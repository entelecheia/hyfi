{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HyFI: Hydra Fast Interface","text":"<p>HyFI, short for Hydra Fast Interface, is a powerful Python framework built atop the foundations of Hydra and Pydantic. Its main objective is to provide a streamlined interface for configuring, structuring, executing, and scaling Python applications and workflows.</p> <ul> <li>Documentation</li> <li>GitHub Repository</li> <li>PyPI Package</li> </ul>"},{"location":"#overview","title":"Overview","text":"<p>In the modern world of software and data science, creating scalable, reproducible, and modular Python workflows is vital. HyFI is here to make that process not just feasible but also efficient and straightforward. It has been meticulously crafted to help developers and researchers build pipeline-oriented projects and promote shareable and reproducible workflows.</p>"},{"location":"#core-features","title":"Core Features","text":""},{"location":"#1-dynamic-configuration-management","title":"1. Dynamic Configuration Management","text":"<ul> <li>Modular Configuration: Harness the power of Hydra and Pydantic to manage your application configurations dynamically and modularity.</li> <li>Seamless Command Line Overrides: Experiment swiftly without the clutter of multiple similar configuration files.</li> <li>Jupyter Notebook Integration: The HyFI class allows for easy composition of configurations even in a jupyter notebook setting.</li> </ul>"},{"location":"#2-zero-boilerplate","title":"2. Zero Boilerplate","text":"<p>Stay focused on your core problems. HyFI takes care of the usual overheads such as command line flags, loading configuration files, and logging.</p>"},{"location":"#3-structured-workflows","title":"3. Structured Workflows","text":"<ul> <li> <p>Configurable Automated Processes: Divide your research into unit jobs or tasks, and then bundle them into workflows.</p> </li> <li> <p>Versatility: Have the liberty to create multiple workflows, with each performing varied sets of tasks.</p> </li> </ul>"},{"location":"#4-reproducibility-and-sharing","title":"4. Reproducibility and Sharing","text":"<ul> <li> <p>Sharing Capability: Share your datasets, models, and configurations effortlessly.</p> </li> <li> <p>Reproducibility: Sharing configurations alongside datasets and models ensures that every piece of research can be replicated.</p> </li> <li> <p>Granular or Holistic: Choose to share individual unit jobs or an entire workflow, as per your need.</p> </li> </ul>"},{"location":"#5-support-for-plugins","title":"5. Support for Plugins","text":"<ul> <li>Integration of HyFI-based Applications: Enhance your project by plugging in several HyFI-based applications. This allows you to leverage the functionalities of plugins along with their specific configuration files.</li> <li>Modular Design Enablement: The plugin support fosters a truly modular design approach, enabling seamless integration of various components and features, thereby promoting greater flexibility and extensibility in your projects.</li> </ul>"},{"location":"#other-noteworthy-features","title":"Other Noteworthy Features:","text":"<ul> <li>Workspace Management: Automatic workspace creation and environment variable management.</li> <li>Task Pipelining: Chain and parallelize jobs and steps seamlessly.</li> <li>Optimized Parallelism: Efficient job batching with the help of Joblib.</li> <li>Dotenv Integration: Manage configurations via .env files with ease.</li> <li>Built-in Commands: Simplify processes like initializing projects, running pipelines, and copying files.</li> <li>Extensibility: Easily extend HyFI's capabilities by crafting new Config classes and utilizing the building blocks it offers.</li> <li>Command Line Interface (CLI): Access a suite of commands and workflows directly from the command line.</li> <li>Advanced Logging: Make use of the integrated logging configurations, complemented by Hydra logging.</li> <li>Robust Caching: Cache both files and data efficiently.</li> </ul>"},{"location":"#citation","title":"Citation","text":"<pre><code>@software{lee_2023_8247719,\n  author       = {Young Joon Lee},\n  title        = {HyFI: Hydra Fast Interface},\n  month        = aug,\n  year         = 2023,\n  publisher    = {Zenodo},\n  doi          = {10.5281/zenodo.8247719},\n  url          = {https://doi.org/10.5281/zenodo.8247719}\n}\n</code></pre> <pre><code>@software{lee_2023_hyfi,\n  author       = {Young Joon Lee},\n  title        = {HyFI: Hydra Fast Interface},\n  year         = 2023,\n  publisher    = {GitHub},\n  url          = {https://github.com/entelecheia/hyfi}\n}\n</code></pre>"},{"location":"#changelog","title":"Changelog","text":"<p>See the CHANGELOG for more information.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please see the contributing guidelines for more information.</p>"},{"location":"#license","title":"License","text":"<p>This project is released under the MIT License.</p> <p>Check out the usage section for further information.</p> <p>Note</p> <p>This project is under active development.</p>"},{"location":"examples/","title":"HyFI Example","text":"<p>This Jupyter Notebook demonstrates the usage of the <code>hyfi</code> package, including initializing a workspace, mounting Google Drive on Colab, and using HyFI to manage configurations.</p> <p>First, let's import the necessary functions and classes from the <code>hyfi</code> package.</p> <pre><code>from hyfi import HyFI\n</code></pre>"},{"location":"examples/#about-the-hyfi-package","title":"About the <code>hyfi</code> package","text":"<p>Now, let's check the version of the <code>hyfi</code> package we are using.</p> <pre><code>HyFI.print_about()\n</code></pre>"},{"location":"examples/#initialize-project","title":"Initialize Project","text":"<p>We'll initialize the project using the <code>HyFI.initialize</code> function. The function takes the following parameters:</p> <ul> <li><code>project_name</code>: Name of the project to use.</li> <li><code>project_description</code>: Description of the project that will be used.</li> <li><code>project_root</code>: Root directory of the project.</li> <li><code>project_workspace_name</code>: Name of the project's workspace directory.</li> <li><code>global_hyfi_root</code>: Root directory of the global hyfi.</li> <li><code>global_workspace_name</code>: Name of the global hierachical workspace directory.</li> <li><code>num_workers</code>: Number of workers to run.</li> <li><code>logging_level</code>: Log level for the log.</li> <li><code>autotime</code>: Whether to automatically set time and / or keep track of run times.</li> <li><code>retina</code>: Whether to use retina or not.</li> <li><code>verbose</code>: Enables or disables logging</li> </ul> <p>We'll check if we're running in Google Colab, and if so, we'll mount Google Drive.</p> <pre><code>if HyFI.is_colab():\n    HyFI.mount_google_drive()\n\nh = HyFI.initialize(\n    project_name=\"hyfi\",\n    logging_level=\"DEBUG\",\n    verbose=True,\n)\n\nprint(\"project_dir:\", h.project.root_dir)\nprint(\"project_workspace_dir:\", h.project.workspace_dir)\n</code></pre>"},{"location":"examples/#compose-configuration","title":"Compose Configuration","text":"<p>We can use the <code>HyFI.compose</code> function to load a configuration file. In this example, we'll use the default workflow configuration file.</p> <pre><code>cfg = HyFI.compose(\"workflow=__init__\")\n</code></pre>"},{"location":"examples/#display-configuration","title":"Display Configuration","text":"<p>Now, let's print the loaded configuration using the <code>HyFI.print</code> function.</p> <pre><code>HyFI.print(cfg)\n</code></pre> <p>That's it! This example demonstrated the basic usage of the <code>hyfi</code> package. You can now use this package to manage your own projects and tasks in a structured manner.</p>"},{"location":"configs/","title":"Configurations","text":""},{"location":"configs/#configyaml","title":"<code>config.yaml</code>","text":"<pre><code># @package _global_\ndefaults:\n  - _self_\n  - about: __init__\n  - cmd: null\n  - mode: __init__\n  - variables: __init__\n\n  - override hydra/help: help\n  - override hydra/hydra_logging: colorlog\n  - override hydra/job_logging: colorlog\n</code></pre>"},{"location":"configs/about/","title":"about","text":"<p>Config location: <code>conf/about</code></p>"},{"location":"configs/about/#__init__yaml","title":"<code>__init__.yaml</code>","text":"<pre><code>_open_link_: false\nname: HyFI\nauthors: Young Joon Lee &lt;entelecheia@hotmail.com&gt;\ndescription: Hydra Fast Interface (Hydra and Pydantic based interface framework)\nhomepage: https://hyfi.entelecheia.ai\nlicense: MIT\n</code></pre>"},{"location":"configs/batch/","title":"batch","text":"<p>Config location: <code>conf/batch</code></p>"},{"location":"configs/batch/#__init__yaml","title":"<code>__init__.yaml</code>","text":"<pre><code>_config_group_: /batch\n_config_name_: __init__\nbatch_name: ${oc.select:..batch_name,${._config_name_}}\nbatch_num:\nbatch_num_auto: false\nbatch_root: ${oc.select:..task_root,workspace}/${oc.select:..task_name,outputs}\noutput_suffix:\noutput_extention:\nrandom_seed: false\nseed: -1\nresume_run: false\nresume_latest: false\ndevice: cpu\nnum_devices: 1\nnum_workers: ${oc.select:..project.num_workers,1}\nconfig_dirname: ${oc.select:..path.dirnames.config_dirname,configs}\nconfig_yaml: ${oc.select:..path.dirnames.config_yaml,config.yaml}\nconfig_json: ${oc.select:..path.dirnames.config_json,config.json}\nverbose: ${oc.select:..verbose,false}\n</code></pre>"},{"location":"configs/cmd/","title":"cmd","text":"<p>Config location: <code>conf/cmd</code></p>"},{"location":"configs/cmd/#__init__yaml","title":"<code>__init__.yaml</code>","text":"<pre><code># @package _global_\n_target_: hyfi.HyFI.run_command\n</code></pre>"},{"location":"configs/cmd/#aboutyaml","title":"<code>about.yaml</code>","text":"<pre><code># @package _global_\ndefaults:\n  - __init__\n\ncmd_name: about\n</code></pre>"},{"location":"configs/cmd/#copy_confyaml","title":"<code>copy_conf.yaml</code>","text":"<pre><code># @package _global_\ndefaults:\n  - __init__\n  - /copier: __init__\n\ncmd_name: copy_conf\ncopier:\n  src_path: ${__hyfi_path__:}/conf\n  dst_path: workpsace/tmp/conf\n</code></pre>"},{"location":"configs/cmd/#run_taskyaml","title":"<code>run_task.yaml</code>","text":"<pre><code># @package _global_\ndefaults:\n  - __init__\n  - /task: __init__\n\ncmd_name: run_task\n</code></pre>"},{"location":"configs/cmd/#run_workflowyaml","title":"<code>run_workflow.yaml</code>","text":"<pre><code># @package _global_\ndefaults:\n  - __init__\n  - /workflow: __init__\n\ncmd_name: run_workflow\n</code></pre>"},{"location":"configs/composer/","title":"composer","text":"<p>Config location: <code>conf/composer</code></p>"},{"location":"configs/composer/#__init__yaml","title":"<code>__init__.yaml</code>","text":"<pre><code>_target_: hyfi.composer.model.BaseModel\n_config_name_: __init__\n_config_group_: /composer\n</code></pre>"},{"location":"configs/copier/","title":"copier","text":"<p>Config location: <code>conf/copier</code></p>"},{"location":"configs/copier/#__init__yaml","title":"<code>__init__.yaml</code>","text":"<pre><code># Source path where to find the template.\nsrc_path: conf\n# Destination path where to render the template.\ndst_path: workspace/tmp/conf\n# Filetypes to copy.\nfiletypes:\n  - yaml\n  - yml\n  - py\n# User-chosen additional file exclusion patterns.\nexclude:\n# If `True`, exclude files that match the patterns for testing. (default: True)\nexclude_test_files: true\n# Skip files that already exist?\nskip_if_exists: false\n# Delete `dst_path` if there's an error?\ncleanup_on_error: false\n# When `True`, Overwrite files that already exist, without asking.\noverwrite: false\n# When `True`, produce no real rendering.\ndryrun: false\n# When `True`, show all output.\nverbose: true\n</code></pre>"},{"location":"configs/env/","title":"env","text":"<p>Config location: <code>conf/env</code></p>"},{"location":"configs/env/#__init__yaml","title":"<code>__init__.yaml</code>","text":"<pre><code>DOTENV_FILENAME: .env\nDOTENV_DIR: ${oc.select:..path.runtime,.}\nDOTENV_FILE: ${.DOTENV_DIR}/${.DOTENV_FILENAME}\n# Internal\nHYFI_SECRETS_DIR: ${.DOTENV_DIR}/secrets\nHYFI_RESOURCE_DIR:\nHYFI_GLOBAL_ROOT:\nHYFI_GLOBAL_WORKSPACE_NAME:\nHYFI_PROJECT_NAME:\nHYFI_PROJECT_DESC:\nHYFI_PROJECT_ROOT:\nHYFI_PROJECT_WORKSPACE_NAME:\nHYFI_LOG_LEVEL: WARNING\nHYFI_VERBOSE: false\nHYFI_NUM_WORKERS:\nCACHED_PATH_CACHE_ROOT:\n</code></pre>"},{"location":"configs/env/#__project__yaml","title":"<code>__project__.yaml</code>","text":"<pre><code>defaults:\n  - __init__\n\n# For other packages\nCUDA_DEVICE_ORDER:\nCUDA_VISIBLE_DEVICES:\nWANDB_PROJECT:\nWANDB_DISABLED:\nWANDB_DIR:\nWANDB_NOTEBOOK_NAME:\nWANDB_SILENT:\nLABEL_STUDIO_SERVER:\nKMP_DUPLICATE_LIB_OK:\nTOKENIZERS_PARALLELISM:\n# API Keys and Tokens\nWANDB_API_KEY:\nHUGGING_FACE_HUB_TOKEN:\nOPENAI_API_KEY:\nECOS_API_KEY:\nFRED_API_KEY:\nNASDAQ_API_KEY:\nHF_USER_ACCESS_TOKEN:\n</code></pre>"},{"location":"configs/joblib/","title":"joblib","text":"<p>Config location: <code>conf/joblib</code></p>"},{"location":"configs/joblib/#__init__yaml","title":"<code>__init__.yaml</code>","text":"<pre><code>backend: joblib\ninitialize_backend: true\nminibatch_size: 1_000\nnum_workers: ${oc.select:..num_workers,1}\nnum_gpus: 0\nverbose: false\n</code></pre>"},{"location":"configs/mode/","title":"mode","text":"<p>Config location: <code>conf/mode</code></p>"},{"location":"configs/mode/#__debug__yaml","title":"<code>__debug__.yaml</code>","text":"<pre><code># @package _global_\ndefaults:\n  - __info__\n\ndebug_mode: true\nignore_warnings: false\nlogging_level: DEBUG\n</code></pre>"},{"location":"configs/mode/#__hydra_debug__yaml","title":"<code>__hydra_debug__.yaml</code>","text":"<pre><code># @package _global_\ndefaults:\n  - __debug__\n\nhydra:\n  verbose: true\n</code></pre>"},{"location":"configs/mode/#__info__yaml","title":"<code>__info__.yaml</code>","text":"<pre><code># @package _global_\ndefaults:\n  - __init__\n\nverbose: true\nlogging_level: INFO\n</code></pre>"},{"location":"configs/mode/#__init__yaml","title":"<code>__init__.yaml</code>","text":"<pre><code># @package _global_\ndebug_mode: false\nnoop: false\ndryrun: false\nresolve: true\nverbose: false\nversion: ${__app_version__:}\nignore_warnings: true\nlogging_level: WARNING\nhydra_log_dir: ${oc.select:project.global_hyfi_root, ${alt:${oc.env:HYFI_GLOBAL_ROOT,null},${__home_path__:}}}/${oc.select:project.global_workspace_name, ${alt:${oc.env:HYFI_GLOBAL_WORKSPACE_NAME,null},.hyfi}}/logs/hydra\n\nhydra:\n  job:\n    name: ${oc.select:project.project_name, ${oc.select:task.project.project_name, ${alt:${oc.env:HYFI_PROJECT_NAME,null},hyfi}}}\n    chdir: true\n  run:\n    dir: ${hydra_log_dir}/${hydra.job.name}/${now:%Y-%m-%d}/${now:%Y-%m-%d_%H-%M-%S}\n  sweep:\n    dir: ${hydra_log_dir}/${hydra.job.name}/multiruns/${now:%Y-%m-%d}/${now:%Y-%m-%d_%H-%M-%S}\n    subdir: ${hydra.job.num}\n  verbose: false\n  job_logging:\n    handlers:\n      console:\n        level: ${hydra.job_logging.root.level}\n      file:\n        level: ${hydra.job_logging.root.level}\n    root:\n      level: ${logging_level}\n</code></pre>"},{"location":"configs/module/","title":"module","text":"<p>Config location: <code>conf/module</code></p>"},{"location":"configs/module/#__init__yaml","title":"<code>__init__.yaml</code>","text":"<pre><code>library_dir: ${oc.select:..path.task_library, libs}\nmodules:\n</code></pre>"},{"location":"configs/path/","title":"path","text":"<p>Config location: <code>conf/path</code></p>"},{"location":"configs/path/#__batch__yaml","title":"<code>__batch__.yaml</code>","text":"<pre><code>defaults:\n  - __task__\n\n_config_name_: __batch__\nbatch_name: ${oc.select:..batch_name,__batch__}\n</code></pre>"},{"location":"configs/path/#__init__yaml","title":"<code>__init__.yaml</code>","text":"<pre><code>---\n# This file defines the path variables used in the project.\n# internal paths for hyfi\ndefaults:\n  - dirnames: __init__\n\n_config_group_: /path\n_config_name_: __init__\n</code></pre>"},{"location":"configs/path/#__project__yaml","title":"<code>__project__.yaml</code>","text":"<pre><code>---\n# This file defines the path variables used in the project.\n# internal paths for hyfi\ndefaults:\n  - __init__\n\n_config_name_: __project__\nhome: ${__home_path__:}\nhyfi: ${__hyfi_path__:}\npackage: ${__package_path__:}\nresources: ${alt:${oc.env:HYFI_RESOURCE_DIR,null},${.hyfi}/resources}\nruntime: ${get_original_cwd:}\n# global paths\nglobal_hyfi_root: ${oc.select:..global_hyfi_root,${alt:${oc.env:HYFI_GLOBAL_ROOT,null},${__home_path__:}}}\nglobal_workspace_name: ${oc.select:..global_workspace_name,${alt:${oc.env:HYFI_GLOBAL_WORKSPACE_NAME,null},.hyfi}}\n# project specific paths\nproject_name: ${oc.select:..project_name,${alt:${oc.env:HYFI_PROJECT_NAME,null},hyfi}}\nproject_root: ${oc.select:..project_root,${alt:${oc.env:HYFI_PROJECT_ROOT,null},${get_original_cwd:}}}\nproject_workspace_name: ${oc.select:..project_workspace_name,${alt:${oc.env:HYFI_PROJECT_WORKSPACE_NAME,null},workspace}}\n</code></pre>"},{"location":"configs/path/#__task__yaml","title":"<code>__task__.yaml</code>","text":"<pre><code>task_name: ${oc.select:..task_name,__test__}\ntask_root: ${oc.select:..task_root,workspace}\n</code></pre>"},{"location":"configs/pipe/","title":"pipe","text":"<p>Config location: <code>conf/pipe</code></p>"},{"location":"configs/pipe/#__dataframe__yaml","title":"<code>__dataframe__.yaml</code>","text":"<pre><code>defaults:\n  - __init__\n\ncolumns_to_apply:\nuse_batcher: false\nnum_workers: 1\n</code></pre>"},{"location":"configs/pipe/#__dataframe_external_funcs__yaml","title":"<code>__dataframe_external_funcs__.yaml</code>","text":"<pre><code>defaults:\n  - __dataframe__\n\npipe_target: hyfi.pipe.dataframe_external_funcs\n</code></pre>"},{"location":"configs/pipe/#__dataframe_instance_methods__yaml","title":"<code>__dataframe_instance_methods__.yaml</code>","text":"<pre><code>defaults:\n  - __dataframe__\n\npipe_target: hyfi.pipe.dataframe_instance_methods\n</code></pre>"},{"location":"configs/pipe/#__general_external_funcs__yaml","title":"<code>__general_external_funcs__.yaml</code>","text":"<pre><code>defaults:\n  - __init__\n\npipe_target: hyfi.pipe.general_external_funcs\n</code></pre>"},{"location":"configs/pipe/#__general_instance_methods__yaml","title":"<code>__general_instance_methods__.yaml</code>","text":"<pre><code>defaults:\n  - __init__\n\npipe_target: hyfi.pipe.general_instance_methods\n</code></pre>"},{"location":"configs/pipe/#__init__yaml","title":"<code>__init__.yaml</code>","text":"<pre><code># _target_:\npipe_target:\nname:\ndesc:\nenv:\nuse_pipe_obj: true # if true, the pipe target function will be called with the pipe object as the first argument\npipe_obj_arg_name: # if use_pipe_obj is true, the pipe object will be passed to the pipe target function with this argument name\nreturn_pipe_obj: false # if true, the pipe target function will return the pipe object instead of the return value\nverbose: false\n</code></pre>"},{"location":"configs/pipe/#dataframe_combine_str_columnsyaml","title":"<code>dataframe_combine_str_columns.yaml</code>","text":"<pre><code>defaults:\n- __general_external_funcs__\n- /run: dataframe_combine_str_columns\nuse_pipe_obj: true\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#dataframe_dropyaml","title":"<code>dataframe_drop.yaml</code>","text":"<pre><code>defaults:\n- __general_external_funcs__\n- /run: dataframe_drop\nuse_pipe_obj: true\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#dataframe_drop_columnsyaml","title":"<code>dataframe_drop_columns.yaml</code>","text":"<pre><code>defaults:\n- __general_external_funcs__\n- /run: dataframe_drop_columns\nuse_pipe_obj: true\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#dataframe_eval_columnsyaml","title":"<code>dataframe_eval_columns.yaml</code>","text":"<pre><code>defaults:\n- __general_external_funcs__\n- /run: dataframe_eval_columns\nuse_pipe_obj: true\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#dataframe_eval_columns_with_pd_evalyaml","title":"<code>dataframe_eval_columns_with_pd_eval.yaml</code>","text":"<pre><code>defaults:\n- __general_external_funcs__\n- /run: dataframe_eval_columns_with_pd_eval\nuse_pipe_obj: true\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#dataframe_print_head_and_tailyaml","title":"<code>dataframe_print_head_and_tail.yaml</code>","text":"<pre><code>defaults:\n- __general_external_funcs__\n- /run: dataframe_print_head_and_tail\nuse_pipe_obj: true\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#dataframe_select_columnsyaml","title":"<code>dataframe_select_columns.yaml</code>","text":"<pre><code>defaults:\n- __general_external_funcs__\n- /run: dataframe_select_columns\nuse_pipe_obj: true\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#dataframe_split_str_columnyaml","title":"<code>dataframe_split_str_column.yaml</code>","text":"<pre><code>defaults:\n- __general_external_funcs__\n- /run: dataframe_split_str_column\nuse_pipe_obj: true\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#dataset_remove_columnsyaml","title":"<code>dataset_remove_columns.yaml</code>","text":"<pre><code>defaults:\n  - __general_instance_methods__\n\nrun:\n  _target_: remove_columns\n  column_names:\n  new_fingerprint:\nverbose: true\n</code></pre>"},{"location":"configs/pipe/#dataset_to_pandasyaml","title":"<code>dataset_to_pandas.yaml</code>","text":"<pre><code>defaults:\n  - __general_instance_methods__\n\nrun:\n  _target_: to_pandas\nverbose: true\n</code></pre>"},{"location":"configs/pipe/#dict_to_dataframeyaml","title":"<code>dict_to_dataframe.yaml</code>","text":"<pre><code>defaults:\n- __general_external_funcs__\n- /run: dict_to_dataframe\nuse_pipe_obj: true\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#filter_and_sample_datayaml","title":"<code>filter_and_sample_data.yaml</code>","text":"<pre><code>defaults:\n- __dataframe_external_funcs__\n- /run: filter_and_sample_data\nuse_pipe_obj: true\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#filter_data_by_queriesyaml","title":"<code>filter_data_by_queries.yaml</code>","text":"<pre><code>defaults:\n- __dataframe_external_funcs__\n- /run: filter_data_by_queries\nuse_pipe_obj: true\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#load_datayaml","title":"<code>load_data.yaml</code>","text":"<pre><code>defaults:\n- __general_external_funcs__\n- /run: load_data\nuse_pipe_obj: false\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#load_dataframeyaml","title":"<code>load_dataframe.yaml</code>","text":"<pre><code>defaults:\n- __dataframe_external_funcs__\n- /run: load_dataframe\nuse_pipe_obj: false\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#load_dataframesyaml","title":"<code>load_dataframes.yaml</code>","text":"<pre><code>defaults:\n- __dataframe_external_funcs__\n- /run: load_dataframes\nuse_pipe_obj: false\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#load_datasetyaml","title":"<code>load_dataset.yaml</code>","text":"<pre><code>defaults:\n- __general_external_funcs__\n- /run: load_dataset\nuse_pipe_obj: false\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#load_dataset_from_diskyaml","title":"<code>load_dataset_from_disk.yaml</code>","text":"<pre><code>defaults:\n- __general_external_funcs__\n- /run: load_dataset_from_disk\nuse_pipe_obj: false\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#merge_dataframesyaml","title":"<code>merge_dataframes.yaml</code>","text":"<pre><code>defaults:\n- __general_external_funcs__\n- /run: merge_dataframes\nuse_pipe_obj: true\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#records_to_dataframeyaml","title":"<code>records_to_dataframe.yaml</code>","text":"<pre><code>defaults:\n- __general_external_funcs__\n- /run: records_to_dataframe\nuse_pipe_obj: true\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#sample_datayaml","title":"<code>sample_data.yaml</code>","text":"<pre><code>defaults:\n- __dataframe_external_funcs__\n- /run: sample_data\nuse_pipe_obj: true\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#sample_datasetyaml","title":"<code>sample_dataset.yaml</code>","text":"<pre><code>defaults:\n- __general_external_funcs__\n- /run: sample_dataset\nuse_pipe_obj: true\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#save_dataframesyaml","title":"<code>save_dataframes.yaml</code>","text":"<pre><code>defaults:\n- __dataframe_external_funcs__\n- /run: save_dataframes\nuse_pipe_obj: true\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#save_dataset_to_diskyaml","title":"<code>save_dataset_to_disk.yaml</code>","text":"<pre><code>defaults:\n- __general_external_funcs__\n- /run: save_dataset_to_disk\nuse_pipe_obj: true\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipe/#split_dataframeyaml","title":"<code>split_dataframe.yaml</code>","text":"<pre><code>defaults:\n- __general_external_funcs__\n- /run: split_dataframe\nuse_pipe_obj: true\npipe_obj_arg_name: null\nreturn_pipe_obj: false\n</code></pre>"},{"location":"configs/pipeline/","title":"pipeline","text":"<p>Config location: <code>conf/pipeline</code></p>"},{"location":"configs/pipeline/#__init__yaml","title":"<code>__init__.yaml</code>","text":"<pre><code>steps:\ninitial_object:\nuse_task_as_initial_object: false\n</code></pre>"},{"location":"configs/project/","title":"project","text":"<p>Config location: <code>conf/project</code></p>"},{"location":"configs/project/#__init__yaml","title":"<code>__init__.yaml</code>","text":"<pre><code>defaults:\n  - /env: __init__\n  - /joblib: __init__\n  - /path: __project__\n\n_config_group_: /project\n_config_name_: __init__\nproject_name: ${alt:${oc.env:HYFI_PROJECT_NAME,null},${alt:${__package_name__:},hyfi}}\nproject_description: ${oc.env:HYFI_PROJECT_DESC,\"\"}\nproject_root: ${alt:${oc.env:HYFI_PROJECT_ROOT,null},${.global_hyfi_root}/${.global_workspace_name}/projects/${.project_name}}\nproject_workspace_name: ${alt:${oc.env:HYFI_PROJECT_WORKSPACE_NAME,null},workspace}\nglobal_hyfi_root: ${alt:${oc.env:HYFI_GLOBAL_ROOT,null},${__home_path__:}}\nglobal_workspace_name: ${alt:${oc.env:HYFI_GLOBAL_WORKSPACE_NAME,null},.hyfi}\nnum_workers: ${oc.env:HYFI_NUM_WORKERS,1}\nuse_huggingface_hub: false\nuse_wandb: false\nverbose: ${alt:${oc.env:HYFI_VERBOSE,null},false}\n</code></pre>"},{"location":"configs/run/","title":"run","text":"<p>Config location: <code>conf/run</code></p>"},{"location":"configs/run/#__help__yaml","title":"<code>__help__.yaml</code>","text":"<pre><code>defaults:\n  - __init__\n\n_description_: |\n  A template for run configuration to instantiate a partial function.\n  List all parameters to the partial function at the root level except for the first parameter, which is the pipe object.\n  If the first parameter is not the pipe object, set use_pipe_obj to false in the pipe configuration and set the first parameter name in pipe_obj_arg_name.\n\n  from the 'pipe' configuration:\n  use_pipe_obj: true # if true, the pipe target function will be called with the pipe object as the first argument\n  pipe_obj_arg_name: # if use_pipe_obj is true, the pipe object will be passed to the pipe target function with this argument name\n</code></pre>"},{"location":"configs/run/#__init__yaml","title":"<code>__init__.yaml</code>","text":"<pre><code>_target_: null\n_partial_: true\n</code></pre>"},{"location":"configs/run/#dataframe_combine_str_columnsyaml","title":"<code>dataframe_combine_str_columns.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.basic.DSBasic.dataframe_combine_str_columns\ncolumns: null\nsep: null\nfillna: null\nnew_column_name: null\ndrop_old_columns: false\nverbose: false\n</code></pre>"},{"location":"configs/run/#dataframe_dropyaml","title":"<code>dataframe_drop.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.basic.DSBasic.dataframe_drop\nlabels: null\naxis: 1\nlevel: null\nerrors: raise\nverbose: false\n</code></pre>"},{"location":"configs/run/#dataframe_drop_columnsyaml","title":"<code>dataframe_drop_columns.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.basic.DSBasic.dataframe_drop_columns\ncolumns: null\nlevel: null\nerrors: raise\nverbose: false\n</code></pre>"},{"location":"configs/run/#dataframe_eval_columnsyaml","title":"<code>dataframe_eval_columns.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.basic.DSBasic.dataframe_eval_columns\nexpressions: null\nengine: python\nverbose: false\n</code></pre>"},{"location":"configs/run/#dataframe_eval_columns_with_pd_evalyaml","title":"<code>dataframe_eval_columns_with_pd_eval.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.basic.DSBasic.dataframe_eval_columns_with_pd_eval\nexpressions: null\nengine: python\nverbose: false\n</code></pre>"},{"location":"configs/run/#dataframe_print_head_and_tailyaml","title":"<code>dataframe_print_head_and_tail.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.basic.DSBasic.dataframe_print_head_and_tail\nnum_heads: 5\nnum_tails: 5\ncolumns: null\nverbose: false\n</code></pre>"},{"location":"configs/run/#dataframe_select_columnsyaml","title":"<code>dataframe_select_columns.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.basic.DSBasic.dataframe_select_columns\ncolumns: null\nverbose: false\n</code></pre>"},{"location":"configs/run/#dataframe_split_str_columnyaml","title":"<code>dataframe_split_str_column.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.basic.DSBasic.dataframe_split_str_column\ncolumn: null\nsep: null\nnew_column_name: null\ndrop_old_column: false\nverbose: false\n</code></pre>"},{"location":"configs/run/#dict_to_dataframeyaml","title":"<code>dict_to_dataframe.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.utils.DSUtils.dict_to_dataframe\norient: columns\ndtype: null\ncolumns: null\n</code></pre>"},{"location":"configs/run/#filter_and_sample_datayaml","title":"<code>filter_and_sample_data.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.slice.DSSlice.filter_and_sample_data\nqueries: null\nsample_size: null\nsample_seed: 42\noutput_dir: .\nsample_filename: null\ntrain_filename: train.parquet\ndiscard_filename: null\nreturning_data: train\nverbose: false\n</code></pre>"},{"location":"configs/run/#filter_data_by_queriesyaml","title":"<code>filter_data_by_queries.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.slice.DSSlice.filter_data_by_queries\nqueries: null\nverbose: false\n</code></pre>"},{"location":"configs/run/#load_datayaml","title":"<code>load_data.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.load.DSLoad.load_data\npath: pandas\nname: null\ndata_dir: null\ndata_files: null\nsplit: train\nfiletype: null\nconcatenate: false\nuse_cached: false\nverbose: false\n</code></pre>"},{"location":"configs/run/#load_dataframeyaml","title":"<code>load_dataframe.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.load.DSLoad.load_dataframe\ndata_file: null\ndata_dir: null\nfiletype: null\ncolumns: null\nindex_col: null\nverbose: false\n</code></pre>"},{"location":"configs/run/#load_dataframesyaml","title":"<code>load_dataframes.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.load.DSLoad.load_dataframes\ndata_files: null\ndata_dir: null\nfiletype: null\nsplit: null\nconcatenate: false\nignore_index: false\nuse_cached: false\nverbose: false\n</code></pre>"},{"location":"configs/run/#load_datasetyaml","title":"<code>load_dataset.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.load.DSLoad.load_dataset\npath: null\nname: null\ndata_dir: null\ndata_files: null\nsplit: null\ncache_dir: null\nfeatures: null\ndownload_config: null\ndownload_mode: null\nverification_mode: null\nnum_proc: null\n</code></pre>"},{"location":"configs/run/#load_dataset_from_diskyaml","title":"<code>load_dataset_from_disk.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.load.DSLoad.load_dataset_from_disk\ndataset_path: null\nkeep_in_memory: null\nstorage_options: null\nnum_heads: 1\nnum_tails: 1\nverbose: false\n</code></pre>"},{"location":"configs/run/#merge_dataframesyaml","title":"<code>merge_dataframes.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.combine.DSCombine.merge_dataframes\nright: null\nhow: inner\n'on': null\nleft_on: null\nright_on: null\nleft_index: false\nright_index: false\nsort: false\nsuffixes:\n- _x\n- _y\ncopy: true\nindicator: false\nvalidate: null\nverbose: false\n</code></pre>"},{"location":"configs/run/#records_to_dataframeyaml","title":"<code>records_to_dataframe.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.utils.DSUtils.records_to_dataframe\nindex: null\nexclude: null\ncolumns: null\ncoerce_float: false\nnrows: null\n</code></pre>"},{"location":"configs/run/#sample_datayaml","title":"<code>sample_data.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.slice.DSSlice.sample_data\nsample_size_per_group: null\nsample_seed: 123\ngroup_by: null\nvalue_col: null\nremove_columns: null\nverbose: false\n</code></pre>"},{"location":"configs/run/#sample_datasetyaml","title":"<code>sample_dataset.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.slice.DSSlice.sample_dataset\nsplit: null\nsample_size: 100\nsample_seed: 42\nrandomize: true\nnum_heads: 1\nnum_tails: 1\nverbose: false\n</code></pre>"},{"location":"configs/run/#save_dataframesyaml","title":"<code>save_dataframes.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.save.DSSave.save_dataframes\ndata_file: null\ndata_dir: null\ncolumns: null\nindex: false\nfiletype: parquet\nsuffix: null\nverbose: false\n</code></pre>"},{"location":"configs/run/#save_dataset_to_diskyaml","title":"<code>save_dataset_to_disk.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.save.DSSave.save_dataset_to_disk\ndataset_path: null\nmax_shard_size: null\nnum_shards: null\nnum_proc: null\nstorage_options: null\nverbose: false\n</code></pre>"},{"location":"configs/run/#split_dataframeyaml","title":"<code>split_dataframe.yaml</code>","text":"<pre><code>_target_: hyfi.utils.datasets.slice.DSSlice.split_dataframe\nindices_or_sections: null\nverbose: false\n</code></pre>"},{"location":"configs/runner/","title":"runner","text":"<p>Config location: <code>conf/runner</code></p>"},{"location":"configs/runner/#__init__yaml","title":"<code>__init__.yaml</code>","text":"<pre><code>defaults:\n- /path@path: __batch__\n- /batch@batch: __init__\n_target_: hyfi.runner.base.Runner\n_config_name_: __init__\n_config_group_: /runner\nverbose: false\ntask_name: demo-task\ntask_root: workspace\nversion: 0.0.0\nmodule: null\npipelines: []\nbatch_name: demo\ncalls: []\n</code></pre>"},{"location":"configs/task/","title":"task","text":"<p>Config location: <code>conf/task</code></p>"},{"location":"configs/task/#__batch__yaml","title":"<code>__batch__.yaml</code>","text":"<pre><code>defaults:\n  - __init__\n  - /batch: __init__\n  - override /path: __batch__\n\n_config_name_: __batch__\nbatch_name: ${._config_name_}\n</code></pre>"},{"location":"configs/task/#__init__yaml","title":"<code>__init__.yaml</code>","text":"<pre><code>defaults:\n  - /path: __task__\n  - /module: __init__\n\n_config_group_: /task\n_config_name_: __init__\ntask_name: ${._config_name_}\ntask_root: ${oc.select:project.project_root,.}/${oc.select:project.project_workspace_name,workspace}\nversion: ${__version__:}\nverbose: ${oc.select:project.verbose,false}\npipelines:\n</code></pre>"},{"location":"configs/variables/","title":"variables","text":"<p>Config location: <code>conf/variables</code></p>"},{"location":"configs/variables/#__init__yaml","title":"<code>__init__.yaml</code>","text":"<pre><code>hyfi_path: ${__hyfi_path__:}\nhyfi_version: ${__hyfi_version__:}\npackage_name: ${__package_name__:}\npackage_path: ${__package_path__:}\napp_version: ${__app_version__:}\nversion: ${__app_version__:}\nconfig_module_path: ${__config_module_path__:}\nuser_config_path: ${__user_config_path__:}\nhome_path: ${__home_path__:}\nproject_root_path: ${__project_root_path__:}\nproject_workspace_path: ${__project_workspace_path__:}\n</code></pre>"},{"location":"configs/workflow/","title":"workflow","text":"<p>Config location: <code>conf/workflow</code></p>"},{"location":"configs/workflow/#__init__yaml","title":"<code>__init__.yaml</code>","text":"<pre><code># @package _global_\ndefaults:\n  - /project: __init__\n  # - /task: __init__\n\n_config_group_: /workflow\n_config_name_: __init__\nworkflow_name: ${._config_name_}\nverbose: false\ntasks:\n  # - task\npipelines:\n  # - pipeline\n</code></pre>"},{"location":"reference/cli/","title":"<code>hyfi.__cli__</code>","text":"<p>This module contains the command line interface for the <code>hyfi</code> package. It is implemented using the <code>hydra</code> package. You can run the CLI by executing the <code>hyfi</code> command.</p> <p>Command line interface for HyFI</p>"},{"location":"reference/cli/#hyfi.__cli__.cli_main","title":"<code>cli_main(cfg)</code>","text":"<p>Main function for the command line interface. Initializes Hydra and instantiates the class. Prints the configuration to standard out if verbose is set to True</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>DictConfig</code> <p>Configuration dictionary to be used for instantiation</p> required <p>Returns:</p> Type Description <code>None</code> <p>None if everything went fine otherwise an error is raised</p> <code>None</code> <p>to indicate the reason for the failure</p> Source code in <code>hyfi/__cli__.py</code> <pre><code>def cli_main(cfg: DictConfig) -&gt; None:\n    \"\"\"\n    Main function for the command line interface.\n    Initializes Hydra and instantiates the class.\n    Prints the configuration to standard out if verbose is set to True\n\n    Args:\n        cfg: Configuration dictionary to be used for instantiation\n\n    Returns:\n        None if everything went fine otherwise an error is raised\n        to indicate the reason for the failure\n    \"\"\"\n    hyfi = HyFI(**cfg)\n\n    # Print out the command line interface for the application.\n    if hyfi.verbose:\n        app_name = hyfi.app_name\n        print(f\"## Command Line Interface for {app_name} ##\")\n\n        # Prints the configuration to the console.\n        if hyfi.resolve:\n            logger.info(\"## hydra configuration resolved ##\")\n            hyfi.print(cfg)\n        else:\n            logger.info(\"## hydra configuration ##\")\n            print(hyfi.to_yaml(cfg))\n\n        logger.info(\"Hydra working directory : %s\", os.getcwd())\n        logger.info(\"Orig working directory  : %s\", hydra.utils.get_original_cwd())\n\n    hyfi.run_config(config=cfg, dryrun=hyfi.dryrun)\n    hyfi.terminate()\n</code></pre>"},{"location":"reference/cli/#hyfi.__cli__.hydra_main","title":"<code>hydra_main(config_path=None, config_name=None, overrides=None, plugins=None)</code>","text":"<p>Main function for the command line interface of Hydra</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Optional[str]</code> <p>The config path, a directory where Hydra will search for             config files. This path is added to Hydra's searchpath.             Relative paths are interpreted relative to the declaring python             file. Alternatively, you can use the prefix <code>pkg://</code> to specify             a python package to add to the searchpath.             If config_path is None no directory is added to the Config search path.</p> <code>None</code> <code>config_name</code> <code>Optional[str]</code> <p>The name of the config (usually the file name without the .yaml extension)</p> <code>None</code> Source code in <code>hyfi/__cli__.py</code> <pre><code>def hydra_main(\n    config_path: Optional[str] = None,\n    config_name: Optional[str] = None,\n    overrides: Optional[List[str]] = None,\n    plugins: Optional[List[str]] = None,\n) -&gt; None:\n    \"\"\"\n    Main function for the command line interface of Hydra\n\n    Args:\n        config_path: The config path, a directory where Hydra will search for\n                        config files. This path is added to Hydra's searchpath.\n                        Relative paths are interpreted relative to the declaring python\n                        file. Alternatively, you can use the prefix `pkg://` to specify\n                        a python package to add to the searchpath.\n                        If config_path is None no directory is added to the Config search path.\n        config_name: The name of the config (usually the file name without the .yaml extension)\n    \"\"\"\n    hyfi_main(config_path, config_name, overrides, plugins)\n</code></pre>"},{"location":"reference/cli/#hyfi.__cli__.hyfi_main","title":"<code>hyfi_main(config_path=None, config_name=None, overrides=None, plugins=None)</code>","text":"<p>Main function for the command line interface of Hydra</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Optional[str]</code> <p>The config path, a directory where Hydra will search for             config files. This path is added to Hydra's searchpath.             Relative paths are interpreted relative to the declaring python             file. Alternatively, you can use the prefix <code>pkg://</code> to specify             a python package to add to the searchpath.             If config_path is None no directory is added to the Config search path.</p> <code>None</code> <code>config_name</code> <code>Optional[str]</code> <p>The name of the config (usually the file name without the .yaml extension)</p> <code>None</code> Source code in <code>hyfi/__cli__.py</code> <pre><code>def hyfi_main(\n    config_path: Optional[str] = None,\n    config_name: Optional[str] = None,\n    overrides: Optional[List[str]] = None,\n    plugins: Optional[List[str]] = None,\n) -&gt; None:\n    \"\"\"\n    Main function for the command line interface of Hydra\n\n    Args:\n        config_path: The config path, a directory where Hydra will search for\n                        config files. This path is added to Hydra's searchpath.\n                        Relative paths are interpreted relative to the declaring python\n                        file. Alternatively, you can use the prefix `pkg://` to specify\n                        a python package to add to the searchpath.\n                        If config_path is None no directory is added to the Config search path.\n        config_name: The name of the config (usually the file name without the .yaml extension)\n    \"\"\"\n    if global_hyfi.user_config_path:\n        sys.argv.append(f\"--config-dir={global_hyfi.user_config_path}\")\n    if not config_path:\n        config_path = global_hyfi.config_module_path\n    if not config_name:\n        config_name = global_hyfi.config_name\n    if not plugins:\n        plugins = global_hyfi.plugins\n    if global_hyfi.package_name != global_hyfi.hyfi_package_name:\n        overrides = overrides or []\n        override = f\"about={global_hyfi.package_name}\"\n        if override not in overrides:\n            overrides.append(override)\n            logger.debug(\n                \"Overriding `about` config group with `%s`\",\n                global_hyfi.package_name,\n            )\n    hyfi_hydra_main(\n        config_path=config_path,\n        config_name=config_name,\n        version_base=global_hyfi.hydra_version_base,\n        overrides=overrides,\n        plugins=plugins,\n    )(cli_main)()\n</code></pre>"},{"location":"reference/click/","title":"<code>hyfi.__click__</code>","text":"<p>This module contains the command line interface for the <code>hyfi</code> package. It is implemented using the <code>click</code> package. You can run the CLI by executing the <code>hyfi-run</code> command.</p>"},{"location":"reference/click/#cli","title":"cli","text":"<p>This is the auxiliary command line interface for Hyfi. The main command line interface is 'hyfi'.</p> <p>It is used to help run HyFI applications. If no command is specified, it will compose a configuration and run it.</p> <p>It is also used to copy configuration files to the destination directory and to install shell completion for Hyfi.</p> <p>:param click.core.Context ctx: Click context.</p> <p>Usage:</p> <pre><code>cli [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --version          Show the version and exit.\n  -c, --config TEXT  Config group to compose and run\n  -p, --print        Print the configuration instead of running it\n  --help             Show this message and exit.\n</code></pre>"},{"location":"reference/click/#about","title":"about","text":"<p>Print the about information for Hyfi.</p> <p>Usage:</p> <pre><code>cli about [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"reference/click/#cc","title":"cc","text":"<p>Copy all config files to the destination directory.</p> <p>Usage:</p> <pre><code>cli cc [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --src_path TEXT   Source path to copy from  [default: hyfi/conf]\n  --dst_path TEXT   Destination path to copy to  [default: ./tmp/conf]\n  --exclude TEXT    Exclude files matching this pattern\n  --skip_if_exists  Skip if destination exists\n  --overwrite       Overwrite destination\n  --dry_run         Dry run\n  --verbose         Verbose output\n  --help            Show this message and exit.\n</code></pre>"},{"location":"reference/click/#sc","title":"sc","text":"<p>Install or Uninstall shell completion for Hyfi.</p> <p>Usage:</p> <pre><code>cli sc [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -u, --uninstall   Uninstall shell completion\n  -s, --shell TEXT  Shell to install completion for  [default: zsh]\n  --help            Show this message and exit.\n</code></pre>"},{"location":"reference/about/","title":"<code>hyfi.about</code>","text":""},{"location":"reference/about/#hyfi.about.About","title":"<code>About</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A Pydantic BaseModel that contains metadata about the package.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The display name of the package.</p> <code>authors</code> <code>str</code> <p>The author(s) of the package.</p> <code>description</code> <code>str</code> <p>A brief description of the package.</p> <code>homepage</code> <code>str</code> <p>The URL of the package's homepage.</p> <code>license</code> <code>str</code> <p>The license under which the package is distributed.</p> Source code in <code>hyfi/about/about.py</code> <pre><code>class About(BaseModel):\n    \"\"\"A Pydantic BaseModel that contains metadata about the package.\n\n    Attributes:\n        name (str): The display name of the package.\n        authors (str): The author(s) of the package.\n        description (str): A brief description of the package.\n        homepage (str): The URL of the package's homepage.\n        license (str): The license under which the package is distributed.\n    \"\"\"\n\n    _config_group_: str = \"/about\"\n    _auto_populate_: bool = True\n\n    name: str = __hyfi_name__\n    authors: str = __hyfi_authors__\n    description: str = __hyfi_description__\n    homepage: str = __hyfi_homepage__\n    license: str = __hyfi_license__\n</code></pre>"},{"location":"reference/batch/","title":"<code>hyfi.batch</code>","text":""},{"location":"reference/batch/#hyfi.batch.Batch","title":"<code>Batch</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration class for batch processing.</p> <p>Attributes:</p> Name Type Description <code>batch_name</code> <code>str</code> <p>Name of the batch.</p> <code>batch_num</code> <code>Optional[int]</code> <p>Number of the batch. If None, it will be set to -1.</p> <code>batch_root</code> <code>str</code> <p>Root directory for the batch.</p> <code>output_suffix</code> <code>str</code> <p>Suffix to be added to the output file name.</p> <code>output_extention</code> <code>str</code> <p>Extension of the output file.</p> <code>random_seed</code> <code>bool</code> <p>Whether to use a random seed for the batch.</p> <code>seed</code> <code>int</code> <p>Seed to be used for the batch. If random_seed is True or seed is None or negative, a random seed will be generated.</p> <code>resume_run</code> <code>bool</code> <p>Whether to resume a previous run of the batch.</p> <code>resume_latest</code> <code>bool</code> <p>Whether to resume the latest run of the batch.</p> <code>device</code> <code>str</code> <p>Device to be used for the batch.</p> <code>num_devices</code> <code>int</code> <p>Number of devices to be used for the batch.</p> <code>num_workers</code> <code>int</code> <p>Number of workers to be used for the batch.</p> <code>config_yaml</code> <code>str</code> <p>Name of the YAML configuration file.</p> <code>config_json</code> <code>str</code> <p>Name of the JSON configuration file.</p> <code>config_dirname</code> <code>str</code> <p>Name of the directory for the configuration files.</p> Source code in <code>hyfi/batch/batch.py</code> <pre><code>class Batch(BaseConfig):\n    \"\"\"\n    Configuration class for batch processing.\n\n    Attributes:\n        batch_name (str): Name of the batch.\n        batch_num (Optional[int]): Number of the batch. If None, it will be set to -1.\n        batch_root (str): Root directory for the batch.\n        output_suffix (str): Suffix to be added to the output file name.\n        output_extention (str): Extension of the output file.\n        random_seed (bool): Whether to use a random seed for the batch.\n        seed (int): Seed to be used for the batch. If random_seed is True or seed is None or negative, a random seed will be generated.\n        resume_run (bool): Whether to resume a previous run of the batch.\n        resume_latest (bool): Whether to resume the latest run of the batch.\n        device (str): Device to be used for the batch.\n        num_devices (int): Number of devices to be used for the batch.\n        num_workers (int): Number of workers to be used for the batch.\n        config_yaml (str): Name of the YAML configuration file.\n        config_json (str): Name of the JSON configuration file.\n        config_dirname (str): Name of the directory for the configuration files.\n    \"\"\"\n\n    _config_name_: str = \"__init__\"\n    _config_group_: str = \"/batch\"\n\n    batch_name: str = \"batch\"\n    batch_num: int = -1\n    batch_num_auto: bool = False\n    batch_root: str = \"workspace/outputs\"\n    output_suffix: str = \"\"\n    output_extention: str = \"\"\n    random_seed: bool = False\n    seed: int = -1\n    resume_run: bool = False\n    resume_latest: bool = False\n    device: str = \"cpu\"\n    num_devices: int = 1\n    num_workers: int = 1\n    config_yaml: str = \"config.yaml\"\n    config_json: str = \"config.json\"\n    config_dirname: str = \"configs\"\n\n    _property_set_methods_ = {\n        \"batch_num\": \"set_batch_num\",\n    }\n\n    def __init__(self, **data):\n        \"\"\"\n        Initializes the BatchConfig object.\n\n        Args:\n            **data (dict): Dictionary containing the configuration data.\n        \"\"\"\n        super().__init__(**data)\n        self.set_batch_num(data.get(\"batch_num\"))\n\n    def set_batch_num(self, val: Optional[int] = None):\n        \"\"\"\n        Sets the batch number.\n\n        Args:\n            val (int): Batch number.\n        \"\"\"\n        if val is None or val &lt; 0 and self.batch_num_auto:\n            num_files = len(list(self.config_dir.glob(self.config_filepattern)))\n            self.batch_num = (\n                num_files - 1 if self.resume_latest and num_files &gt; 0 else num_files\n            )\n            if self.verbose:\n                logger.info(\n                    \"Init batch - Batch name: %s, Batch num: %s\",\n                    self.batch_name,\n                    self.batch_num,\n                )\n\n    @field_validator(\"batch_num\", mode=\"before\")\n    def _validate_batch_num(cls, v):\n        \"\"\"\n        Validates the batch number.\n\n        Args:\n            v (int): Batch number.\n\n        Returns:\n            int: Validated batch number.\n        \"\"\"\n        return v if v is not None else -1\n\n    @field_validator(\"batch_num_auto\", mode=\"before\")\n    def _validate_batch_num_auto(cls, v, info: ValidationInfo):\n        \"\"\"\n        Validates the batch number auto flag.\n\n        Args:\n            v (int): Batch number auto flag.\n\n        Returns:\n            int: Validated batch number auto flag.\n        \"\"\"\n        batch_num = info.data[\"batch_num\"]\n        return batch_num is None or batch_num &lt; 0\n\n    @field_validator(\"seed\")\n    def _validate_seed(cls, v, info: ValidationInfo):\n        \"\"\"\n        Validates the seed.\n\n        Args:\n            v (int): Seed.\n            info (ValidationInfo): Validation information.\n\n        Returns:\n            int: Validated seed.\n        \"\"\"\n        if info.data[\"random_seed\"] or v is None or v &lt; 0:\n            random.seed()\n            seed = random.randint(0, 2**32 - 1)\n            if info.data.get(\"verbose\"):\n                logger.info(f\"Setting seed to {seed}\")\n            return seed\n        return v\n\n    @field_validator(\"output_suffix\", mode=\"before\")\n    def _validate_output_suffix(cls, v):\n        \"\"\"\n        Validates the output suffix.\n\n        Args:\n            v (str): Output suffix.\n\n        Returns:\n            str: Validated output suffix.\n        \"\"\"\n        return v or \"\"\n\n    @field_validator(\"output_extention\", mode=\"before\")\n    def _validate_output_extention(cls, v):\n        return v.strip(\".\") if v else \"\"\n\n    @property\n    def root_dir(self) -&gt; Path:\n        \"\"\"\n        Root directory for the batch.\n        \"\"\"\n        return Path(self.batch_root).absolute()\n\n    @property\n    def batch_dir(self) -&gt; Path:\n        \"\"\"\n        Returns the path to the batch directory.\n        \"\"\"\n        return self.root_dir / self.batch_name\n\n    @property\n    def batch_id(self) -&gt; str:\n        \"\"\"\n        Prefix for the output file name.\n        \"\"\"\n        return f\"{self.batch_name}({self.batch_num})\"\n\n    @property\n    def output_file(self) -&gt; str:\n        \"\"\"\n        Output file name.\n        \"\"\"\n        if self.output_suffix:\n            return f\"{self.batch_id}_{self.output_suffix}.{self.output_extention}\"\n        else:\n            return f\"{self.batch_id}.{self.output_extention}\"\n\n    @property\n    def config_filename(self) -&gt; str:\n        \"\"\"\n        Name of the YAML configuration file.\n        \"\"\"\n        return f\"{self.batch_id}_{self.config_yaml}\"\n\n    @property\n    def config_jsonfile(self) -&gt; str:\n        \"\"\"\n        Name of the JSON configuration file.\n        \"\"\"\n        return f\"{self.batch_id}_{self.config_json}\"\n\n    @property\n    def config_filepattern(self) -&gt; str:\n        \"\"\"\n        File pattern for the configuration files.\n        \"\"\"\n        return f\"{self.batch_name}(*)_{self.config_yaml}\"\n\n    @property\n    def config_dir(self) -&gt; Path:\n        \"\"\"\n        Directory for the configuration files.\n        \"\"\"\n        return self.batch_dir / self.config_dirname\n\n    @property\n    def config_filepath(self) -&gt; Path:\n        \"\"\"\n        Path to the YAML configuration file.\n        \"\"\"\n        return self.config_dir / self.config_filename\n\n    @property\n    def config_jsonpath(self) -&gt; Path:\n        \"\"\"\n        Path to the JSON configuration file.\n        \"\"\"\n        return self.config_dir / self.config_jsonfile\n</code></pre>"},{"location":"reference/batch/#hyfi.batch.Batch.batch_dir","title":"<code>batch_dir: Path</code>  <code>property</code>","text":"<p>Returns the path to the batch directory.</p>"},{"location":"reference/batch/#hyfi.batch.Batch.batch_id","title":"<code>batch_id: str</code>  <code>property</code>","text":"<p>Prefix for the output file name.</p>"},{"location":"reference/batch/#hyfi.batch.Batch.config_dir","title":"<code>config_dir: Path</code>  <code>property</code>","text":"<p>Directory for the configuration files.</p>"},{"location":"reference/batch/#hyfi.batch.Batch.config_filename","title":"<code>config_filename: str</code>  <code>property</code>","text":"<p>Name of the YAML configuration file.</p>"},{"location":"reference/batch/#hyfi.batch.Batch.config_filepath","title":"<code>config_filepath: Path</code>  <code>property</code>","text":"<p>Path to the YAML configuration file.</p>"},{"location":"reference/batch/#hyfi.batch.Batch.config_filepattern","title":"<code>config_filepattern: str</code>  <code>property</code>","text":"<p>File pattern for the configuration files.</p>"},{"location":"reference/batch/#hyfi.batch.Batch.config_jsonfile","title":"<code>config_jsonfile: str</code>  <code>property</code>","text":"<p>Name of the JSON configuration file.</p>"},{"location":"reference/batch/#hyfi.batch.Batch.config_jsonpath","title":"<code>config_jsonpath: Path</code>  <code>property</code>","text":"<p>Path to the JSON configuration file.</p>"},{"location":"reference/batch/#hyfi.batch.Batch.output_file","title":"<code>output_file: str</code>  <code>property</code>","text":"<p>Output file name.</p>"},{"location":"reference/batch/#hyfi.batch.Batch.root_dir","title":"<code>root_dir: Path</code>  <code>property</code>","text":"<p>Root directory for the batch.</p>"},{"location":"reference/batch/#hyfi.batch.Batch.__init__","title":"<code>__init__(**data)</code>","text":"<p>Initializes the BatchConfig object.</p> <p>Parameters:</p> Name Type Description Default <code>**data</code> <code>dict</code> <p>Dictionary containing the configuration data.</p> <code>{}</code> Source code in <code>hyfi/batch/batch.py</code> <pre><code>def __init__(self, **data):\n    \"\"\"\n    Initializes the BatchConfig object.\n\n    Args:\n        **data (dict): Dictionary containing the configuration data.\n    \"\"\"\n    super().__init__(**data)\n    self.set_batch_num(data.get(\"batch_num\"))\n</code></pre>"},{"location":"reference/batch/#hyfi.batch.Batch.set_batch_num","title":"<code>set_batch_num(val=None)</code>","text":"<p>Sets the batch number.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>int</code> <p>Batch number.</p> <code>None</code> Source code in <code>hyfi/batch/batch.py</code> <pre><code>def set_batch_num(self, val: Optional[int] = None):\n    \"\"\"\n    Sets the batch number.\n\n    Args:\n        val (int): Batch number.\n    \"\"\"\n    if val is None or val &lt; 0 and self.batch_num_auto:\n        num_files = len(list(self.config_dir.glob(self.config_filepattern)))\n        self.batch_num = (\n            num_files - 1 if self.resume_latest and num_files &gt; 0 else num_files\n        )\n        if self.verbose:\n            logger.info(\n                \"Init batch - Batch name: %s, Batch num: %s\",\n                self.batch_name,\n                self.batch_num,\n            )\n</code></pre>"},{"location":"reference/composer/","title":"<code>hyfi.composer</code>","text":""},{"location":"reference/composer/#hyfi.composer.BaseConfig","title":"<code>BaseConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for all config classes.</p> Source code in <code>hyfi/composer/config.py</code> <pre><code>class BaseConfig(BaseModel):\n    \"\"\"\n    Base class for all config classes.\n    \"\"\"\n\n    _config_name_: str = \"__init__\"\n    _auto_populate_: bool = True\n\n    verbose: bool = False\n\n    _init_args_: Dict[str, Any] = {}\n    _property_set_methods_: Dict[str, str] = {}\n    _subconfigs_: Dict[str, Any] = {}\n\n    def __init__(self, **config_kwargs):\n        logger.debug(\n            \"init %s with %s args\", self.__class__.__name__, len(config_kwargs)\n        )\n        super().__init__(**config_kwargs)\n        # self.initialize_subconfigs(config_kwargs)\n        self._init_args_ = config_kwargs.copy()\n\n    def __setattr__(self, key, val):\n        \"\"\"\n        Overrides the default __setattr__ method to allow for custom property set methods.\n\n        Args:\n            key (str): The name of the attribute to set.\n            val (Any): The value to set the attribute to.\n        \"\"\"\n        if method := self._property_set_methods_.get(key):  # type: ignore\n            logger.debug(\n                \"Setting %s to %s\",\n                key,\n                val if isinstance(val, (str, int)) else type(val),\n            )\n            getattr(self, method)(val)\n        super().__setattr__(key, val)\n\n    def export_config(\n        self,\n        exclude: Optional[Union[str, List[str], Set[str], None]] = None,\n        exclude_none: bool = True,\n        only_include: Optional[Union[str, List[str], Set[str], None]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Export the configuration to a dictionary.\n\n        Args:\n            exclude (Optional[Union[str, List[str], Set[str], None]]): Keys to exclude from the saved configuration.\n                Defaults to None.\n            exclude_none (bool): Whether to exclude keys with None values. Defaults to True.\n            only_include (Optional[Union[str, List[str], Set[str], None]]): Keys to include in the saved configuration.\n                Defaults to None.\n\n        Returns:\n            Dict[str, Any]: The configuration dictionary.\n        \"\"\"\n        if not exclude:\n            exclude = self._exclude_  # type: ignore\n        if isinstance(exclude, str):\n            exclude = [exclude]\n        if exclude is None:\n            exclude = []\n        if isinstance(only_include, str):\n            only_include = [only_include]\n        if only_include is None:\n            only_include = []\n\n        config = self.model_dump(exclude=exclude, exclude_none=exclude_none)  # type: ignore\n        if only_include:\n            config = {key: config[key] for key in only_include if key in config}\n\n        return config\n\n    def save_config(\n        self,\n        filepath: Union[str, Path],\n        exclude: Optional[Union[str, List[str], Set[str], None]] = None,\n        exclude_none: bool = True,\n        only_include: Optional[Union[str, List[str], Set[str], None]] = None,\n    ) -&gt; str:\n        \"\"\"\n        Save the batch configuration to file.\n\n        Args:\n            filepath ([Union[str, Path]): The filepath to save the configuration to.\n            exclude (Optional[Union[str, List[str], Set[str], None]]): Keys to exclude from the saved configuration.\n                Defaults to None.\n            exclude_none (bool): Whether to exclude keys with None values. Defaults to True.\n            only_include (Optional[Union[str, List[str], Set[str], None]]): Keys to include in the saved configuration.\n                Defaults to None.\n\n        Returns:\n            str: The filename of the saved configuration.\n        \"\"\"\n        logger.info(\"Saving config to %s\", filepath)\n\n        config_to_save = self.export_config(\n            exclude=exclude, exclude_none=exclude_none, only_include=only_include\n        )\n\n        Composer.save(config_to_save, filepath)\n        return str(filepath)\n\n    def save_config_as_json(\n        self,\n        filepath: Union[str, Path],\n        exclude: Optional[Union[str, List[str], Set[str], None]] = None,\n        exclude_none: bool = True,\n        only_include: Optional[Union[str, List[str], Set[str], None]] = None,\n    ) -&gt; str:\n        def dumper(obj):\n            return Composer.to_dict(obj) if isinstance(obj, DictConfig) else str(obj)\n\n        config_to_save = self.export_config(\n            exclude=exclude, exclude_none=exclude_none, only_include=only_include\n        )\n        logger.info(\"Saving config to %s\", filepath)\n        Composer.save_json(config_to_save, filepath, default=dumper)\n        return str(filepath)\n\n    def print_config(\n        self,\n    ):\n        Composer.print(self.model_dump())\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.BaseConfig.__setattr__","title":"<code>__setattr__(key, val)</code>","text":"<p>Overrides the default setattr method to allow for custom property set methods.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the attribute to set.</p> required <code>val</code> <code>Any</code> <p>The value to set the attribute to.</p> required Source code in <code>hyfi/composer/config.py</code> <pre><code>def __setattr__(self, key, val):\n    \"\"\"\n    Overrides the default __setattr__ method to allow for custom property set methods.\n\n    Args:\n        key (str): The name of the attribute to set.\n        val (Any): The value to set the attribute to.\n    \"\"\"\n    if method := self._property_set_methods_.get(key):  # type: ignore\n        logger.debug(\n            \"Setting %s to %s\",\n            key,\n            val if isinstance(val, (str, int)) else type(val),\n        )\n        getattr(self, method)(val)\n    super().__setattr__(key, val)\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.BaseConfig.export_config","title":"<code>export_config(exclude=None, exclude_none=True, only_include=None)</code>","text":"<p>Export the configuration to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>exclude</code> <code>Optional[Union[str, List[str], Set[str], None]]</code> <p>Keys to exclude from the saved configuration. Defaults to None.</p> <code>None</code> <code>exclude_none</code> <code>bool</code> <p>Whether to exclude keys with None values. Defaults to True.</p> <code>True</code> <code>only_include</code> <code>Optional[Union[str, List[str], Set[str], None]]</code> <p>Keys to include in the saved configuration. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The configuration dictionary.</p> Source code in <code>hyfi/composer/config.py</code> <pre><code>def export_config(\n    self,\n    exclude: Optional[Union[str, List[str], Set[str], None]] = None,\n    exclude_none: bool = True,\n    only_include: Optional[Union[str, List[str], Set[str], None]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Export the configuration to a dictionary.\n\n    Args:\n        exclude (Optional[Union[str, List[str], Set[str], None]]): Keys to exclude from the saved configuration.\n            Defaults to None.\n        exclude_none (bool): Whether to exclude keys with None values. Defaults to True.\n        only_include (Optional[Union[str, List[str], Set[str], None]]): Keys to include in the saved configuration.\n            Defaults to None.\n\n    Returns:\n        Dict[str, Any]: The configuration dictionary.\n    \"\"\"\n    if not exclude:\n        exclude = self._exclude_  # type: ignore\n    if isinstance(exclude, str):\n        exclude = [exclude]\n    if exclude is None:\n        exclude = []\n    if isinstance(only_include, str):\n        only_include = [only_include]\n    if only_include is None:\n        only_include = []\n\n    config = self.model_dump(exclude=exclude, exclude_none=exclude_none)  # type: ignore\n    if only_include:\n        config = {key: config[key] for key in only_include if key in config}\n\n    return config\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.BaseConfig.save_config","title":"<code>save_config(filepath, exclude=None, exclude_none=True, only_include=None)</code>","text":"<p>Save the batch configuration to file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>[Union[str, Path]</code> <p>The filepath to save the configuration to.</p> required <code>exclude</code> <code>Optional[Union[str, List[str], Set[str], None]]</code> <p>Keys to exclude from the saved configuration. Defaults to None.</p> <code>None</code> <code>exclude_none</code> <code>bool</code> <p>Whether to exclude keys with None values. Defaults to True.</p> <code>True</code> <code>only_include</code> <code>Optional[Union[str, List[str], Set[str], None]]</code> <p>Keys to include in the saved configuration. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The filename of the saved configuration.</p> Source code in <code>hyfi/composer/config.py</code> <pre><code>def save_config(\n    self,\n    filepath: Union[str, Path],\n    exclude: Optional[Union[str, List[str], Set[str], None]] = None,\n    exclude_none: bool = True,\n    only_include: Optional[Union[str, List[str], Set[str], None]] = None,\n) -&gt; str:\n    \"\"\"\n    Save the batch configuration to file.\n\n    Args:\n        filepath ([Union[str, Path]): The filepath to save the configuration to.\n        exclude (Optional[Union[str, List[str], Set[str], None]]): Keys to exclude from the saved configuration.\n            Defaults to None.\n        exclude_none (bool): Whether to exclude keys with None values. Defaults to True.\n        only_include (Optional[Union[str, List[str], Set[str], None]]): Keys to include in the saved configuration.\n            Defaults to None.\n\n    Returns:\n        str: The filename of the saved configuration.\n    \"\"\"\n    logger.info(\"Saving config to %s\", filepath)\n\n    config_to_save = self.export_config(\n        exclude=exclude, exclude_none=exclude_none, only_include=only_include\n    )\n\n    Composer.save(config_to_save, filepath)\n    return str(filepath)\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.BaseModel","title":"<code>BaseModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for all Pydantic models.</p> <p>Attributes:</p> Name Type Description <code>_config_name_</code> <code>str</code> <p>The name of the model.</p> <code>_config_group_</code> <code>str</code> <p>The group of the model.</p> <code>_auto_populate_</code> <code>bool</code> <p>Whether to auto-populate the model with defaults from the config.</p> <code>_auto_generate_</code> <code>bool</code> <p>Whether to auto-generate the config for the model.</p> Source code in <code>hyfi/composer/model.py</code> <pre><code>class BaseModel(PydanticBaseModel):\n    \"\"\"\n    Base class for all Pydantic models.\n\n    Attributes:\n        _config_name_ (str): The name of the model.\n        _config_group_ (str): The group of the model.\n        _auto_populate_ (bool): Whether to auto-populate the model with defaults from the config.\n        _auto_generate_ (bool): Whether to auto-generate the config for the model.\n\n    \"\"\"\n\n    _config_name_: str = \"__init__\"\n    _config_group_: str = \"/composer\"\n    _auto_populate_: bool = False\n    _auto_generate_: bool = False\n    _exclude_: Set[str] = set()\n    _exclude_keys_ = {\n        \"_exclude_keys_\": True,\n        \"_target_\": True,\n        \"_config_name_\": True,\n        \"_config_group_\": True,\n        \"_auto_populate_\": True,\n        \"_auto_generate_\": True,\n        \"_exclude_\": True,\n    }\n\n    model_config = ConfigDict(\n        arbitrary_types_allowed=True,\n        extra=\"allow\",\n        validate_assignment=False,\n    )  # type: ignore\n\n    @model_validator(mode=\"before\")\n    def validate_model_config_before(cls, data):\n        # logger.debug(\"Validating model config before validating each field.\")\n        _auto_populate_ = data.get(\"_auto_populate_\", getattr(cls._auto_populate_, \"default\", False))  # type: ignore\n        if not _auto_populate_:\n            if global_hyfi.verbosity &gt; 1:\n                logger.debug(\"Auto-populate is disabled for class `%s`.\", cls.__name__)\n            return data\n        _config_name_ = data.get(\"_config_name_\", getattr(cls._config_name_, \"default\", \"__init__\"))  # type: ignore\n        _config_group_ = data.get(\"_config_group_\", getattr(cls._config_group_, \"default\"))  # type: ignore\n        _class_name_ = cls.__name__  # type: ignore\n        if not _config_group_:\n            if global_hyfi.verbosity &gt; 0:\n                logger.debug(\"There is no config group specified.\")\n            return data\n        # Initialize the config with the given config_name.\n        if global_hyfi.verbosity &gt; 1:\n            logger.info(\n                \"Composing `%s` class with `%s` config in `%s` group.\",\n                _class_name_,\n                _config_name_,\n                _config_group_,\n            )\n        config_group = f\"{_config_group_}={_config_name_}\"\n        cfg = Composer.compose_as_dict(\n            config_group=config_group,\n            config_data=data,\n            throw_on_compose_failure=False,\n        )\n        data = Composer.update(cfg, data)\n        # Exclude any attributes specified in the class's `exclude` list.\n        exclude = getattr(cls._exclude_, \"default\", set())  # type: ignore\n        for name in exclude:\n            if name in data:\n                logger.debug(\"Excluding `%s` from the config.\", name)\n                del data[name]  # type: ignore\n        return data\n\n    @property\n    def kwargs(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Returns the model as a dictionary excluding any keys specified in the class's `exclude_keys` list.\n        \"\"\"\n        return self.model_dump(exclude=self._exclude_keys_)\n\n    @property\n    def config_name(self) -&gt; str:\n        \"\"\"\n        Returns the name of the model.\n        \"\"\"\n        return self._config_name_\n\n    @property\n    def config_group(self) -&gt; str:\n        \"\"\"\n        Returns the group of the model.\n        \"\"\"\n        return self._config_group_\n\n    @property\n    def auto_populate(self) -&gt; bool:\n        \"\"\"\n        Returns whether the model should be auto-populated.\n        \"\"\"\n        return self._auto_populate_\n\n    @property\n    def auto_generate(self) -&gt; bool:\n        \"\"\"\n        Returns whether the model should be auto-generated.\n        \"\"\"\n        return self._auto_generate_\n\n    @classmethod\n    def generate_config(\n        cls,\n        config_name: Optional[str] = None,\n        config_path: str = None,\n        config_root: Optional[str] = None,\n        save: bool = True,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Saves a HyFI config for itself.\n\n        Args:\n            cls (BaseModel): The class to generate a config for.\n            config_name (Optional[str]): The name of the config. If not provided, the name of the target will be used.\n            config_path (Optional[str]): The path to save the config to (relative to the config root). Defaults to \"run\".\n            config_root (Optional[str]): The root of the config path. If not provided, the global hyfi config directory will be used.\n            **kwargs_for_target: Keyword arguments to pass to the target.\n        \"\"\"\n\n        target = f\"{cls.__module__}.{cls.__name__}\"\n        cfg = {\n            \"_target_\": target,\n            \"_config_name_\": getattr(cls._config_name_, \"default\"),\n            \"_config_group_\": getattr(cls._config_group_, \"default\"),\n        }\n\n        model_fields = {\n            key: getattr(value, \"default\") for key, value in cls.model_fields.items()\n        }\n        cfg.update(model_fields)\n        cfg = cls.sanitized_config(cfg)\n\n        if not save:\n            return cfg\n\n        config_name = (\n            config_name or getattr(cls._config_name_, \"default\")\n        ) or cls._config_name_\n        _save_config(\n            config=cfg,\n            class_name=cls.__name__,\n            config_group=getattr(cls._config_group_, \"default\"),\n            config_name=config_name,\n            config_path=config_path,\n            config_root=config_root,\n        )\n        return cfg\n\n    @staticmethod\n    def sanitized_config(\n        config: Dict[str, Any],\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts a config to Hydra-supported type if necessary and possible.\n\n        Args:\n            config (Dict[str, Any]): The config to sanitize.\n\n        Returns:\n            Dict[str, Any]: The sanitized config.\n        \"\"\"\n        defaults = []\n        sanitized_config = {}\n        _config = {}\n        for key, value in config.items():\n            if hasattr(value, \"_config_group_\") and hasattr(value, \"_config_name_\"):\n                config_name = (\n                    getattr(value, \"model_extra\", {}).get(\"_config_name_\")\n                    or value._config_name_\n                )\n                if value._config_group_ == key:\n                    defaults.append({f\"{value._config_group_}\": config_name})\n                else:\n                    defaults.append({f\"{value._config_group_}@{key}\": config_name})\n            else:\n                value = sanitized_default_value(value)\n                _config[key] = value\n        if defaults:\n            sanitized_config[\"defaults\"] = defaults\n        sanitized_config.update(_config)\n        return sanitized_config\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.BaseModel.auto_generate","title":"<code>auto_generate: bool</code>  <code>property</code>","text":"<p>Returns whether the model should be auto-generated.</p>"},{"location":"reference/composer/#hyfi.composer.BaseModel.auto_populate","title":"<code>auto_populate: bool</code>  <code>property</code>","text":"<p>Returns whether the model should be auto-populated.</p>"},{"location":"reference/composer/#hyfi.composer.BaseModel.config_group","title":"<code>config_group: str</code>  <code>property</code>","text":"<p>Returns the group of the model.</p>"},{"location":"reference/composer/#hyfi.composer.BaseModel.config_name","title":"<code>config_name: str</code>  <code>property</code>","text":"<p>Returns the name of the model.</p>"},{"location":"reference/composer/#hyfi.composer.BaseModel.kwargs","title":"<code>kwargs: Dict[str, Any]</code>  <code>property</code>","text":"<p>Returns the model as a dictionary excluding any keys specified in the class's <code>exclude_keys</code> list.</p>"},{"location":"reference/composer/#hyfi.composer.BaseModel.generate_config","title":"<code>generate_config(config_name=None, config_path=None, config_root=None, save=True)</code>  <code>classmethod</code>","text":"<p>Saves a HyFI config for itself.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>BaseModel</code> <p>The class to generate a config for.</p> required <code>config_name</code> <code>Optional[str]</code> <p>The name of the config. If not provided, the name of the target will be used.</p> <code>None</code> <code>config_path</code> <code>Optional[str]</code> <p>The path to save the config to (relative to the config root). Defaults to \"run\".</p> <code>None</code> <code>config_root</code> <code>Optional[str]</code> <p>The root of the config path. If not provided, the global hyfi config directory will be used.</p> <code>None</code> <code>**kwargs_for_target</code> <p>Keyword arguments to pass to the target.</p> required Source code in <code>hyfi/composer/model.py</code> <pre><code>@classmethod\ndef generate_config(\n    cls,\n    config_name: Optional[str] = None,\n    config_path: str = None,\n    config_root: Optional[str] = None,\n    save: bool = True,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Saves a HyFI config for itself.\n\n    Args:\n        cls (BaseModel): The class to generate a config for.\n        config_name (Optional[str]): The name of the config. If not provided, the name of the target will be used.\n        config_path (Optional[str]): The path to save the config to (relative to the config root). Defaults to \"run\".\n        config_root (Optional[str]): The root of the config path. If not provided, the global hyfi config directory will be used.\n        **kwargs_for_target: Keyword arguments to pass to the target.\n    \"\"\"\n\n    target = f\"{cls.__module__}.{cls.__name__}\"\n    cfg = {\n        \"_target_\": target,\n        \"_config_name_\": getattr(cls._config_name_, \"default\"),\n        \"_config_group_\": getattr(cls._config_group_, \"default\"),\n    }\n\n    model_fields = {\n        key: getattr(value, \"default\") for key, value in cls.model_fields.items()\n    }\n    cfg.update(model_fields)\n    cfg = cls.sanitized_config(cfg)\n\n    if not save:\n        return cfg\n\n    config_name = (\n        config_name or getattr(cls._config_name_, \"default\")\n    ) or cls._config_name_\n    _save_config(\n        config=cfg,\n        class_name=cls.__name__,\n        config_group=getattr(cls._config_group_, \"default\"),\n        config_name=config_name,\n        config_path=config_path,\n        config_root=config_root,\n    )\n    return cfg\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.BaseModel.sanitized_config","title":"<code>sanitized_config(config)</code>  <code>staticmethod</code>","text":"<p>Converts a config to Hydra-supported type if necessary and possible.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict[str, Any]</code> <p>The config to sanitize.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The sanitized config.</p> Source code in <code>hyfi/composer/model.py</code> <pre><code>@staticmethod\ndef sanitized_config(\n    config: Dict[str, Any],\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts a config to Hydra-supported type if necessary and possible.\n\n    Args:\n        config (Dict[str, Any]): The config to sanitize.\n\n    Returns:\n        Dict[str, Any]: The sanitized config.\n    \"\"\"\n    defaults = []\n    sanitized_config = {}\n    _config = {}\n    for key, value in config.items():\n        if hasattr(value, \"_config_group_\") and hasattr(value, \"_config_name_\"):\n            config_name = (\n                getattr(value, \"model_extra\", {}).get(\"_config_name_\")\n                or value._config_name_\n            )\n            if value._config_group_ == key:\n                defaults.append({f\"{value._config_group_}\": config_name})\n            else:\n                defaults.append({f\"{value._config_group_}@{key}\": config_name})\n        else:\n            value = sanitized_default_value(value)\n            _config[key] = value\n    if defaults:\n        sanitized_config[\"defaults\"] = defaults\n    sanitized_config.update(_config)\n    return sanitized_config\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.BaseSettings","title":"<code>BaseSettings</code>","text":"<p>               Bases: <code>BaseSettings</code>, <code>ENVs</code></p> <p>Configuration class for environment variables in HyFI.</p> <p>!! The variables are read-only and cannot be changed after initialization.</p> Source code in <code>hyfi/composer/settings.py</code> <pre><code>class BaseSettings(PydanticBaseSettings, ENVs):\n    \"\"\"\n    Configuration class for environment variables in HyFI.\n\n    !! The variables are read-only and cannot be changed after initialization.\n    \"\"\"\n\n    \"\"\"Environment variables for HyFI\"\"\"\n\n    _config_name_: str = \"__init__\"\n    _config_group_: str = \"/env\"\n\n    DOTENV_FILENAME: Optional[str] = \".env\"\n    DOTENV_DIR: Optional[str] = None\n    DOTENV_FILE: Optional[str] = None\n    HYFI_SECRETS_DIR: Optional[str] = None\n\n    model_config = SettingsConfigDict(\n        env_prefix=\"\",\n        env_nested_delimiter=\"__\",\n        case_sentive=False,\n        env_file=global_hyfi.dotenv_file,\n        env_file_encoding=\"utf-8\",\n        validate_assignment=True,\n        extra=\"allow\",\n        secrets_dir=global_hyfi.secrets_dir,\n    )  # type: ignore\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: Type[PydanticBaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; Tuple[PydanticBaseSettingsSource, ...]:\n        # BaseSettings.load_dotenv(dotenv_file=global_hyfi.dotenv_file)\n        return (\n            init_settings,\n            file_secret_settings,\n            DotEnvSettingsSource(settings_cls),\n            env_settings,\n        )\n\n    @model_validator(mode=\"before\")  # type: ignore\n    def check_and_set_values(cls, data):\n        if not isinstance(data, dict):\n            return data\n        env_file = os.environ.get(\"DOTENV_FILE\", \"\")\n        if os.path.isfile(env_file):\n            data[\"DOTENV_FILE\"] = env_file\n            dotenv_filename = os.path.basename(env_file)\n            dotenv_dir = os.path.dirname(env_file)\n            data[\"DOTENV_DIR\"] = dotenv_dir\n            data[\"DOTENV_FILENAME\"] = dotenv_filename\n        data[\"HYFI_SECRETS_DIR\"] = global_hyfi.secrets_dir\n        return BaseSettings.check_and_set_osenv_vars(data)\n\n    @property\n    def os(self):\n        \"\"\"Returns the OS environment variables.\"\"\"\n        return os.environ\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.BaseSettings.os","title":"<code>os</code>  <code>property</code>","text":"<p>Returns the OS environment variables.</p>"},{"location":"reference/composer/#hyfi.composer.Composer","title":"<code>Composer</code>","text":"<p>               Bases: <code>UTILs</code>, <code>GENERATOR</code></p> <p>Compose a configuration by applying overrides</p> Source code in <code>hyfi/composer/composer.py</code> <pre><code>class Composer(UTILs, GENERATOR):\n    \"\"\"\n    Compose a configuration by applying overrides\n    \"\"\"\n\n    @staticmethod\n    def hydra_compose(\n        root_config_name: Optional[str] = None,\n        config_module: Optional[str] = None,\n        overrides: Optional[List[str]] = None,\n        plugins: Optional[List[str]] = None,\n    ):\n        is_initialized = GlobalHydra.instance().is_initialized()  # type: ignore\n        config_module = config_module or global_hyfi.config_module\n        plugins = plugins or global_hyfi.plugins\n\n        overrides = overrides or []\n        # by adding the variables=__init__ override,\n        # we can access the variables in the config whenever we want\n        override = \"+variables=__init__\"\n        if override not in overrides:\n            overrides.append(override)\n            logger.debug(\n                \"Overriding `about` config group with `%s`\",\n                global_hyfi.package_name,\n            )\n        # logger.debug(\"config_module: %s\", config_module)\n        if is_initialized:\n            # Hydra is already initialized.\n            # logger.debug(\"Hydra is already initialized\")\n            cfg = hydra.compose(config_name=root_config_name, overrides=overrides)\n        else:\n            with hyfi_hydra.initialize_config(\n                config_module=config_module,\n                config_dir=global_hyfi.user_config_path,\n                plugins=plugins,\n                version_base=global_hyfi.hydra_version_base,\n            ):\n                cfg = hydra.compose(config_name=root_config_name, overrides=overrides)\n        return cfg\n\n    @staticmethod\n    def compose_as_dict(\n        config_group: Optional[str] = None,\n        overrides: Optional[List[str]] = None,\n        config_data: Optional[Union[Dict[str, Any], DictConfig]] = None,\n        throw_on_compose_failure: bool = True,\n        throw_on_resolution_failure: bool = True,\n        throw_on_missing: bool = False,\n        root_config_name: Optional[str] = None,\n        config_module: Optional[str] = None,\n        global_package: bool = False,\n        **kwargs,\n    ) -&gt; Dict:\n        return Composer.to_dict(\n            Composer.compose(\n                config_group=config_group,\n                overrides=overrides,\n                config_data=config_data,\n                throw_on_compose_failure=throw_on_compose_failure,\n                throw_on_resolution_failure=throw_on_resolution_failure,\n                throw_on_missing=throw_on_missing,\n                root_config_name=root_config_name,\n                config_module=config_module,\n                global_package=global_package,\n                **kwargs,\n            )\n        )\n\n    @staticmethod\n    def compose(\n        config_group: Optional[str] = None,\n        overrides: Optional[List[str]] = None,\n        config_data: Optional[Union[Dict[str, Any], DictConfig]] = None,\n        throw_on_compose_failure: bool = True,\n        throw_on_resolution_failure: bool = True,\n        throw_on_missing: bool = False,\n        root_config_name: Optional[str] = None,\n        config_module: Optional[str] = None,\n        global_package: bool = False,\n        **kwargs,\n    ) -&gt; DictConfig:\n        try:\n            return Composer._compose_internal(\n                config_group=config_group,\n                overrides=overrides,\n                config_data=config_data,\n                throw_on_resolution_failure=throw_on_resolution_failure,\n                throw_on_missing=throw_on_missing,\n                root_config_name=root_config_name,\n                config_module=config_module,\n                global_package=global_package,\n                **kwargs,\n            )\n        except Exception as e:\n            logger.error(\"Error composing config: %s\", e)\n            if throw_on_compose_failure:\n                raise e\n            return DictConfig(config_data) if config_data else DictConfig({})\n\n    @staticmethod\n    def _compose_internal(\n        config_group: Optional[str] = None,\n        overrides: Optional[List[str]] = None,\n        config_data: Optional[Union[Dict[str, Any], DictConfig]] = None,\n        throw_on_resolution_failure: bool = True,\n        throw_on_missing: bool = False,\n        root_config_name: Optional[str] = None,\n        config_module: Optional[str] = None,\n        global_package: bool = False,\n        **kwargs,\n    ) -&gt; DictConfig:\n        if isinstance(config_data, DictConfig):\n            logger.debug(\"returning config_data without composing\")\n            return config_data\n        cg = ConfigGroup(config_group=config_group)\n        overrides = cg.get_overrides(\n            overrides=overrides,\n            root_config_name=root_config_name,\n            config_module=config_module,\n        )\n\n        logger.debug(f\"compose config with overrides: {overrides}\")\n        # Initialize hydra and return the configuration.\n        cfg = Composer.hydra_compose(\n            root_config_name=root_config_name,\n            config_module=config_module,\n            overrides=overrides,\n        )\n        # Add config group overrides to overrides list.\n        global_package = global_package or cg.global_package\n        if cg.group_key and not global_package:\n            group_overrides: List[str] = []\n            group_cfg = Composer.select(\n                cfg,\n                key=cg.group_key,\n                default=None,\n                throw_on_missing=False,\n                throw_on_resolution_failure=False,\n            )\n            if config_data and group_cfg:\n                group_overrides.extend(\n                    (\n                        f\"{cg.group_key}.{k}='{v}'\"\n                        if isinstance(v, str)\n                        else f\"{cg.group_key}.{k}={v}\"\n                    )\n                    for k, v in config_data.items()\n                    if isinstance(v, (str, int, float, bool)) and k in group_cfg\n                )\n            if group_overrides:\n                overrides.extend(group_overrides)\n                cfg = Composer.hydra_compose(\n                    root_config_name=root_config_name,\n                    config_module=config_module,\n                    overrides=overrides,\n                )\n\n            # Select the group_key from the configuration.\n            cfg = Composer.select(\n                cfg,\n                key=cg.group_key,\n                default=None,\n                throw_on_missing=throw_on_missing,\n                throw_on_resolution_failure=throw_on_resolution_failure,\n            )\n        return cfg\n\n    @staticmethod\n    def is_composable(\n        config_group: str,\n        config_module: Optional[str] = None,\n    ) -&gt; bool:\n        \"\"\"\n        Determines whether the input configuration object is composable.\n\n        Args:\n            config_group (str): The name of the configuration group to check.\n            config_module (Optional[str], optional): The name of the configuration module to check. Defaults to None.\n\n        Returns:\n            bool: True if the configuration object is composable, False otherwise.\n        \"\"\"\n        try:\n            cfg = Composer.compose(\n                config_group=config_group,\n                config_module=config_module,\n            )\n            return cfg is not None\n        except Exception as e:\n            logger.error(\"Error composing config: %s\", e)\n            return False\n\n    @staticmethod\n    def is_instantiatable(cfg: Any):\n        \"\"\"\n        Determines whether the input configuration object is instantiatable.\n\n        Args:\n            cfg (Any): The configuration object to check.\n\n        Returns:\n            bool: True if the configuration object is instantiatable, False otherwise.\n        \"\"\"\n        return Composer.is_config(cfg) and SpecialKeys.TARGET in cfg\n\n    @staticmethod\n    def replace_special_keys(_dict: Mapping[str, Any]) -&gt; Mapping:\n        \"\"\"\n        Replace special keys in a dictionary.\n\n        Args:\n            _dict (Mapping[str, Any]): The dictionary to update.\n\n        Returns:\n            Mapping: The updated dictionary.\n        \"\"\"\n        _new_dict = {}\n        for k, v in _dict.items():\n            key = Composer.generate_alias_for_special_keys(k)\n            if isinstance(v, collections.abc.Mapping):\n                _new_dict[key] = Composer.replace_special_keys(v)\n            else:\n                _new_dict[key] = v\n        return _new_dict\n\n    @staticmethod\n    def generate_alias_for_special_keys(key: str) -&gt; str:\n        \"\"\"\n        Generate an alias for special keys.\n        _with_ -&gt; run\n        _pipe_ -&gt; pipe_target\n        _run_ -&gt; run\n\n        Args:\n            key (str): The special key to generate an alias for.\n\n        Returns:\n            str: The alias for the special key.\n        \"\"\"\n        # replace the exact `with`, `pipe` with `run_with`, `run_pipe`\n        key_ = re.sub(r\"^with$\", \"run\", key)\n        # replace the prefix `_` with `run_`\n        key_ = re.sub(r\"^_with_$\", \"run\", key_)\n        key_ = re.sub(r\"^_pipe_$\", \"pipe_target\", key_)\n        key_ = re.sub(r\"^_run_$\", \"run\", key_)\n        return key_\n\n    @staticmethod\n    def partial(\n        config: Union[str, Dict],\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; Callable:\n        \"\"\"\n        Returns a callable object that is a partial version of the function or class specified in the config object.\n\n        Args:\n            config: An config object describing what to call and what params to use.\n                    In addition to the parameters, the config must contain:\n                    _target_ : target class or callable name (str)\n                    And may contain:\n                    _partial_: If True, return functools.partial wrapped method or object\n                                False by default. Configure per target.\n            args: Optional positional parameters pass-through\n            kwargs: Optional named parameters to override\n                    parameters in the config object. Parameters not present\n                    in the config objects are being passed as is to the target.\n                    IMPORTANT: dataclasses instances in kwargs are interpreted as config\n                                and cannot be used as passthrough\n        Returns:\n            A callable object that is a partial version of the function or class specified in the config object.\n        \"\"\"\n        if isinstance(config, str):\n            config = {SpecialKeys.TARGET.value: config}\n        else:\n            config = Composer.to_dict(config)\n        if not isinstance(config, dict):\n            raise ValueError(\"config must be a dict or a str\")\n        config[SpecialKeys.PARTIAL.value] = True\n        rc_kwargs_ = config.pop(SpecialKeys.KWARGS, {})\n        if rc_kwargs_ and kwargs:\n            kwargs.update(rc_kwargs_)\n        return Composer.instantiate(config, *args, **kwargs)\n\n    @staticmethod\n    def instantiate(config: Any, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Instantiates an object using the provided config object.\n\n        Args:\n            config: An config object describing what to call and what params to use.\n                    In addition to the parameters, the config must contain:\n                    _target_ : target class or callable name (str)\n                    And may contain:\n                    _args_: List-like of positional arguments to pass to the target\n                    _recursive_: Construct nested objects as well (bool).\n                                    False by default.\n                                    may be overridden via a _recursive_ key in\n                                    the kwargs\n                    _convert_: Conversion strategy\n                            none    : Passed objects are DictConfig and ListConfig, default\n                            partial : Passed objects are converted to dict and list, with\n                                    the exception of Structured Configs (and their fields).\n                            all     : Passed objects are dicts, lists and primitives without\n                                    a trace of OmegaConf containers\n                    _partial_: If True, return functools.partial wrapped method or object\n                                False by default. Configure per target.\n                    _args_: List-like of positional arguments\n            args: Optional positional parameters pass-through\n            kwargs: Optional named parameters to override\n                    parameters in the config object. Parameters not present\n                    in the config objects are being passed as is to the target.\n                    IMPORTANT: dataclasses instances in kwargs are interpreted as config\n                                and cannot be used as passthrough\n\n        Returns:\n            if _target_ is a class name: the instantiated object\n            if _target_ is a callable: the return value of the call\n        \"\"\"\n        verbose = config.get(\"verbose\", False)\n        if not Composer.is_instantiatable(config):\n            if verbose:\n                logger.info(\"Config is not instantiatable, returning config\")\n            return config\n        _recursive_ = config.get(SpecialKeys.RECURSIVE, False)\n        if SpecialKeys.RECURSIVE not in kwargs:\n            kwargs[SpecialKeys.RECURSIVE.value] = _recursive_\n        if verbose:\n            logger.info(\"instantiating %s ...\", config.get(SpecialKeys.TARGET))\n        return hydra.utils.instantiate(config, *args, **kwargs)\n\n    @staticmethod\n    def getsource(obj: Any) -&gt; str:\n        \"\"\"\n        Return the source code of the object.\n\n        Args:\n            obj: The object to get the source code of.\n\n        Returns:\n            The source code of the object as a string.\n\n        \"\"\"\n        try:\n            target_string = \"\"\n            if Composer.is_config(obj):\n                if SpecialKeys.TARGET in obj:\n                    target_string = obj[SpecialKeys.TARGET]\n            elif isinstance(obj, str):\n                target_string = obj\n            return UTILs.getsource(target_string) if target_string else \"\"\n        except Exception as e:\n            logger.error(f\"Error getting source: {e}\")\n            return \"\"\n\n    @staticmethod\n    def viewsource(obj: Any):\n        \"\"\"\n        Print the source code of the object.\n\n        Args:\n            obj: The object to print the source code of.\n\n        \"\"\"\n        print(Composer.getsource(obj))\n\n    @staticmethod\n    def instantiate_config(\n        config_group: Optional[str] = None,\n        overrides: Optional[List[str]] = None,\n        config_data: Optional[Union[Dict[str, Any], DictConfig]] = None,\n        global_package: bool = False,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"\n        Instantiates an object using the provided config group and overrides.\n\n        Args:\n            config_group: Name of the config group to compose (`config_group=name`)\n            overrides: List of config groups to apply overrides to (`overrides=[\"override_name\"]`)\n            config_data: Keyword arguments to override config group values (will be converted to overrides of the form `config_group_name.key=value`)\n            global_package: If True, the config assumed to be a global package\n            args: Optional positional parameters pass-through\n            kwargs: Optional named parameters to override\n                    parameters in the config object. Parameters not present\n                    in the config objects are being passed as is to the target.\n                    IMPORTANT: dataclasses instances in kwargs are interpreted as config\n                                and cannot be used as passthrough\n\n        Returns:\n            if _target_ is a class name: the instantiated object\n            if _target_ is a callable: the return value of the call\n        \"\"\"\n        cfg = Composer.compose(\n            config_group=config_group,\n            overrides=overrides,\n            config_data=config_data,\n            global_package=global_package,\n        )\n        return Composer.instantiate(cfg, *args, **kwargs)\n\n    @staticmethod\n    def print_config(\n        config_group: Optional[str] = None,\n        overrides: Optional[List[str]] = None,\n        config_data: Optional[Union[Dict[str, Any], DictConfig]] = None,\n        global_package: bool = False,\n    ):\n        \"\"\"\n        Print the configuration\n\n        Args:\n            config_group: Name of the config group to compose (`config_group=name`)\n            overrides: List of config groups to apply overrides to (`overrides=[\"override_name\"]`)\n            config_data: Keyword arguments to override config group values (will be converted to overrides of the form `config_group_name.key=value`)\n            global_package: If True, the config assumed to be a global package\n        \"\"\"\n        cfg = Composer.compose(\n            config_group=config_group,\n            overrides=overrides,\n            config_data=config_data,\n            global_package=global_package,\n        )\n        Composer.print(cfg)\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.Composer.generate_alias_for_special_keys","title":"<code>generate_alias_for_special_keys(key)</code>  <code>staticmethod</code>","text":"<p>Generate an alias for special keys. with -&gt; run pipe -&gt; pipe_target run -&gt; run</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The special key to generate an alias for.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The alias for the special key.</p> Source code in <code>hyfi/composer/composer.py</code> <pre><code>@staticmethod\ndef generate_alias_for_special_keys(key: str) -&gt; str:\n    \"\"\"\n    Generate an alias for special keys.\n    _with_ -&gt; run\n    _pipe_ -&gt; pipe_target\n    _run_ -&gt; run\n\n    Args:\n        key (str): The special key to generate an alias for.\n\n    Returns:\n        str: The alias for the special key.\n    \"\"\"\n    # replace the exact `with`, `pipe` with `run_with`, `run_pipe`\n    key_ = re.sub(r\"^with$\", \"run\", key)\n    # replace the prefix `_` with `run_`\n    key_ = re.sub(r\"^_with_$\", \"run\", key_)\n    key_ = re.sub(r\"^_pipe_$\", \"pipe_target\", key_)\n    key_ = re.sub(r\"^_run_$\", \"run\", key_)\n    return key_\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.Composer.getsource","title":"<code>getsource(obj)</code>  <code>staticmethod</code>","text":"<p>Return the source code of the object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to get the source code of.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The source code of the object as a string.</p> Source code in <code>hyfi/composer/composer.py</code> <pre><code>@staticmethod\ndef getsource(obj: Any) -&gt; str:\n    \"\"\"\n    Return the source code of the object.\n\n    Args:\n        obj: The object to get the source code of.\n\n    Returns:\n        The source code of the object as a string.\n\n    \"\"\"\n    try:\n        target_string = \"\"\n        if Composer.is_config(obj):\n            if SpecialKeys.TARGET in obj:\n                target_string = obj[SpecialKeys.TARGET]\n        elif isinstance(obj, str):\n            target_string = obj\n        return UTILs.getsource(target_string) if target_string else \"\"\n    except Exception as e:\n        logger.error(f\"Error getting source: {e}\")\n        return \"\"\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.Composer.instantiate","title":"<code>instantiate(config, *args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Instantiates an object using the provided config object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Any</code> <p>An config object describing what to call and what params to use.     In addition to the parameters, the config must contain:     target : target class or callable name (str)     And may contain:     args: List-like of positional arguments to pass to the target     recursive: Construct nested objects as well (bool).                     False by default.                     may be overridden via a recursive key in                     the kwargs     convert: Conversion strategy             none    : Passed objects are DictConfig and ListConfig, default             partial : Passed objects are converted to dict and list, with                     the exception of Structured Configs (and their fields).             all     : Passed objects are dicts, lists and primitives without                     a trace of OmegaConf containers     partial: If True, return functools.partial wrapped method or object                 False by default. Configure per target.     args: List-like of positional arguments</p> required <code>args</code> <code>Any</code> <p>Optional positional parameters pass-through</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>Optional named parameters to override     parameters in the config object. Parameters not present     in the config objects are being passed as is to the target.     IMPORTANT: dataclasses instances in kwargs are interpreted as config                 and cannot be used as passthrough</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>if target is a class name: the instantiated object</p> <code>Any</code> <p>if target is a callable: the return value of the call</p> Source code in <code>hyfi/composer/composer.py</code> <pre><code>@staticmethod\ndef instantiate(config: Any, *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Instantiates an object using the provided config object.\n\n    Args:\n        config: An config object describing what to call and what params to use.\n                In addition to the parameters, the config must contain:\n                _target_ : target class or callable name (str)\n                And may contain:\n                _args_: List-like of positional arguments to pass to the target\n                _recursive_: Construct nested objects as well (bool).\n                                False by default.\n                                may be overridden via a _recursive_ key in\n                                the kwargs\n                _convert_: Conversion strategy\n                        none    : Passed objects are DictConfig and ListConfig, default\n                        partial : Passed objects are converted to dict and list, with\n                                the exception of Structured Configs (and their fields).\n                        all     : Passed objects are dicts, lists and primitives without\n                                a trace of OmegaConf containers\n                _partial_: If True, return functools.partial wrapped method or object\n                            False by default. Configure per target.\n                _args_: List-like of positional arguments\n        args: Optional positional parameters pass-through\n        kwargs: Optional named parameters to override\n                parameters in the config object. Parameters not present\n                in the config objects are being passed as is to the target.\n                IMPORTANT: dataclasses instances in kwargs are interpreted as config\n                            and cannot be used as passthrough\n\n    Returns:\n        if _target_ is a class name: the instantiated object\n        if _target_ is a callable: the return value of the call\n    \"\"\"\n    verbose = config.get(\"verbose\", False)\n    if not Composer.is_instantiatable(config):\n        if verbose:\n            logger.info(\"Config is not instantiatable, returning config\")\n        return config\n    _recursive_ = config.get(SpecialKeys.RECURSIVE, False)\n    if SpecialKeys.RECURSIVE not in kwargs:\n        kwargs[SpecialKeys.RECURSIVE.value] = _recursive_\n    if verbose:\n        logger.info(\"instantiating %s ...\", config.get(SpecialKeys.TARGET))\n    return hydra.utils.instantiate(config, *args, **kwargs)\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.Composer.instantiate_config","title":"<code>instantiate_config(config_group=None, overrides=None, config_data=None, global_package=False, *args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Instantiates an object using the provided config group and overrides.</p> <p>Parameters:</p> Name Type Description Default <code>config_group</code> <code>Optional[str]</code> <p>Name of the config group to compose (<code>config_group=name</code>)</p> <code>None</code> <code>overrides</code> <code>Optional[List[str]]</code> <p>List of config groups to apply overrides to (<code>overrides=[\"override_name\"]</code>)</p> <code>None</code> <code>config_data</code> <code>Optional[Union[Dict[str, Any], DictConfig]]</code> <p>Keyword arguments to override config group values (will be converted to overrides of the form <code>config_group_name.key=value</code>)</p> <code>None</code> <code>global_package</code> <code>bool</code> <p>If True, the config assumed to be a global package</p> <code>False</code> <code>args</code> <code>Any</code> <p>Optional positional parameters pass-through</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>Optional named parameters to override     parameters in the config object. Parameters not present     in the config objects are being passed as is to the target.     IMPORTANT: dataclasses instances in kwargs are interpreted as config                 and cannot be used as passthrough</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>if target is a class name: the instantiated object</p> <code>Any</code> <p>if target is a callable: the return value of the call</p> Source code in <code>hyfi/composer/composer.py</code> <pre><code>@staticmethod\ndef instantiate_config(\n    config_group: Optional[str] = None,\n    overrides: Optional[List[str]] = None,\n    config_data: Optional[Union[Dict[str, Any], DictConfig]] = None,\n    global_package: bool = False,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"\n    Instantiates an object using the provided config group and overrides.\n\n    Args:\n        config_group: Name of the config group to compose (`config_group=name`)\n        overrides: List of config groups to apply overrides to (`overrides=[\"override_name\"]`)\n        config_data: Keyword arguments to override config group values (will be converted to overrides of the form `config_group_name.key=value`)\n        global_package: If True, the config assumed to be a global package\n        args: Optional positional parameters pass-through\n        kwargs: Optional named parameters to override\n                parameters in the config object. Parameters not present\n                in the config objects are being passed as is to the target.\n                IMPORTANT: dataclasses instances in kwargs are interpreted as config\n                            and cannot be used as passthrough\n\n    Returns:\n        if _target_ is a class name: the instantiated object\n        if _target_ is a callable: the return value of the call\n    \"\"\"\n    cfg = Composer.compose(\n        config_group=config_group,\n        overrides=overrides,\n        config_data=config_data,\n        global_package=global_package,\n    )\n    return Composer.instantiate(cfg, *args, **kwargs)\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.Composer.is_composable","title":"<code>is_composable(config_group, config_module=None)</code>  <code>staticmethod</code>","text":"<p>Determines whether the input configuration object is composable.</p> <p>Parameters:</p> Name Type Description Default <code>config_group</code> <code>str</code> <p>The name of the configuration group to check.</p> required <code>config_module</code> <code>Optional[str]</code> <p>The name of the configuration module to check. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the configuration object is composable, False otherwise.</p> Source code in <code>hyfi/composer/composer.py</code> <pre><code>@staticmethod\ndef is_composable(\n    config_group: str,\n    config_module: Optional[str] = None,\n) -&gt; bool:\n    \"\"\"\n    Determines whether the input configuration object is composable.\n\n    Args:\n        config_group (str): The name of the configuration group to check.\n        config_module (Optional[str], optional): The name of the configuration module to check. Defaults to None.\n\n    Returns:\n        bool: True if the configuration object is composable, False otherwise.\n    \"\"\"\n    try:\n        cfg = Composer.compose(\n            config_group=config_group,\n            config_module=config_module,\n        )\n        return cfg is not None\n    except Exception as e:\n        logger.error(\"Error composing config: %s\", e)\n        return False\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.Composer.is_instantiatable","title":"<code>is_instantiatable(cfg)</code>  <code>staticmethod</code>","text":"<p>Determines whether the input configuration object is instantiatable.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>Any</code> <p>The configuration object to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the configuration object is instantiatable, False otherwise.</p> Source code in <code>hyfi/composer/composer.py</code> <pre><code>@staticmethod\ndef is_instantiatable(cfg: Any):\n    \"\"\"\n    Determines whether the input configuration object is instantiatable.\n\n    Args:\n        cfg (Any): The configuration object to check.\n\n    Returns:\n        bool: True if the configuration object is instantiatable, False otherwise.\n    \"\"\"\n    return Composer.is_config(cfg) and SpecialKeys.TARGET in cfg\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.Composer.partial","title":"<code>partial(config, *args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Returns a callable object that is a partial version of the function or class specified in the config object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Union[str, Dict]</code> <p>An config object describing what to call and what params to use.     In addition to the parameters, the config must contain:     target : target class or callable name (str)     And may contain:     partial: If True, return functools.partial wrapped method or object                 False by default. Configure per target.</p> required <code>args</code> <code>Any</code> <p>Optional positional parameters pass-through</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>Optional named parameters to override     parameters in the config object. Parameters not present     in the config objects are being passed as is to the target.     IMPORTANT: dataclasses instances in kwargs are interpreted as config                 and cannot be used as passthrough</p> <code>{}</code> <p>Returns:     A callable object that is a partial version of the function or class specified in the config object.</p> Source code in <code>hyfi/composer/composer.py</code> <pre><code>@staticmethod\ndef partial(\n    config: Union[str, Dict],\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Callable:\n    \"\"\"\n    Returns a callable object that is a partial version of the function or class specified in the config object.\n\n    Args:\n        config: An config object describing what to call and what params to use.\n                In addition to the parameters, the config must contain:\n                _target_ : target class or callable name (str)\n                And may contain:\n                _partial_: If True, return functools.partial wrapped method or object\n                            False by default. Configure per target.\n        args: Optional positional parameters pass-through\n        kwargs: Optional named parameters to override\n                parameters in the config object. Parameters not present\n                in the config objects are being passed as is to the target.\n                IMPORTANT: dataclasses instances in kwargs are interpreted as config\n                            and cannot be used as passthrough\n    Returns:\n        A callable object that is a partial version of the function or class specified in the config object.\n    \"\"\"\n    if isinstance(config, str):\n        config = {SpecialKeys.TARGET.value: config}\n    else:\n        config = Composer.to_dict(config)\n    if not isinstance(config, dict):\n        raise ValueError(\"config must be a dict or a str\")\n    config[SpecialKeys.PARTIAL.value] = True\n    rc_kwargs_ = config.pop(SpecialKeys.KWARGS, {})\n    if rc_kwargs_ and kwargs:\n        kwargs.update(rc_kwargs_)\n    return Composer.instantiate(config, *args, **kwargs)\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.Composer.print_config","title":"<code>print_config(config_group=None, overrides=None, config_data=None, global_package=False)</code>  <code>staticmethod</code>","text":"<p>Print the configuration</p> <p>Parameters:</p> Name Type Description Default <code>config_group</code> <code>Optional[str]</code> <p>Name of the config group to compose (<code>config_group=name</code>)</p> <code>None</code> <code>overrides</code> <code>Optional[List[str]]</code> <p>List of config groups to apply overrides to (<code>overrides=[\"override_name\"]</code>)</p> <code>None</code> <code>config_data</code> <code>Optional[Union[Dict[str, Any], DictConfig]]</code> <p>Keyword arguments to override config group values (will be converted to overrides of the form <code>config_group_name.key=value</code>)</p> <code>None</code> <code>global_package</code> <code>bool</code> <p>If True, the config assumed to be a global package</p> <code>False</code> Source code in <code>hyfi/composer/composer.py</code> <pre><code>@staticmethod\ndef print_config(\n    config_group: Optional[str] = None,\n    overrides: Optional[List[str]] = None,\n    config_data: Optional[Union[Dict[str, Any], DictConfig]] = None,\n    global_package: bool = False,\n):\n    \"\"\"\n    Print the configuration\n\n    Args:\n        config_group: Name of the config group to compose (`config_group=name`)\n        overrides: List of config groups to apply overrides to (`overrides=[\"override_name\"]`)\n        config_data: Keyword arguments to override config group values (will be converted to overrides of the form `config_group_name.key=value`)\n        global_package: If True, the config assumed to be a global package\n    \"\"\"\n    cfg = Composer.compose(\n        config_group=config_group,\n        overrides=overrides,\n        config_data=config_data,\n        global_package=global_package,\n    )\n    Composer.print(cfg)\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.Composer.replace_special_keys","title":"<code>replace_special_keys(_dict)</code>  <code>staticmethod</code>","text":"<p>Replace special keys in a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>_dict</code> <code>Mapping[str, Any]</code> <p>The dictionary to update.</p> required <p>Returns:</p> Name Type Description <code>Mapping</code> <code>Mapping</code> <p>The updated dictionary.</p> Source code in <code>hyfi/composer/composer.py</code> <pre><code>@staticmethod\ndef replace_special_keys(_dict: Mapping[str, Any]) -&gt; Mapping:\n    \"\"\"\n    Replace special keys in a dictionary.\n\n    Args:\n        _dict (Mapping[str, Any]): The dictionary to update.\n\n    Returns:\n        Mapping: The updated dictionary.\n    \"\"\"\n    _new_dict = {}\n    for k, v in _dict.items():\n        key = Composer.generate_alias_for_special_keys(k)\n        if isinstance(v, collections.abc.Mapping):\n            _new_dict[key] = Composer.replace_special_keys(v)\n        else:\n            _new_dict[key] = v\n    return _new_dict\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.Composer.viewsource","title":"<code>viewsource(obj)</code>  <code>staticmethod</code>","text":"<p>Print the source code of the object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to print the source code of.</p> required Source code in <code>hyfi/composer/composer.py</code> <pre><code>@staticmethod\ndef viewsource(obj: Any):\n    \"\"\"\n    Print the source code of the object.\n\n    Args:\n        obj: The object to print the source code of.\n\n    \"\"\"\n    print(Composer.getsource(obj))\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.DocGenerator","title":"<code>DocGenerator</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A class for generating reference documentation and configuration documentation.</p> <p>This class provides methods for generating reference documentation for modules and configuration documentation for directories.</p> <p>Attributes:</p> Name Type Description <code>_config_name_</code> <code>str</code> <p>The name of the configuration.</p> <code>_config_group_</code> <code>str</code> <p>The group of the configuration.</p> <code>config_docs_dirname</code> <code>str</code> <p>The name of the directory for configuration documentation.</p> <code>reference_docs_dirname</code> <code>str</code> <p>The name of the directory for reference documentation.</p> <code>exclude_configs</code> <code>List[str]</code> <p>A list of configurations to exclude.</p> <code>exclude_references</code> <code>List[str]</code> <p>A list of references to exclude.</p> Properties <p>root_dir: The root directory. package_dir: The package directory. package_name: The package name. config_dir: The configuration directory. config_docs_dir: The directory for configuration documentation. reference_docs_dir: The directory for reference documentation.</p> <p>Methods:</p> Name Description <code>generate_reference_docs</code> <p>Generates reference documentation for modules.</p> <code>write_ref_doc</code> <p>Writes reference documentation for a module.</p> <code>generate_config_docs</code> <p>Generates configuration documentation for directories.</p> <code>write_config_doc</code> <p>Writes configuration documentation for a directory.</p> Example <pre><code>doc_generator = DocGenerator()\ndoc_generator.generate_reference_docs()\ndoc_generator.generate_config_docs()\n</code></pre> Source code in <code>hyfi/composer/docs.py</code> <pre><code>class DocGenerator(BaseModel):\n    \"\"\"\n    A class for generating reference documentation and configuration documentation.\n\n    This class provides methods for generating reference documentation for modules and configuration documentation for directories.\n\n    Attributes:\n        _config_name_: The name of the configuration.\n        _config_group_: The group of the configuration.\n        config_docs_dirname: The name of the directory for configuration documentation.\n        reference_docs_dirname: The name of the directory for reference documentation.\n        exclude_configs: A list of configurations to exclude.\n        exclude_references: A list of references to exclude.\n\n    Properties:\n        root_dir: The root directory.\n        package_dir: The package directory.\n        package_name: The package name.\n        config_dir: The configuration directory.\n        config_docs_dir: The directory for configuration documentation.\n        reference_docs_dir: The directory for reference documentation.\n\n    Methods:\n        generate_reference_docs: Generates reference documentation for modules.\n        write_ref_doc: Writes reference documentation for a module.\n        generate_config_docs: Generates configuration documentation for directories.\n        write_config_doc: Writes configuration documentation for a directory.\n\n    Example:\n        ```python\n        doc_generator = DocGenerator()\n        doc_generator.generate_reference_docs()\n        doc_generator.generate_config_docs()\n        ```\n    \"\"\"\n\n    _config_name_: str = \"__init__\"\n    _config_group_: str = \"/docs\"\n\n    config_docs_dirname: str = \"docs/configs\"\n    reference_docs_dirname: str = \"docs/reference\"\n\n    exclude_configs: List[str] = [\n        \"docs\",\n        \"hydra\",\n    ]\n    exclude_references: List[str] = [\n        \"conf\",\n        \"__cli__.py\",\n        \"__click__.py\",\n        \"__init__.py\",\n        \"_version.py\",\n        \"__pycache__\",\n    ]\n\n    def __call__(self) -&gt; None:\n        self.generate_config_docs()\n        self.generate_reference_docs()\n\n    @property\n    def root_dir(self) -&gt; Path:\n        return Path(ENVs.getcwd())\n\n    @property\n    def package_dir(self) -&gt; Path:\n        return Path(global_hyfi.package_path)\n\n    @property\n    def package_name(self) -&gt; str:\n        return global_hyfi.package_name\n\n    @property\n    def config_dir(self) -&gt; Path:\n        return self.package_dir / global_hyfi.config_dirname\n\n    @property\n    def config_docs_dir(self) -&gt; Path:\n        path_ = self.root_dir / self.config_docs_dirname\n        path_.mkdir(parents=True, exist_ok=True)\n        return path_\n\n    @property\n    def reference_docs_dir(self) -&gt; Path:\n        path_ = self.root_dir / self.reference_docs_dirname\n        path_.mkdir(parents=True, exist_ok=True)\n        return path_\n\n    def generate_reference_docs(self):\n        exclude_refs = self.exclude_references or []\n        logger.info(\"Generating reference documentation excluding %s\", exclude_refs)\n        for _path in self.package_dir.iterdir():\n            module_name = _path.name\n            if _path.is_file() or module_name in exclude_refs:\n                continue\n            self.write_ref_doc(_path)\n            # for file in _path.iterdir():\n            #     if file.name in exclude_refs:\n            #         continue\n            #     self.write_ref_doc(file)\n\n    def write_ref_doc(self, module_path: Path):\n        module_name = module_path.relative_to(self.package_dir)\n        if module_path.is_dir():\n            ref_file = self.reference_docs_dir / str(module_name) / \"index.md\"\n        else:\n            module_name = module_name.with_suffix(\"\")\n            ref_file = self.reference_docs_dir / f\"{module_name}.md\"\n        module_name = module_name.as_posix().replace(\"/\", \".\")\n        module_name = f\"{self.package_name}.{module_name}\"\n        ref_file.parent.mkdir(parents=True, exist_ok=True)\n        logger.info(\n            \"Writing reference documentation for %s to %s\", module_name, ref_file\n        )\n        with open(ref_file, \"w\") as f:\n            f.write(f\"# `{module_name}`\\n\\n\")\n            f.write(f\"::: {module_name}\\n\")\n\n    def generate_config_docs(self):\n        exclude_configs = self.exclude_configs or []\n        logger.info(\n            \"Generating configuration documentation excluding %s\", exclude_configs\n        )\n        for config_path in sorted(self.config_dir.iterdir()):\n            if (\n                config_path.is_file()\n                or config_path.name in exclude_configs\n                or config_path.name.startswith(\"__\")\n            ):\n                continue\n            self.write_config_doc(config_path)\n\n    def write_config_doc(self, config_path: Path):\n        dirname = config_path.name\n        output_file = self.config_docs_dir / f\"{dirname}.md\"\n        logger.info(\n            \"Writing configuration documentation for %s to %s\", dirname, output_file\n        )\n        with open(output_file, \"w\") as f:\n            f.write(f\"# {dirname}\\n\\n\")\n            f.write(f\"Config location: `conf/{dirname}`\\n\\n\")\n            for file in sorted(config_path.iterdir()):\n                if file.is_dir():\n                    continue\n                if file.suffix == \".yaml\":\n                    f.write(f\"## `{file.name}`\\n\\n\")\n                    f.write(\"```yaml\\n\")\n                    lvl = self.config_docs_dir.relative_to(self.root_dir)\n                    lvl = \"/\".join([\"..\"] * len(lvl.as_posix().split(\"/\")))\n                    rel_path = f\"{lvl}/{file.relative_to(self.root_dir)}\"\n                    f.write(\"{% include '\" + str(rel_path) + \"' %}\")\n                    f.write(\"\\n```\\n\\n\")\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.GENERATOR","title":"<code>GENERATOR</code>","text":"<p>Generates Hydra configs for functions and classes.</p> Source code in <code>hyfi/composer/generator.py</code> <pre><code>class GENERATOR:\n    \"\"\"\n    Generates Hydra configs for functions and classes.\n    \"\"\"\n\n    @staticmethod\n    def generate_pipe_config(\n        target: Callable,\n        pipe_target_type: PipeTargetTypes = PipeTargetTypes.GENERAL_EXTERNAL_FUNCS,\n        use_pipe_obj: bool = True,\n        pipe_obj_arg_name: Optional[str] = None,\n        return_pipe_obj: bool = False,\n        pipe_prefix: Optional[str] = None,\n        config_name: Optional[str] = None,\n        config_root: Optional[str] = None,\n        **kwargs_for_target,\n    ) -&gt; str:\n        \"\"\"\n        Generates HyFI pipe config for a given target.\n\n        Args:\n            target: Target function or class.\n            pipe_target_type: Type of target function or class.\n            use_pipe_obj: Whether to use pipe object as the first argument.\n            pipe_obj_arg_name: Name of the pipe object argument.\n            return_pipe_obj: Whether to return pipe object.\n            pipe_prefix: Prefix for pipe object argument.\n            config_name: Name of the config.\n            config_root: Root of the config.\n            **kwargs_for_target: Keyword arguments for the target.\n        \"\"\"\n        use_first_arg_as_pipe_obj = not pipe_obj_arg_name and use_pipe_obj\n        config_name = config_name or target.__name__\n        config_name = f\"{pipe_prefix}_{config_name}\" if pipe_prefix else config_name\n        config_root = config_root or global_hyfi.config_root\n\n        run_config_name = GENERATOR.generate_callable_config(\n            target,\n            config_name=config_name,\n            config_path=\"run\",\n            config_root=config_root,\n            use_first_arg_as_pipe_obj=use_first_arg_as_pipe_obj,\n            **kwargs_for_target,\n        )\n\n        cfg = {\n            \"defaults\": [\n                pipe_target_type.value,\n                {\"/run\": run_config_name},\n            ],\n            \"use_pipe_obj\": use_pipe_obj,\n            \"pipe_obj_arg_name\": pipe_obj_arg_name,\n            \"return_pipe_obj\": return_pipe_obj,\n        }\n\n        filename = f\"{config_name}.yaml\"\n        config_path = Path(config_root) / \"pipe\"\n        config_path.mkdir(parents=True, exist_ok=True)\n        config_path /= filename\n        CONFs.save(cfg, config_path)\n        logger.info(f\"Saved HyFI pipe config for {target.__name__} to {config_path}\")\n\n        return config_name\n\n    @staticmethod\n    def generate_callable_config(\n        target: Callable,\n        config_name: Optional[str] = None,\n        config_path: str = \"run\",\n        config_root: Optional[str] = None,\n        use_first_arg_as_pipe_obj: bool = False,\n        **kwargs_for_target,\n    ) -&gt; str:\n        \"\"\"\n        Saves a HyFI config to a file.\n\n        Args:\n            target (Callable): The function or class to generate a config for.\n            use_first_arg_as_pipe_obj (bool): Whether to use the first argument as the pipe object.\n            config_name (Optional[str]): The name of the config. If not provided, the name of the target will be used.\n            config_path (Optional[str]): The path to save the config to (relative to the config root). Defaults to \"run\".\n            config_root (Optional[str]): The root of the config path. If not provided, the global hyfi config directory will be used.\n            **kwargs_for_target: Keyword arguments to pass to the target.\n        \"\"\"\n        cfg = GENERATOR.generate_target_config(\n            target,\n            remove_first_arg=use_first_arg_as_pipe_obj,\n            **kwargs_for_target,\n        )\n        config_name = config_name or target.__name__\n        filename = f\"{config_name}.yaml\"\n        config_root = config_root or global_hyfi.config_root\n        config_path = Path(config_root) / config_path\n        config_path.mkdir(parents=True, exist_ok=True)\n        config_path /= filename\n        CONFs.save(cfg, config_path)\n        logger.info(f\"Saved HyFI config for {target.__name__} to {config_path}\")\n        return config_name\n\n    @staticmethod\n    def generate_target_config(\n        target: Callable,\n        remove_first_arg: bool = False,\n        **kwargs,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Generates a HyFI config for a given target.\n\n        Args:\n            target (Callable): The function or class to generate a config for.\n            remove_first_arg (bool): Whether to remove the first argument from the config.\n            **kwargs: Keyword arguments to pass to the target.\n        \"\"\"\n        params = inspect.signature(target).parameters\n\n        config_dict = {\n            \"_target_\": f\"{target.__module__}.{target.__qualname__}\",\n        }\n\n        for i, (key, param) in enumerate(params.items()):\n            if remove_first_arg and i == 0:\n                continue\n            if param.kind == inspect.Parameter.VAR_KEYWORD:\n                continue\n            if key in kwargs:\n                value = kwargs[key]\n            else:\n                value = (\n                    None if param.default == inspect.Parameter.empty else param.default\n                )\n            config_dict[key] = sanitized_default_value(value)\n        return config_dict\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.GENERATOR.generate_callable_config","title":"<code>generate_callable_config(target, config_name=None, config_path='run', config_root=None, use_first_arg_as_pipe_obj=False, **kwargs_for_target)</code>  <code>staticmethod</code>","text":"<p>Saves a HyFI config to a file.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Callable</code> <p>The function or class to generate a config for.</p> required <code>use_first_arg_as_pipe_obj</code> <code>bool</code> <p>Whether to use the first argument as the pipe object.</p> <code>False</code> <code>config_name</code> <code>Optional[str]</code> <p>The name of the config. If not provided, the name of the target will be used.</p> <code>None</code> <code>config_path</code> <code>Optional[str]</code> <p>The path to save the config to (relative to the config root). Defaults to \"run\".</p> <code>'run'</code> <code>config_root</code> <code>Optional[str]</code> <p>The root of the config path. If not provided, the global hyfi config directory will be used.</p> <code>None</code> <code>**kwargs_for_target</code> <p>Keyword arguments to pass to the target.</p> <code>{}</code> Source code in <code>hyfi/composer/generator.py</code> <pre><code>@staticmethod\ndef generate_callable_config(\n    target: Callable,\n    config_name: Optional[str] = None,\n    config_path: str = \"run\",\n    config_root: Optional[str] = None,\n    use_first_arg_as_pipe_obj: bool = False,\n    **kwargs_for_target,\n) -&gt; str:\n    \"\"\"\n    Saves a HyFI config to a file.\n\n    Args:\n        target (Callable): The function or class to generate a config for.\n        use_first_arg_as_pipe_obj (bool): Whether to use the first argument as the pipe object.\n        config_name (Optional[str]): The name of the config. If not provided, the name of the target will be used.\n        config_path (Optional[str]): The path to save the config to (relative to the config root). Defaults to \"run\".\n        config_root (Optional[str]): The root of the config path. If not provided, the global hyfi config directory will be used.\n        **kwargs_for_target: Keyword arguments to pass to the target.\n    \"\"\"\n    cfg = GENERATOR.generate_target_config(\n        target,\n        remove_first_arg=use_first_arg_as_pipe_obj,\n        **kwargs_for_target,\n    )\n    config_name = config_name or target.__name__\n    filename = f\"{config_name}.yaml\"\n    config_root = config_root or global_hyfi.config_root\n    config_path = Path(config_root) / config_path\n    config_path.mkdir(parents=True, exist_ok=True)\n    config_path /= filename\n    CONFs.save(cfg, config_path)\n    logger.info(f\"Saved HyFI config for {target.__name__} to {config_path}\")\n    return config_name\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.GENERATOR.generate_pipe_config","title":"<code>generate_pipe_config(target, pipe_target_type=PipeTargetTypes.GENERAL_EXTERNAL_FUNCS, use_pipe_obj=True, pipe_obj_arg_name=None, return_pipe_obj=False, pipe_prefix=None, config_name=None, config_root=None, **kwargs_for_target)</code>  <code>staticmethod</code>","text":"<p>Generates HyFI pipe config for a given target.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Callable</code> <p>Target function or class.</p> required <code>pipe_target_type</code> <code>PipeTargetTypes</code> <p>Type of target function or class.</p> <code>GENERAL_EXTERNAL_FUNCS</code> <code>use_pipe_obj</code> <code>bool</code> <p>Whether to use pipe object as the first argument.</p> <code>True</code> <code>pipe_obj_arg_name</code> <code>Optional[str]</code> <p>Name of the pipe object argument.</p> <code>None</code> <code>return_pipe_obj</code> <code>bool</code> <p>Whether to return pipe object.</p> <code>False</code> <code>pipe_prefix</code> <code>Optional[str]</code> <p>Prefix for pipe object argument.</p> <code>None</code> <code>config_name</code> <code>Optional[str]</code> <p>Name of the config.</p> <code>None</code> <code>config_root</code> <code>Optional[str]</code> <p>Root of the config.</p> <code>None</code> <code>**kwargs_for_target</code> <p>Keyword arguments for the target.</p> <code>{}</code> Source code in <code>hyfi/composer/generator.py</code> <pre><code>@staticmethod\ndef generate_pipe_config(\n    target: Callable,\n    pipe_target_type: PipeTargetTypes = PipeTargetTypes.GENERAL_EXTERNAL_FUNCS,\n    use_pipe_obj: bool = True,\n    pipe_obj_arg_name: Optional[str] = None,\n    return_pipe_obj: bool = False,\n    pipe_prefix: Optional[str] = None,\n    config_name: Optional[str] = None,\n    config_root: Optional[str] = None,\n    **kwargs_for_target,\n) -&gt; str:\n    \"\"\"\n    Generates HyFI pipe config for a given target.\n\n    Args:\n        target: Target function or class.\n        pipe_target_type: Type of target function or class.\n        use_pipe_obj: Whether to use pipe object as the first argument.\n        pipe_obj_arg_name: Name of the pipe object argument.\n        return_pipe_obj: Whether to return pipe object.\n        pipe_prefix: Prefix for pipe object argument.\n        config_name: Name of the config.\n        config_root: Root of the config.\n        **kwargs_for_target: Keyword arguments for the target.\n    \"\"\"\n    use_first_arg_as_pipe_obj = not pipe_obj_arg_name and use_pipe_obj\n    config_name = config_name or target.__name__\n    config_name = f\"{pipe_prefix}_{config_name}\" if pipe_prefix else config_name\n    config_root = config_root or global_hyfi.config_root\n\n    run_config_name = GENERATOR.generate_callable_config(\n        target,\n        config_name=config_name,\n        config_path=\"run\",\n        config_root=config_root,\n        use_first_arg_as_pipe_obj=use_first_arg_as_pipe_obj,\n        **kwargs_for_target,\n    )\n\n    cfg = {\n        \"defaults\": [\n            pipe_target_type.value,\n            {\"/run\": run_config_name},\n        ],\n        \"use_pipe_obj\": use_pipe_obj,\n        \"pipe_obj_arg_name\": pipe_obj_arg_name,\n        \"return_pipe_obj\": return_pipe_obj,\n    }\n\n    filename = f\"{config_name}.yaml\"\n    config_path = Path(config_root) / \"pipe\"\n    config_path.mkdir(parents=True, exist_ok=True)\n    config_path /= filename\n    CONFs.save(cfg, config_path)\n    logger.info(f\"Saved HyFI pipe config for {target.__name__} to {config_path}\")\n\n    return config_name\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.GENERATOR.generate_target_config","title":"<code>generate_target_config(target, remove_first_arg=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Generates a HyFI config for a given target.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Callable</code> <p>The function or class to generate a config for.</p> required <code>remove_first_arg</code> <code>bool</code> <p>Whether to remove the first argument from the config.</p> <code>False</code> <code>**kwargs</code> <p>Keyword arguments to pass to the target.</p> <code>{}</code> Source code in <code>hyfi/composer/generator.py</code> <pre><code>@staticmethod\ndef generate_target_config(\n    target: Callable,\n    remove_first_arg: bool = False,\n    **kwargs,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Generates a HyFI config for a given target.\n\n    Args:\n        target (Callable): The function or class to generate a config for.\n        remove_first_arg (bool): Whether to remove the first argument from the config.\n        **kwargs: Keyword arguments to pass to the target.\n    \"\"\"\n    params = inspect.signature(target).parameters\n\n    config_dict = {\n        \"_target_\": f\"{target.__module__}.{target.__qualname__}\",\n    }\n\n    for i, (key, param) in enumerate(params.items()):\n        if remove_first_arg and i == 0:\n            continue\n        if param.kind == inspect.Parameter.VAR_KEYWORD:\n            continue\n        if key in kwargs:\n            value = kwargs[key]\n        else:\n            value = (\n                None if param.default == inspect.Parameter.empty else param.default\n            )\n        config_dict[key] = sanitized_default_value(value)\n    return config_dict\n</code></pre>"},{"location":"reference/composer/#hyfi.composer.SpecialKeys","title":"<code>SpecialKeys</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Special keys in configs used by HyFI.</p> Source code in <code>hyfi/composer/composer.py</code> <pre><code>class SpecialKeys(str, Enum):\n    \"\"\"Special keys in configs used by HyFI.\"\"\"\n\n    CALL = \"_call_\"\n    CONFIG = \"_config_\"\n    CONFIG_GROUP = \"_config_group_\"\n    CONFIG_NAME = \"_config_name_\"\n    DESCRIPTION = \"_description_\"\n    EXEC = \"_exec_\"\n    FUNC = \"_func_\"\n    KWARGS = \"_kwargs_\"\n    METHOD = \"_method_\"\n    PARTIAL = \"_partial_\"\n    PIPE_TARGET = \"pipe_target\"\n    RECURSIVE = \"_recursive_\"\n    RUN = \"run\"\n    RUN_WITH = \"run_with\"\n    TARGET = \"_target_\"\n    TYPE = \"_type_\"\n    USES = \"uses\"\n    WITH = \"with\"\n</code></pre>"},{"location":"reference/copier/","title":"<code>hyfi.copier</code>","text":""},{"location":"reference/copier/#hyfi.copier.Copier","title":"<code>Copier</code>","text":"<p>Copier process state manager.</p> <p>This class represents the state of a copier work and contains methods to actually produce the desired work.</p> <p>To use it properly, use it as a context manager and fill all dataclass fields.</p> <p>Then, execute <code>run_copy</code> to copy the template to the destination.</p> <p>Attributes:</p> Name Type Description <code>src_path</code> <code>Path</code> <p>Source path where to find the template.</p> <code>dst_path</code> <code>Path</code> <p>Destination path where to render the template.</p> <code>filetypes</code> <code>Optional[Union[List[str], str]]</code> <p>Filetypes to copy.</p> <code>exclude</code> <code>Optional[Union[List[str], str]]</code> <p>User-chosen additional file exclusion patterns.</p> <code>exclude_test_files</code> <code>bool</code> <p>If <code>True</code>, exclude files that match the patterns for testing. (default: True)</p> <code>skip_if_exists</code> <code>bool</code> <p>If <code>True</code>, skip files that already exist in the destination. (default: False)</p> <code>cleanup_on_error</code> <code>bool</code> <p>Delete <code>dst_path</code> if there's an error?</p> <code>overwrite</code> <code>bool</code> <p>When <code>True</code>, Overwrite files that already exist, without asking.</p> <code>dryrun</code> <code>bool</code> <p>When <code>True</code>, produce no real rendering.</p> <code>verbose</code> <code>bool</code> <p>When <code>True</code>, show all output.</p> Source code in <code>hyfi/copier/copier.py</code> <pre><code>@dataclass()\nclass Copier:\n    \"\"\"Copier process state manager.\n\n    This class represents the state of a copier work and contains methods to\n    actually produce the desired work.\n\n    To use it properly, use it as a context manager and fill all dataclass fields.\n\n    Then, execute `run_copy` to copy the template to the destination.\n\n    Attributes:\n        src_path:\n            Source path where to find the template.\n\n        dst_path:\n            Destination path where to render the template.\n\n        filetypes:\n            Filetypes to copy.\n\n        exclude:\n            User-chosen additional file exclusion patterns.\n\n        exclude_test_files:\n            If `True`, exclude files that match the patterns for testing. (default: True)\n\n        skip_if_exists:\n            If `True`, skip files that already exist in the destination. (default: False)\n\n        cleanup_on_error:\n            Delete `dst_path` if there's an error?\n\n        overwrite:\n            When `True`, Overwrite files that already exist, without asking.\n\n        dryrun:\n            When `True`, produce no real rendering.\n\n        verbose:\n            When `True`, show all output.\n    \"\"\"\n\n    src_path: Path = field(default=Path(\"conf\"))\n    dst_path: Path = field(default=Path(\".\"))\n    filetypes: Optional[Union[List[str], str]] = field(default=None)\n    exclude: Optional[Union[List[str], str]] = field(default=None)\n    exclude_test_files: bool = True\n    skip_if_exists: bool = False\n    cleanup_on_error: bool = True\n    overwrite: bool = False\n    dryrun: bool = False\n    verbose: bool = True\n\n    def __post_init__(self):\n        \"\"\"Initialize the path_spec attribute based on the exclude patterns.\"\"\"\n        # Validate and convert src_path and dst_path\n        for attr_name in [\"src_path\", \"dst_path\"]:\n            attr_value = getattr(self, attr_name)\n            if not isinstance(attr_value, Path):\n                setattr(self, attr_name, Path(attr_value))\n\n        # Validate and convert exclude and filetypes\n        for attr_name in [\"exclude\", \"filetypes\"]:\n            attr_value = getattr(self, attr_name)\n            if attr_value is None:\n                setattr(self, attr_name, [])\n            elif not isinstance(attr_value, list):\n                setattr(self, attr_name, [attr_value])\n\n        if self.filetypes is None or len(self.filetypes) == 0:\n            self.filetypes = [\"yaml\", \"yml\", \"py\"]\n\n        exclude = (\n            []\n            if self.exclude is None or len(self.exclude) == 0\n            else [self.exclude] if isinstance(self.exclude, str) else self.exclude\n        )\n\n        test_files = [\"_test_*\", \"__test_*\"]\n        if self.exclude_test_files:\n            exclude += test_files\n        if not self.dst_path.is_absolute():\n            self.dst_path = ENVs.getcwd() / self.dst_path\n        self.path_spec = PathSpec.from_lines(\"gitwildmatch\", exclude)\n        self.dst_path_existed = self.dst_path.exists()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"Exit the context manager, handling cleanup if needed.\"\"\"\n        if exc_type is not None and not self.dst_path_existed and self.cleanup_on_error:\n            rmtree(self.dst_path)\n            FUNCs.printf(\n                \"CLEANUP\",\n                f\"Removed {self.dst_path}\",\n                Style.DANGER,\n                verbose=self.verbose,\n            )\n\n    def run_copy(self):\n        \"\"\"Execute the copy process.\n\n        Walk through the source directory, compare YAML files with the destination\n        directory, and copy files based on the specified settings.\n        \"\"\"\n        if not Path(self.src_path).is_dir():\n            FUNCs.printf(\n                \"ERROR\",\n                f\"Source path {self.src_path} does not exist.\",\n                style=Style.DANGER,\n            )\n            return\n        for root, _, files in os.walk(self.src_path):\n            for filename in files:\n                if not any(filename.endswith(filetype) for filetype in self.filetypes):\n                    continue\n\n                src_file = Path(root, filename)\n                dst_file = self.dst_path / src_file.relative_to(self.src_path)\n                dst_file = dst_file.absolute()\n\n                if self.path_spec.match_file(src_file):\n                    FUNCs.printf(\n                        \"EXCLUDED\", f\"{src_file}\", Style.WARNING, verbose=self.verbose\n                    )\n                    continue\n\n                if dst_file.exists():\n                    if self.skip_if_exists:\n                        FUNCs.printf(\n                            \"SKIPPED\",\n                            f\"{src_file}\",\n                            Style.WARNING,\n                            verbose=self.verbose,\n                        )\n                        continue\n\n                    if filecmp.cmp(src_file, dst_file, shallow=False):\n                        FUNCs.printf(\n                            \"UNCHANGED\",\n                            f\"{src_file}\",\n                            Style.IGNORE,\n                            verbose=self.verbose,\n                        )\n                        continue\n\n                    answer = \"Y\"\n                    if not self.overwrite:\n                        answer = input(f\"Overwrite {dst_file}? [Y/n]: \") or \"Y\"\n                    if answer.lower() != \"y\":\n                        FUNCs.printf(\n                            \"IGNORED\",\n                            f\"{src_file}\",\n                            Style.WARNING,\n                            verbose=self.verbose,\n                        )\n                        continue\n\n                if not self.dryrun:\n                    dst_file.parent.mkdir(parents=True, exist_ok=True)\n                    copy2(src_file, dst_file)\n                FUNCs.printf(\n                    \"COPIED\",\n                    f\"{src_file} -&gt; {dst_file}\",\n                    Style.OK,\n                    verbose=self.verbose,\n                )\n</code></pre>"},{"location":"reference/copier/#hyfi.copier.Copier.__exit__","title":"<code>__exit__(exc_type, exc_value, traceback)</code>","text":"<p>Exit the context manager, handling cleanup if needed.</p> Source code in <code>hyfi/copier/copier.py</code> <pre><code>def __exit__(self, exc_type, exc_value, traceback):\n    \"\"\"Exit the context manager, handling cleanup if needed.\"\"\"\n    if exc_type is not None and not self.dst_path_existed and self.cleanup_on_error:\n        rmtree(self.dst_path)\n        FUNCs.printf(\n            \"CLEANUP\",\n            f\"Removed {self.dst_path}\",\n            Style.DANGER,\n            verbose=self.verbose,\n        )\n</code></pre>"},{"location":"reference/copier/#hyfi.copier.Copier.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize the path_spec attribute based on the exclude patterns.</p> Source code in <code>hyfi/copier/copier.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Initialize the path_spec attribute based on the exclude patterns.\"\"\"\n    # Validate and convert src_path and dst_path\n    for attr_name in [\"src_path\", \"dst_path\"]:\n        attr_value = getattr(self, attr_name)\n        if not isinstance(attr_value, Path):\n            setattr(self, attr_name, Path(attr_value))\n\n    # Validate and convert exclude and filetypes\n    for attr_name in [\"exclude\", \"filetypes\"]:\n        attr_value = getattr(self, attr_name)\n        if attr_value is None:\n            setattr(self, attr_name, [])\n        elif not isinstance(attr_value, list):\n            setattr(self, attr_name, [attr_value])\n\n    if self.filetypes is None or len(self.filetypes) == 0:\n        self.filetypes = [\"yaml\", \"yml\", \"py\"]\n\n    exclude = (\n        []\n        if self.exclude is None or len(self.exclude) == 0\n        else [self.exclude] if isinstance(self.exclude, str) else self.exclude\n    )\n\n    test_files = [\"_test_*\", \"__test_*\"]\n    if self.exclude_test_files:\n        exclude += test_files\n    if not self.dst_path.is_absolute():\n        self.dst_path = ENVs.getcwd() / self.dst_path\n    self.path_spec = PathSpec.from_lines(\"gitwildmatch\", exclude)\n    self.dst_path_existed = self.dst_path.exists()\n</code></pre>"},{"location":"reference/copier/#hyfi.copier.Copier.run_copy","title":"<code>run_copy()</code>","text":"<p>Execute the copy process.</p> <p>Walk through the source directory, compare YAML files with the destination directory, and copy files based on the specified settings.</p> Source code in <code>hyfi/copier/copier.py</code> <pre><code>def run_copy(self):\n    \"\"\"Execute the copy process.\n\n    Walk through the source directory, compare YAML files with the destination\n    directory, and copy files based on the specified settings.\n    \"\"\"\n    if not Path(self.src_path).is_dir():\n        FUNCs.printf(\n            \"ERROR\",\n            f\"Source path {self.src_path} does not exist.\",\n            style=Style.DANGER,\n        )\n        return\n    for root, _, files in os.walk(self.src_path):\n        for filename in files:\n            if not any(filename.endswith(filetype) for filetype in self.filetypes):\n                continue\n\n            src_file = Path(root, filename)\n            dst_file = self.dst_path / src_file.relative_to(self.src_path)\n            dst_file = dst_file.absolute()\n\n            if self.path_spec.match_file(src_file):\n                FUNCs.printf(\n                    \"EXCLUDED\", f\"{src_file}\", Style.WARNING, verbose=self.verbose\n                )\n                continue\n\n            if dst_file.exists():\n                if self.skip_if_exists:\n                    FUNCs.printf(\n                        \"SKIPPED\",\n                        f\"{src_file}\",\n                        Style.WARNING,\n                        verbose=self.verbose,\n                    )\n                    continue\n\n                if filecmp.cmp(src_file, dst_file, shallow=False):\n                    FUNCs.printf(\n                        \"UNCHANGED\",\n                        f\"{src_file}\",\n                        Style.IGNORE,\n                        verbose=self.verbose,\n                    )\n                    continue\n\n                answer = \"Y\"\n                if not self.overwrite:\n                    answer = input(f\"Overwrite {dst_file}? [Y/n]: \") or \"Y\"\n                if answer.lower() != \"y\":\n                    FUNCs.printf(\n                        \"IGNORED\",\n                        f\"{src_file}\",\n                        Style.WARNING,\n                        verbose=self.verbose,\n                    )\n                    continue\n\n            if not self.dryrun:\n                dst_file.parent.mkdir(parents=True, exist_ok=True)\n                copy2(src_file, dst_file)\n            FUNCs.printf(\n                \"COPIED\",\n                f\"{src_file} -&gt; {dst_file}\",\n                Style.OK,\n                verbose=self.verbose,\n            )\n</code></pre>"},{"location":"reference/core/","title":"<code>hyfi.core</code>","text":""},{"location":"reference/core/#hyfi.core.GlobalHyFIResolver","title":"<code>GlobalHyFIResolver</code>","text":"Source code in <code>hyfi/core/core.py</code> <pre><code>class GlobalHyFIResolver:\n    @staticmethod\n    def __hyfi_version__() -&gt; str:\n        \"\"\"\n        Returns the version of HyFI.\n\n        Returns:\n            string containing the version of HyFI\n        \"\"\"\n        from hyfi._version import __version__\n\n        return __version__\n\n    def __hyfi_path__() -&gt; str:\n        \"\"\"Returns the path to the HyFI root folder\"\"\"\n        return __global_hyfi__.hyfi_package_path\n\n    @staticmethod\n    def __home_path__() -&gt; str:\n        \"\"\"Returns the path to the user's home folder\"\"\"\n        return Path.home().as_posix()\n\n    @staticmethod\n    def __app_version__() -&gt; str:\n        \"\"\"\n        Returns the version of App.\n\n        Returns:\n            string containing the version of App\n        \"\"\"\n\n        return __global_hyfi__.version\n\n    @staticmethod\n    def __package_name__() -&gt; str:\n        \"\"\"\n        Returns the package name of the App\n\n        Returns:\n            string containing the package name of the App\n        \"\"\"\n\n        return __global_hyfi__.package_name\n\n    @staticmethod\n    def __package_path__() -&gt; str:\n        \"\"\"\n        Returns the path to the App root folder\n\n        Returns:\n            string containing the path to the App root folder\n        \"\"\"\n\n        return __global_hyfi__.package_path\n\n    @staticmethod\n    def __config_module_path__() -&gt; str:\n        \"\"\"Global HyFI config path for the package to search for.\"\"\"\n        return __global_hyfi__.config_module_path\n\n    @staticmethod\n    def __user_config_path__() -&gt; str:\n        \"\"\"Global HyFI user config path for the package to search for.\"\"\"\n        return __global_hyfi__.user_config_path\n</code></pre>"},{"location":"reference/core/#hyfi.core.GlobalHyFIResolver.__app_version__","title":"<code>__app_version__()</code>  <code>staticmethod</code>","text":"<p>Returns the version of App.</p> <p>Returns:</p> Type Description <code>str</code> <p>string containing the version of App</p> Source code in <code>hyfi/core/core.py</code> <pre><code>@staticmethod\ndef __app_version__() -&gt; str:\n    \"\"\"\n    Returns the version of App.\n\n    Returns:\n        string containing the version of App\n    \"\"\"\n\n    return __global_hyfi__.version\n</code></pre>"},{"location":"reference/core/#hyfi.core.GlobalHyFIResolver.__config_module_path__","title":"<code>__config_module_path__()</code>  <code>staticmethod</code>","text":"<p>Global HyFI config path for the package to search for.</p> Source code in <code>hyfi/core/core.py</code> <pre><code>@staticmethod\ndef __config_module_path__() -&gt; str:\n    \"\"\"Global HyFI config path for the package to search for.\"\"\"\n    return __global_hyfi__.config_module_path\n</code></pre>"},{"location":"reference/core/#hyfi.core.GlobalHyFIResolver.__home_path__","title":"<code>__home_path__()</code>  <code>staticmethod</code>","text":"<p>Returns the path to the user's home folder</p> Source code in <code>hyfi/core/core.py</code> <pre><code>@staticmethod\ndef __home_path__() -&gt; str:\n    \"\"\"Returns the path to the user's home folder\"\"\"\n    return Path.home().as_posix()\n</code></pre>"},{"location":"reference/core/#hyfi.core.GlobalHyFIResolver.__hyfi_path__","title":"<code>__hyfi_path__()</code>","text":"<p>Returns the path to the HyFI root folder</p> Source code in <code>hyfi/core/core.py</code> <pre><code>def __hyfi_path__() -&gt; str:\n    \"\"\"Returns the path to the HyFI root folder\"\"\"\n    return __global_hyfi__.hyfi_package_path\n</code></pre>"},{"location":"reference/core/#hyfi.core.GlobalHyFIResolver.__hyfi_version__","title":"<code>__hyfi_version__()</code>  <code>staticmethod</code>","text":"<p>Returns the version of HyFI.</p> <p>Returns:</p> Type Description <code>str</code> <p>string containing the version of HyFI</p> Source code in <code>hyfi/core/core.py</code> <pre><code>@staticmethod\ndef __hyfi_version__() -&gt; str:\n    \"\"\"\n    Returns the version of HyFI.\n\n    Returns:\n        string containing the version of HyFI\n    \"\"\"\n    from hyfi._version import __version__\n\n    return __version__\n</code></pre>"},{"location":"reference/core/#hyfi.core.GlobalHyFIResolver.__package_name__","title":"<code>__package_name__()</code>  <code>staticmethod</code>","text":"<p>Returns the package name of the App</p> <p>Returns:</p> Type Description <code>str</code> <p>string containing the package name of the App</p> Source code in <code>hyfi/core/core.py</code> <pre><code>@staticmethod\ndef __package_name__() -&gt; str:\n    \"\"\"\n    Returns the package name of the App\n\n    Returns:\n        string containing the package name of the App\n    \"\"\"\n\n    return __global_hyfi__.package_name\n</code></pre>"},{"location":"reference/core/#hyfi.core.GlobalHyFIResolver.__package_path__","title":"<code>__package_path__()</code>  <code>staticmethod</code>","text":"<p>Returns the path to the App root folder</p> <p>Returns:</p> Type Description <code>str</code> <p>string containing the path to the App root folder</p> Source code in <code>hyfi/core/core.py</code> <pre><code>@staticmethod\ndef __package_path__() -&gt; str:\n    \"\"\"\n    Returns the path to the App root folder\n\n    Returns:\n        string containing the path to the App root folder\n    \"\"\"\n\n    return __global_hyfi__.package_path\n</code></pre>"},{"location":"reference/core/#hyfi.core.GlobalHyFIResolver.__user_config_path__","title":"<code>__user_config_path__()</code>  <code>staticmethod</code>","text":"<p>Global HyFI user config path for the package to search for.</p> Source code in <code>hyfi/core/core.py</code> <pre><code>@staticmethod\ndef __user_config_path__() -&gt; str:\n    \"\"\"Global HyFI user config path for the package to search for.\"\"\"\n    return __global_hyfi__.user_config_path\n</code></pre>"},{"location":"reference/env/","title":"<code>hyfi.env</code>","text":""},{"location":"reference/env/#hyfi.env.Env","title":"<code>Env</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Configuration class for environment variables in HyFI.</p> <p>Attributes:</p> Name Type Description <code>_config_name_</code> <code>str</code> <p>str: Name of the configuration.</p> <code>DOTENV_FILENAME</code> <code>str</code> <p>Optional[str]: Name of the dotenv file.</p> <code>DOTENV_DIR</code> <code>str</code> <p>Optional[str]: Path to the dotenv file.</p> <code>DOTENV_FILE</code> <code>str</code> <p>Optional[str]: Full path to the dotenv file.</p> <code>HYFI_RESOURCE_DIR</code> <code>Optional[str]</code> <p>Optional[str]: Path to the resource directory.</p> <code>HYFI_GLOBAL_ROOT</code> <code>Optional[str]</code> <p>Optional[str]: Path to the global root directory.</p> <code>HYFI_GLOBAL_WORKSPACE_NAME</code> <code>Optional[str]</code> <p>Optional[str]: Name of the global workspace.</p> <code>HYFI_PROJECT_NAME</code> <code>Optional[str]</code> <p>Optional[str]: Name of the project.</p> <code>HYFI_PROJECT_DESC</code> <code>Optional[str]</code> <p>Optional[str]: Description of the project.</p> <code>HYFI_PROJECT_ROOT</code> <code>Optional[str]</code> <p>Optional[str]: Path to the project root directory.</p> <code>HYFI_PROJECT_WORKSPACE_NAME</code> <code>Optional[str]</code> <p>Optional[str]: Name of the project workspace.</p> <code>HYFI_LOG_LEVEL</code> <code>Optional[str]</code> <p>Optional[str]: Log level for HyFI.</p> <code>HYFI_VERBOSE</code> <code>Optional[Union[bool, str, int]]</code> <p>Optional[Union[bool, str, int]]: Verbosity level for HyFI.</p> <code>HYFI_NUM_WORKERS</code> <code>Optional[int]</code> <p>Optional[int]: Number of workers for HyFI.</p> <code>CACHED_PATH_CACHE_ROOT</code> <code>Optional[str]</code> <p>Optional[str]: Path to the cached path cache root.</p> Source code in <code>hyfi/env/env.py</code> <pre><code>class Env(BaseSettings):\n    \"\"\"\n    Configuration class for environment variables in HyFI.\n\n    Attributes:\n        _config_name_: str: Name of the configuration.\n        DOTENV_FILENAME: Optional[str]: Name of the dotenv file.\n        DOTENV_DIR: Optional[str]: Path to the dotenv file.\n        DOTENV_FILE: Optional[str]: Full path to the dotenv file.\n        HYFI_RESOURCE_DIR: Optional[str]: Path to the resource directory.\n        HYFI_GLOBAL_ROOT: Optional[str]: Path to the global root directory.\n        HYFI_GLOBAL_WORKSPACE_NAME: Optional[str]: Name of the global workspace.\n        HYFI_PROJECT_NAME: Optional[str]: Name of the project.\n        HYFI_PROJECT_DESC: Optional[str]: Description of the project.\n        HYFI_PROJECT_ROOT: Optional[str]: Path to the project root directory.\n        HYFI_PROJECT_WORKSPACE_NAME: Optional[str]: Name of the project workspace.\n        HYFI_LOG_LEVEL: Optional[str]: Log level for HyFI.\n        HYFI_VERBOSE: Optional[Union[bool, str, int]]: Verbosity level for HyFI.\n        HYFI_NUM_WORKERS: Optional[int]: Number of workers for HyFI.\n        CACHED_PATH_CACHE_ROOT: Optional[str]: Path to the cached path cache root.\n    \"\"\"\n\n    \"\"\"Environment variables for HyFI\"\"\"\n\n    _config_name_: str = \"__init__\"\n    _config_group_: str = \"/env\"\n\n    # Internal\n    HYFI_RESOURCE_DIR: Optional[str] = None\n    HYFI_GLOBAL_ROOT: Optional[str] = None\n    HYFI_GLOBAL_WORKSPACE_NAME: Optional[str] = \".hyfi\"\n    HYFI_PROJECT_NAME: Optional[str] = None\n    HYFI_PROJECT_DESC: Optional[str] = None\n    HYFI_PROJECT_ROOT: Optional[str] = None\n    HYFI_PROJECT_WORKSPACE_NAME: Optional[str] = \"workspace\"\n    HYFI_LOG_LEVEL: Optional[str] = \"WARNING\"\n    HYFI_VERBOSE: Optional[Union[bool, str, int]] = False\n    HYFI_NUM_WORKERS: Optional[int] = 1\n    CACHED_PATH_CACHE_ROOT: Optional[str] = None\n</code></pre>"},{"location":"reference/env/#hyfi.env.ProjectEnv","title":"<code>ProjectEnv</code>","text":"<p>               Bases: <code>Env</code></p> <p>Project configuration class for environment variables in HyFI.</p> <p>Attributes:</p> Name Type Description <code>CUDA_DEVICE_ORDER</code> <code>Optional[str]</code> <p>Optional[str]: CUDA device order.</p> <code>CUDA_VISIBLE_DEVICES</code> <code>Optional[Union[str, int]]</code> <p>Optional[str]: CUDA visible devices.</p> <code>WANDB_PROJECT</code> <code>Optional[str]</code> <p>Optional[str]: Name of the Weights &amp; Biases project.</p> <code>WANDB_DISABLED</code> <code>Optional[Union[bool, str]]</code> <p>Optional[str]: Whether Weights &amp; Biases is disabled.</p> <code>WANDB_DIR</code> <code>Optional[str]</code> <p>Optional[str]: Path to the Weights &amp; Biases directory.</p> <code>WANDB_NOTEBOOK_NAME</code> <code>Optional[str]</code> <p>Optional[str]: Name of the Weights &amp; Biases notebook.</p> <code>WANDB_SILENT</code> <code>Optional[Union[bool, str]]</code> <p>Optional[Union[bool, str]]: Whether Weights &amp; Biases is silent.</p> <code>LABEL_STUDIO_SERVER</code> <code>Optional[str]</code> <p>Optional[str]: URL of the Label Studio server.</p> <code>KMP_DUPLICATE_LIB_OK</code> <code>Optional[str]</code> <p>Optional[str]: Whether to allow duplicate libraries for Intel MKL.</p> <code>TOKENIZERS_PARALLELISM</code> <code>Optional[Union[bool, str]]</code> <p>Optional[Union[bool, str]]: Whether tokenizers are parallelized.</p> <code>WANDB_API_KEY</code> <code>Optional[SecretStr]</code> <p>Optional[SecretStr]: Weights &amp; Biases API key.</p> <code>HUGGING_FACE_HUB_TOKEN</code> <code>Optional[SecretStr]</code> <p>Optional[SecretStr]: Hugging Face Hub token.</p> <code>OPENAI_API_KEY</code> <code>Optional[SecretStr]</code> <p>Optional[SecretStr]: OpenAI API key.</p> <code>ECOS_API_KEY</code> <code>Optional[SecretStr]</code> <p>Optional[SecretStr]: ECOS API key.</p> <code>FRED_API_KEY</code> <code>Optional[SecretStr]</code> <p>Optional[SecretStr]: FRED API key.</p> <code>NASDAQ_API_KEY</code> <code>Optional[SecretStr]</code> <p>Optional[SecretStr]: NASDAQ API key.</p> <code>HF_USER_ACCESS_TOKEN</code> <code>Optional[SecretStr]</code> <p>Optional[SecretStr]: Hugging Face user access token.</p> <code>LABEL_STUDIO_USER_TOKEN</code> <code>Optional[SecretStr]</code> <p>Optional[SecretStr]: Label Studio user token.</p> Source code in <code>hyfi/env/env.py</code> <pre><code>class ProjectEnv(Env):\n    \"\"\"\n    Project configuration class for environment variables in HyFI.\n\n    Attributes:\n        CUDA_DEVICE_ORDER: Optional[str]: CUDA device order.\n        CUDA_VISIBLE_DEVICES: Optional[str]: CUDA visible devices.\n        WANDB_PROJECT: Optional[str]: Name of the Weights &amp; Biases project.\n        WANDB_DISABLED: Optional[str]: Whether Weights &amp; Biases is disabled.\n        WANDB_DIR: Optional[str]: Path to the Weights &amp; Biases directory.\n        WANDB_NOTEBOOK_NAME: Optional[str]: Name of the Weights &amp; Biases notebook.\n        WANDB_SILENT: Optional[Union[bool, str]]: Whether Weights &amp; Biases is silent.\n        LABEL_STUDIO_SERVER: Optional[str]: URL of the Label Studio server.\n        KMP_DUPLICATE_LIB_OK: Optional[str]: Whether to allow duplicate libraries for Intel MKL.\n        TOKENIZERS_PARALLELISM: Optional[Union[bool, str]]: Whether tokenizers are parallelized.\n        WANDB_API_KEY: Optional[SecretStr]: Weights &amp; Biases API key.\n        HUGGING_FACE_HUB_TOKEN: Optional[SecretStr]: Hugging Face Hub token.\n        OPENAI_API_KEY: Optional[SecretStr]: OpenAI API key.\n        ECOS_API_KEY: Optional[SecretStr]: ECOS API key.\n        FRED_API_KEY: Optional[SecretStr]: FRED API key.\n        NASDAQ_API_KEY: Optional[SecretStr]: NASDAQ API key.\n        HF_USER_ACCESS_TOKEN: Optional[SecretStr]: Hugging Face user access token.\n        LABEL_STUDIO_USER_TOKEN: Optional[SecretStr]: Label Studio user token.\n    \"\"\"\n\n    \"\"\"Environment variables for HyFI\"\"\"\n\n    _config_name_: str = \"__project__\"\n\n    # For other packages\n    CUDA_DEVICE_ORDER: Optional[str] = \"PCI_BUS_ID\"\n    CUDA_VISIBLE_DEVICES: Optional[Union[str, int]] = None\n    WANDB_PROJECT: Optional[str] = None\n    WANDB_DISABLED: Optional[Union[bool, str]] = None\n    WANDB_DIR: Optional[str] = None\n    WANDB_NOTEBOOK_NAME: Optional[str] = None\n    WANDB_SILENT: Optional[Union[bool, str]] = None\n    LABEL_STUDIO_SERVER: Optional[str] = None\n    KMP_DUPLICATE_LIB_OK: Optional[str] = \"True\"\n    TOKENIZERS_PARALLELISM: Optional[Union[bool, str]] = False\n    # API Keys and Tokens\n    WANDB_API_KEY: Optional[SecretStr] = Field(exclude=True, default=\"\")\n    HUGGING_FACE_HUB_TOKEN: Optional[SecretStr] = Field(exclude=True, default=\"\")\n    OPENAI_API_KEY: Optional[SecretStr] = Field(exclude=True, default=\"\")\n    ECOS_API_KEY: Optional[SecretStr] = Field(exclude=True, default=\"\")\n    FRED_API_KEY: Optional[SecretStr] = Field(exclude=True, default=\"\")\n    NASDAQ_API_KEY: Optional[SecretStr] = Field(exclude=True, default=\"\")\n    HF_USER_ACCESS_TOKEN: Optional[SecretStr] = Field(exclude=True, default=\"\")\n    LABEL_STUDIO_USER_TOKEN: Optional[SecretStr] = Field(exclude=True, default=\"\")\n</code></pre>"},{"location":"reference/graphics/","title":"<code>hyfi.graphics</code>","text":""},{"location":"reference/graphics/#hyfi.graphics.COLLAGE","title":"<code>COLLAGE</code>","text":"Source code in <code>hyfi/graphics/collage.py</code> <pre><code>class COLLAGE:\n    @staticmethod\n    def collage(\n        images_or_uris: Union[\n            List[Union[str, Path, Image.Image]], str, Path, Image.Image\n        ],\n        output_file: Optional[Union[str, Path]] = None,\n        num_cols: Optional[int] = 3,\n        num_images: Optional[int] = 12,\n        collage_width: int = 1200,\n        padding: int = 10,\n        background_color: str = \"black\",\n        crop_to_min_size: bool = False,\n        show_filename: bool = False,\n        filename_offset: Tuple[int, int] = (5, 5),\n        fontname: Optional[str] = None,\n        fontsize: int = 12,\n        fontcolor: str = \"#000\",\n        **kwargs,\n    ) -&gt; Optional[Collage]:\n        \"\"\"\n        Create a collage of images.\n        \"\"\"\n\n        if not isinstance(images_or_uris, list):\n            images_or_uris = [images_or_uris]\n        images_or_uris = [\n            uri if isinstance(uri, Image.Image) else str(uri) for uri in images_or_uris\n        ]\n\n        if num_images:\n            num_images = min(num_images, len(images_or_uris))\n        else:\n            num_images = len(images_or_uris)\n        if num_images &lt; 1:\n            raise ValueError(\"max_images must be greater than 0\")\n        num_images, num_cols, nrows = GUTILs.get_grid_size(\n            num_images, num_cols=num_cols\n        )\n        logger.info(\n            \"Creating collage of %d images in %d columns and %d rows\",\n            num_images,\n            num_cols,\n            nrows,\n        )\n        img_width = collage_width // num_cols\n        collage_width = num_cols * img_width + padding * (num_cols + 1)\n\n        # load images\n        images = GUTILs.load_images(\n            images_or_uris[:num_images],\n            resize_to_multiple_of=None,\n            crop_to_min_size=crop_to_min_size,\n            max_width=img_width,\n            **kwargs,\n        )\n        filenames = [\n            os.path.basename(image_or_uri) if isinstance(image_or_uri, str) else None\n            for image_or_uri in images_or_uris[:num_images]\n        ]\n        # convert images\n        images = [\n            GUTILs.print_filename_on_image(\n                image,\n                print_filename=show_filename,\n                filename=filename,\n                filename_offset=filename_offset,\n                fontname=fontname,\n                fontsize=fontsize,\n                fontcolor=fontcolor,\n            )\n            for image, filename in zip(images, filenames)\n        ]\n\n        collage = COLLAGE.get_grid_of_images(\n            images, num_cols, padding, background_color=background_color\n        )\n        if output_file:\n            output_file = str(output_file)\n            os.makedirs(os.path.dirname(output_file), exist_ok=True)\n            collage.image.save(output_file)\n            collage.filepath = output_file\n            logger.info(\"Saved collage to %s\", output_file)\n        return collage\n\n    @staticmethod\n    def label_collage(\n        collage: Collage,\n        collage_filepath=None,\n        title: Optional[str] = None,\n        title_fontsize: int = 10,\n        xlabel=None,\n        ylabel=None,\n        xticklabels=None,\n        yticklabels=None,\n        xlabel_fontsize=12,\n        ylabel_fontsize=12,\n        dpi=100,\n        fg_fontcolor=\"white\",\n        bg_color=\"black\",\n        caption=None,\n        **kwargs,\n    ) -&gt; Collage:\n        \"\"\"\n        Create a collage of images.\n        \"\"\"\n        figsize = (collage.width / dpi, collage.height / dpi)\n        ncols, nrows = collage.ncols, collage.nrows\n\n        fig = plt.figure(figsize=figsize, dpi=dpi)\n        fig.patch.set_facecolor(bg_color)  # type: ignore\n        plt.imshow(np.array(collage.image))\n        ax = plt.gca()\n        plt.grid(False)\n        if xlabel is None and ylabel is None:\n            plt.axis(\"off\")\n        if title is not None:\n            title = \"\\n\".join(\n                sum(\n                    (\n                        textwrap.wrap(\n                            t, width=int(collage.width / 15 * 12 / title_fontsize)\n                        )\n                        for t in title.split(\"\\n\")\n                    ),\n                    [],\n                )\n            )\n            ax.set_title(title, fontsize=title_fontsize, color=fg_fontcolor)\n        if xlabel is not None:\n            # plt.xlabel(xlabel, fontdict={\"fontsize\": xlabel_fontsize})\n            ax.set_xlabel(xlabel, fontsize=xlabel_fontsize, color=fg_fontcolor)\n        if ylabel is not None:\n            # plt.ylabel(ylabel, fontdict={\"fontsize\": ylabel_fontsize})\n            ax.set_ylabel(ylabel, fontsize=ylabel_fontsize, color=fg_fontcolor)\n        if xticklabels is not None:\n            # get ncols number of xticks from xlim\n            xlim = ax.get_xlim()\n            xticks = GUTILs.get_ticks_from_lim(xlim, ncols)\n            ax.set_xticks(xticks, color=fg_fontcolor)\n            xticklabels = [\"\"] + xticklabels\n            ax.set_xticklabels(\n                xticklabels, fontsize=xlabel_fontsize, color=fg_fontcolor\n            )\n        if yticklabels is not None:\n            # get nrows number of yticks from ylim\n            ylim = ax.get_ylim()\n            yticks = GUTILs.get_ticks_from_lim(ylim, nrows)\n            ax.set_yticks(yticks, color=fg_fontcolor)\n            yticklabels = [\"\"] + yticklabels\n            ax.set_yticklabels(\n                yticklabels, fontsize=ylabel_fontsize, color=fg_fontcolor\n            )\n\n        plt.tight_layout()\n        if caption is not None:\n            plt.figtext(\n                0.5,\n                0.01,\n                caption,\n                wrap=True,\n                horizontalalignment=\"center\",\n                fontsize=10,\n                color=fg_fontcolor,\n            )\n\n        img = GUTILs.convert_figure_to_image(fig, dpi=dpi)\n        img = GUTILs.scale_image(img, max_width=collage.width)\n        plt.close()\n\n        if collage_filepath is not None:\n            collage_filepath = str(collage_filepath)\n            os.makedirs(os.path.dirname(collage_filepath), exist_ok=True)\n            # fig.savefig(collage_filepath, dpi=dpi, bbox_inches=\"tight\", pad_inches=0)\n            img.save(collage_filepath)\n            # collage_image.save(collage_filepath)\n            # log.info(f\"Saved collage to {collage_filepath}\")\n\n        return Collage(\n            image=img,\n            filepath=collage_filepath,\n            width=img.width,\n            height=img.height,\n            ncols=ncols,\n            nrows=nrows,\n        )\n\n    @staticmethod\n    def get_grid_of_images(\n        images: List[Image.Image],\n        num_cols: int = 3,\n        padding: int = 10,\n        background_color: str = \"black\",\n    ) -&gt; Collage:\n        \"\"\"\n        Create a grid of images.\n        \"\"\"\n        nrows = len(images) // num_cols\n        assert len(images) == nrows * num_cols\n        width, height = images[0].size\n        grid_width = num_cols * width + padding * (num_cols + 1)\n        grid_height = nrows * height + padding * (nrows + 1)\n        collage = Image.new(\n            \"RGB\", size=(grid_width, grid_height), color=background_color\n        )\n        for j, image in enumerate(images):\n            x = j % num_cols\n            y = j // num_cols\n            collage.paste(\n                image, (x * width + padding * (x + 1), y * height + padding * (y + 1))\n            )\n        return Collage(\n            image=collage,\n            width=grid_width,\n            height=grid_height,\n            ncols=num_cols,\n            nrows=nrows,\n        )\n\n    @staticmethod\n    def gallery_ndarray_images(\n        array: np.ndarray,\n        ncols: int = 7,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Create a gallery of images from a numpy array.\n        \"\"\"\n        nindex, height, width, intensity = array.shape\n        nrows = nindex // ncols\n        assert nindex == nrows * ncols\n        return (\n            array.reshape(nrows, ncols, height, width, intensity)\n            .swapaxes(1, 2)\n            .reshape(height * nrows, width * ncols, intensity)\n        )\n\n    @staticmethod\n    def make_subplot_pages_from_images(\n        images: List[Union[str, Path, np.ndarray, Image.Image]],\n        num_images_per_page: int,\n        num_cols: int,\n        num_rows: Optional[int] = None,\n        output_dir: Optional[Union[str, Path]] = None,\n        output_file_format: str = \"collage_p{page_num}.png\",\n        titles: Optional[List[str]] = None,\n        title_fontsize: int = 10,\n        title_color: str = \"black\",\n        figsize: Optional[Tuple[float, float]] = None,\n        width_multiple: float = 4,\n        height_multiple: float = 2,\n        sharex: bool = True,\n        sharey: bool = True,\n        squeeze: bool = True,\n        dpi: int = 100,\n        verbose: bool = False,\n    ):\n        \"\"\"Make subplot pages from images.\n\n        Args:\n            images: List of images to be plotted.\n            num_images_per_page: Number of images per page.\n            num_cols: Number of columns.\n            num_rows: Number of rows. If None, it will be calculated automatically.\n            output_dir: Output directory.\n            output_file_format: Output file format.\n            titles: List of titles for each image.\n            title_fontsize: Title fontsize.\n            title_color: Title color.\n            figsize: Figure size.\n            width_multiple: Width multiple.\n            height_multiple: Height multiple.\n            sharex: Share x-axis.\n            sharey: Share y-axis.\n            squeeze: Squeeze.\n            dpi: Dots per inch.\n        \"\"\"\n        num_images = len(images)\n        num_pages = math.ceil(num_images / num_images_per_page)\n        for page_num in range(num_pages):\n            start_idx = page_num * num_images_per_page\n            end_idx = start_idx + num_images_per_page\n            page_images = images[start_idx:end_idx]\n            page_titles = titles[start_idx:end_idx] if titles else None\n            page_output_file = (\n                Path(output_dir) / output_file_format.format(page_num=page_num)\n                if output_dir\n                else None\n            )\n            if verbose:\n                logger.info(\n                    f\"Making page {page_num + 1}/{num_pages} with {len(page_images)} images\"\n                )\n                logger.info(f\"Page titles: {page_titles}\")\n                logger.info(f\"Page output file: {page_output_file}\")\n            COLLAGE.make_subplots_from_images(\n                page_images,\n                num_cols=num_cols,\n                num_rows=num_rows,\n                output_file=page_output_file,\n                titles=page_titles,\n                title_fontsize=title_fontsize,\n                title_color=title_color,\n                figsize=figsize,\n                width_multiple=width_multiple,\n                height_multiple=height_multiple,\n                sharex=sharex,\n                sharey=sharey,\n                squeeze=squeeze,\n                dpi=dpi,\n                verbose=verbose,\n            )\n\n    @staticmethod\n    def make_subplots_from_images(\n        images: List[Union[str, Path, np.ndarray, Image.Image]],\n        num_cols: int,\n        num_rows: Optional[int] = None,\n        output_file: Optional[Union[str, Path]] = None,\n        titles: Optional[List[str]] = None,\n        title_fontsize: int = 10,\n        title_color: str = \"black\",\n        figsize: Optional[Tuple[float, float]] = None,\n        width_multiple: float = 4,\n        height_multiple: float = 2,\n        sharex: bool = True,\n        sharey: bool = True,\n        squeeze: bool = True,\n        dpi: int = 100,\n        verbose: bool = False,\n    ):\n        \"\"\"Make subplots from images.\n\n        Args:\n            images: List of images to be plotted.\n            num_cols: Number of columns.\n            num_rows: Number of rows. If None, it will be calculated automatically.\n            output_file: Output file path.\n            titles: List of titles for each image.\n            title_fontsize: Title fontsize.\n            title_color: Title color.\n            figsize: Figure size.\n            sharex: Share x-axis or not.\n            sharey: Share y-axis or not.\n            squeeze: Squeeze or not.\n            dpi: Dots per inch.\n        \"\"\"\n        if num_rows is None:\n            num_images = len(images)\n            num_rows = math.ceil(num_images / num_cols)\n        if figsize is None:\n            figsize = (num_cols * width_multiple, num_rows * height_multiple)\n        fig, axes = plt.subplots(\n            num_rows,\n            num_cols,\n            figsize=figsize,\n            sharex=sharex,\n            sharey=sharey,\n            squeeze=squeeze,\n        )\n        for i in range(num_cols * num_rows):\n            ax = (\n                axes[i % num_cols]\n                if num_rows == 1\n                else axes[i // num_cols, i % num_cols]\n            )\n            if i &gt;= len(images):\n                ax.set_visible(False)\n                continue\n            image = images[i]\n            if isinstance(image, (str, Path)):\n                image = GUTILs.load_image(image)\n            ax.imshow(image)\n            if titles:\n                ax.set_title(titles[i], fontsize=title_fontsize, color=title_color)\n            ax.axis(\"off\")\n        if output_file:\n            GUTILs.save_adjusted_subplots(fig, output_file, dpi=dpi, verbose=verbose)\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.COLLAGE.collage","title":"<code>collage(images_or_uris, output_file=None, num_cols=3, num_images=12, collage_width=1200, padding=10, background_color='black', crop_to_min_size=False, show_filename=False, filename_offset=(5, 5), fontname=None, fontsize=12, fontcolor='#000', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a collage of images.</p> Source code in <code>hyfi/graphics/collage.py</code> <pre><code>@staticmethod\ndef collage(\n    images_or_uris: Union[\n        List[Union[str, Path, Image.Image]], str, Path, Image.Image\n    ],\n    output_file: Optional[Union[str, Path]] = None,\n    num_cols: Optional[int] = 3,\n    num_images: Optional[int] = 12,\n    collage_width: int = 1200,\n    padding: int = 10,\n    background_color: str = \"black\",\n    crop_to_min_size: bool = False,\n    show_filename: bool = False,\n    filename_offset: Tuple[int, int] = (5, 5),\n    fontname: Optional[str] = None,\n    fontsize: int = 12,\n    fontcolor: str = \"#000\",\n    **kwargs,\n) -&gt; Optional[Collage]:\n    \"\"\"\n    Create a collage of images.\n    \"\"\"\n\n    if not isinstance(images_or_uris, list):\n        images_or_uris = [images_or_uris]\n    images_or_uris = [\n        uri if isinstance(uri, Image.Image) else str(uri) for uri in images_or_uris\n    ]\n\n    if num_images:\n        num_images = min(num_images, len(images_or_uris))\n    else:\n        num_images = len(images_or_uris)\n    if num_images &lt; 1:\n        raise ValueError(\"max_images must be greater than 0\")\n    num_images, num_cols, nrows = GUTILs.get_grid_size(\n        num_images, num_cols=num_cols\n    )\n    logger.info(\n        \"Creating collage of %d images in %d columns and %d rows\",\n        num_images,\n        num_cols,\n        nrows,\n    )\n    img_width = collage_width // num_cols\n    collage_width = num_cols * img_width + padding * (num_cols + 1)\n\n    # load images\n    images = GUTILs.load_images(\n        images_or_uris[:num_images],\n        resize_to_multiple_of=None,\n        crop_to_min_size=crop_to_min_size,\n        max_width=img_width,\n        **kwargs,\n    )\n    filenames = [\n        os.path.basename(image_or_uri) if isinstance(image_or_uri, str) else None\n        for image_or_uri in images_or_uris[:num_images]\n    ]\n    # convert images\n    images = [\n        GUTILs.print_filename_on_image(\n            image,\n            print_filename=show_filename,\n            filename=filename,\n            filename_offset=filename_offset,\n            fontname=fontname,\n            fontsize=fontsize,\n            fontcolor=fontcolor,\n        )\n        for image, filename in zip(images, filenames)\n    ]\n\n    collage = COLLAGE.get_grid_of_images(\n        images, num_cols, padding, background_color=background_color\n    )\n    if output_file:\n        output_file = str(output_file)\n        os.makedirs(os.path.dirname(output_file), exist_ok=True)\n        collage.image.save(output_file)\n        collage.filepath = output_file\n        logger.info(\"Saved collage to %s\", output_file)\n    return collage\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.COLLAGE.gallery_ndarray_images","title":"<code>gallery_ndarray_images(array, ncols=7)</code>  <code>staticmethod</code>","text":"<p>Create a gallery of images from a numpy array.</p> Source code in <code>hyfi/graphics/collage.py</code> <pre><code>@staticmethod\ndef gallery_ndarray_images(\n    array: np.ndarray,\n    ncols: int = 7,\n) -&gt; np.ndarray:\n    \"\"\"\n    Create a gallery of images from a numpy array.\n    \"\"\"\n    nindex, height, width, intensity = array.shape\n    nrows = nindex // ncols\n    assert nindex == nrows * ncols\n    return (\n        array.reshape(nrows, ncols, height, width, intensity)\n        .swapaxes(1, 2)\n        .reshape(height * nrows, width * ncols, intensity)\n    )\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.COLLAGE.get_grid_of_images","title":"<code>get_grid_of_images(images, num_cols=3, padding=10, background_color='black')</code>  <code>staticmethod</code>","text":"<p>Create a grid of images.</p> Source code in <code>hyfi/graphics/collage.py</code> <pre><code>@staticmethod\ndef get_grid_of_images(\n    images: List[Image.Image],\n    num_cols: int = 3,\n    padding: int = 10,\n    background_color: str = \"black\",\n) -&gt; Collage:\n    \"\"\"\n    Create a grid of images.\n    \"\"\"\n    nrows = len(images) // num_cols\n    assert len(images) == nrows * num_cols\n    width, height = images[0].size\n    grid_width = num_cols * width + padding * (num_cols + 1)\n    grid_height = nrows * height + padding * (nrows + 1)\n    collage = Image.new(\n        \"RGB\", size=(grid_width, grid_height), color=background_color\n    )\n    for j, image in enumerate(images):\n        x = j % num_cols\n        y = j // num_cols\n        collage.paste(\n            image, (x * width + padding * (x + 1), y * height + padding * (y + 1))\n        )\n    return Collage(\n        image=collage,\n        width=grid_width,\n        height=grid_height,\n        ncols=num_cols,\n        nrows=nrows,\n    )\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.COLLAGE.label_collage","title":"<code>label_collage(collage, collage_filepath=None, title=None, title_fontsize=10, xlabel=None, ylabel=None, xticklabels=None, yticklabels=None, xlabel_fontsize=12, ylabel_fontsize=12, dpi=100, fg_fontcolor='white', bg_color='black', caption=None, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a collage of images.</p> Source code in <code>hyfi/graphics/collage.py</code> <pre><code>@staticmethod\ndef label_collage(\n    collage: Collage,\n    collage_filepath=None,\n    title: Optional[str] = None,\n    title_fontsize: int = 10,\n    xlabel=None,\n    ylabel=None,\n    xticklabels=None,\n    yticklabels=None,\n    xlabel_fontsize=12,\n    ylabel_fontsize=12,\n    dpi=100,\n    fg_fontcolor=\"white\",\n    bg_color=\"black\",\n    caption=None,\n    **kwargs,\n) -&gt; Collage:\n    \"\"\"\n    Create a collage of images.\n    \"\"\"\n    figsize = (collage.width / dpi, collage.height / dpi)\n    ncols, nrows = collage.ncols, collage.nrows\n\n    fig = plt.figure(figsize=figsize, dpi=dpi)\n    fig.patch.set_facecolor(bg_color)  # type: ignore\n    plt.imshow(np.array(collage.image))\n    ax = plt.gca()\n    plt.grid(False)\n    if xlabel is None and ylabel is None:\n        plt.axis(\"off\")\n    if title is not None:\n        title = \"\\n\".join(\n            sum(\n                (\n                    textwrap.wrap(\n                        t, width=int(collage.width / 15 * 12 / title_fontsize)\n                    )\n                    for t in title.split(\"\\n\")\n                ),\n                [],\n            )\n        )\n        ax.set_title(title, fontsize=title_fontsize, color=fg_fontcolor)\n    if xlabel is not None:\n        # plt.xlabel(xlabel, fontdict={\"fontsize\": xlabel_fontsize})\n        ax.set_xlabel(xlabel, fontsize=xlabel_fontsize, color=fg_fontcolor)\n    if ylabel is not None:\n        # plt.ylabel(ylabel, fontdict={\"fontsize\": ylabel_fontsize})\n        ax.set_ylabel(ylabel, fontsize=ylabel_fontsize, color=fg_fontcolor)\n    if xticklabels is not None:\n        # get ncols number of xticks from xlim\n        xlim = ax.get_xlim()\n        xticks = GUTILs.get_ticks_from_lim(xlim, ncols)\n        ax.set_xticks(xticks, color=fg_fontcolor)\n        xticklabels = [\"\"] + xticklabels\n        ax.set_xticklabels(\n            xticklabels, fontsize=xlabel_fontsize, color=fg_fontcolor\n        )\n    if yticklabels is not None:\n        # get nrows number of yticks from ylim\n        ylim = ax.get_ylim()\n        yticks = GUTILs.get_ticks_from_lim(ylim, nrows)\n        ax.set_yticks(yticks, color=fg_fontcolor)\n        yticklabels = [\"\"] + yticklabels\n        ax.set_yticklabels(\n            yticklabels, fontsize=ylabel_fontsize, color=fg_fontcolor\n        )\n\n    plt.tight_layout()\n    if caption is not None:\n        plt.figtext(\n            0.5,\n            0.01,\n            caption,\n            wrap=True,\n            horizontalalignment=\"center\",\n            fontsize=10,\n            color=fg_fontcolor,\n        )\n\n    img = GUTILs.convert_figure_to_image(fig, dpi=dpi)\n    img = GUTILs.scale_image(img, max_width=collage.width)\n    plt.close()\n\n    if collage_filepath is not None:\n        collage_filepath = str(collage_filepath)\n        os.makedirs(os.path.dirname(collage_filepath), exist_ok=True)\n        # fig.savefig(collage_filepath, dpi=dpi, bbox_inches=\"tight\", pad_inches=0)\n        img.save(collage_filepath)\n        # collage_image.save(collage_filepath)\n        # log.info(f\"Saved collage to {collage_filepath}\")\n\n    return Collage(\n        image=img,\n        filepath=collage_filepath,\n        width=img.width,\n        height=img.height,\n        ncols=ncols,\n        nrows=nrows,\n    )\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.COLLAGE.make_subplot_pages_from_images","title":"<code>make_subplot_pages_from_images(images, num_images_per_page, num_cols, num_rows=None, output_dir=None, output_file_format='collage_p{page_num}.png', titles=None, title_fontsize=10, title_color='black', figsize=None, width_multiple=4, height_multiple=2, sharex=True, sharey=True, squeeze=True, dpi=100, verbose=False)</code>  <code>staticmethod</code>","text":"<p>Make subplot pages from images.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>List[Union[str, Path, ndarray, Image]]</code> <p>List of images to be plotted.</p> required <code>num_images_per_page</code> <code>int</code> <p>Number of images per page.</p> required <code>num_cols</code> <code>int</code> <p>Number of columns.</p> required <code>num_rows</code> <code>Optional[int]</code> <p>Number of rows. If None, it will be calculated automatically.</p> <code>None</code> <code>output_dir</code> <code>Optional[Union[str, Path]]</code> <p>Output directory.</p> <code>None</code> <code>output_file_format</code> <code>str</code> <p>Output file format.</p> <code>'collage_p{page_num}.png'</code> <code>titles</code> <code>Optional[List[str]]</code> <p>List of titles for each image.</p> <code>None</code> <code>title_fontsize</code> <code>int</code> <p>Title fontsize.</p> <code>10</code> <code>title_color</code> <code>str</code> <p>Title color.</p> <code>'black'</code> <code>figsize</code> <code>Optional[Tuple[float, float]]</code> <p>Figure size.</p> <code>None</code> <code>width_multiple</code> <code>float</code> <p>Width multiple.</p> <code>4</code> <code>height_multiple</code> <code>float</code> <p>Height multiple.</p> <code>2</code> <code>sharex</code> <code>bool</code> <p>Share x-axis.</p> <code>True</code> <code>sharey</code> <code>bool</code> <p>Share y-axis.</p> <code>True</code> <code>squeeze</code> <code>bool</code> <p>Squeeze.</p> <code>True</code> <code>dpi</code> <code>int</code> <p>Dots per inch.</p> <code>100</code> Source code in <code>hyfi/graphics/collage.py</code> <pre><code>@staticmethod\ndef make_subplot_pages_from_images(\n    images: List[Union[str, Path, np.ndarray, Image.Image]],\n    num_images_per_page: int,\n    num_cols: int,\n    num_rows: Optional[int] = None,\n    output_dir: Optional[Union[str, Path]] = None,\n    output_file_format: str = \"collage_p{page_num}.png\",\n    titles: Optional[List[str]] = None,\n    title_fontsize: int = 10,\n    title_color: str = \"black\",\n    figsize: Optional[Tuple[float, float]] = None,\n    width_multiple: float = 4,\n    height_multiple: float = 2,\n    sharex: bool = True,\n    sharey: bool = True,\n    squeeze: bool = True,\n    dpi: int = 100,\n    verbose: bool = False,\n):\n    \"\"\"Make subplot pages from images.\n\n    Args:\n        images: List of images to be plotted.\n        num_images_per_page: Number of images per page.\n        num_cols: Number of columns.\n        num_rows: Number of rows. If None, it will be calculated automatically.\n        output_dir: Output directory.\n        output_file_format: Output file format.\n        titles: List of titles for each image.\n        title_fontsize: Title fontsize.\n        title_color: Title color.\n        figsize: Figure size.\n        width_multiple: Width multiple.\n        height_multiple: Height multiple.\n        sharex: Share x-axis.\n        sharey: Share y-axis.\n        squeeze: Squeeze.\n        dpi: Dots per inch.\n    \"\"\"\n    num_images = len(images)\n    num_pages = math.ceil(num_images / num_images_per_page)\n    for page_num in range(num_pages):\n        start_idx = page_num * num_images_per_page\n        end_idx = start_idx + num_images_per_page\n        page_images = images[start_idx:end_idx]\n        page_titles = titles[start_idx:end_idx] if titles else None\n        page_output_file = (\n            Path(output_dir) / output_file_format.format(page_num=page_num)\n            if output_dir\n            else None\n        )\n        if verbose:\n            logger.info(\n                f\"Making page {page_num + 1}/{num_pages} with {len(page_images)} images\"\n            )\n            logger.info(f\"Page titles: {page_titles}\")\n            logger.info(f\"Page output file: {page_output_file}\")\n        COLLAGE.make_subplots_from_images(\n            page_images,\n            num_cols=num_cols,\n            num_rows=num_rows,\n            output_file=page_output_file,\n            titles=page_titles,\n            title_fontsize=title_fontsize,\n            title_color=title_color,\n            figsize=figsize,\n            width_multiple=width_multiple,\n            height_multiple=height_multiple,\n            sharex=sharex,\n            sharey=sharey,\n            squeeze=squeeze,\n            dpi=dpi,\n            verbose=verbose,\n        )\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.COLLAGE.make_subplots_from_images","title":"<code>make_subplots_from_images(images, num_cols, num_rows=None, output_file=None, titles=None, title_fontsize=10, title_color='black', figsize=None, width_multiple=4, height_multiple=2, sharex=True, sharey=True, squeeze=True, dpi=100, verbose=False)</code>  <code>staticmethod</code>","text":"<p>Make subplots from images.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>List[Union[str, Path, ndarray, Image]]</code> <p>List of images to be plotted.</p> required <code>num_cols</code> <code>int</code> <p>Number of columns.</p> required <code>num_rows</code> <code>Optional[int]</code> <p>Number of rows. If None, it will be calculated automatically.</p> <code>None</code> <code>output_file</code> <code>Optional[Union[str, Path]]</code> <p>Output file path.</p> <code>None</code> <code>titles</code> <code>Optional[List[str]]</code> <p>List of titles for each image.</p> <code>None</code> <code>title_fontsize</code> <code>int</code> <p>Title fontsize.</p> <code>10</code> <code>title_color</code> <code>str</code> <p>Title color.</p> <code>'black'</code> <code>figsize</code> <code>Optional[Tuple[float, float]]</code> <p>Figure size.</p> <code>None</code> <code>sharex</code> <code>bool</code> <p>Share x-axis or not.</p> <code>True</code> <code>sharey</code> <code>bool</code> <p>Share y-axis or not.</p> <code>True</code> <code>squeeze</code> <code>bool</code> <p>Squeeze or not.</p> <code>True</code> <code>dpi</code> <code>int</code> <p>Dots per inch.</p> <code>100</code> Source code in <code>hyfi/graphics/collage.py</code> <pre><code>@staticmethod\ndef make_subplots_from_images(\n    images: List[Union[str, Path, np.ndarray, Image.Image]],\n    num_cols: int,\n    num_rows: Optional[int] = None,\n    output_file: Optional[Union[str, Path]] = None,\n    titles: Optional[List[str]] = None,\n    title_fontsize: int = 10,\n    title_color: str = \"black\",\n    figsize: Optional[Tuple[float, float]] = None,\n    width_multiple: float = 4,\n    height_multiple: float = 2,\n    sharex: bool = True,\n    sharey: bool = True,\n    squeeze: bool = True,\n    dpi: int = 100,\n    verbose: bool = False,\n):\n    \"\"\"Make subplots from images.\n\n    Args:\n        images: List of images to be plotted.\n        num_cols: Number of columns.\n        num_rows: Number of rows. If None, it will be calculated automatically.\n        output_file: Output file path.\n        titles: List of titles for each image.\n        title_fontsize: Title fontsize.\n        title_color: Title color.\n        figsize: Figure size.\n        sharex: Share x-axis or not.\n        sharey: Share y-axis or not.\n        squeeze: Squeeze or not.\n        dpi: Dots per inch.\n    \"\"\"\n    if num_rows is None:\n        num_images = len(images)\n        num_rows = math.ceil(num_images / num_cols)\n    if figsize is None:\n        figsize = (num_cols * width_multiple, num_rows * height_multiple)\n    fig, axes = plt.subplots(\n        num_rows,\n        num_cols,\n        figsize=figsize,\n        sharex=sharex,\n        sharey=sharey,\n        squeeze=squeeze,\n    )\n    for i in range(num_cols * num_rows):\n        ax = (\n            axes[i % num_cols]\n            if num_rows == 1\n            else axes[i // num_cols, i % num_cols]\n        )\n        if i &gt;= len(images):\n            ax.set_visible(False)\n            continue\n        image = images[i]\n        if isinstance(image, (str, Path)):\n            image = GUTILs.load_image(image)\n        ax.imshow(image)\n        if titles:\n            ax.set_title(titles[i], fontsize=title_fontsize, color=title_color)\n        ax.axis(\"off\")\n    if output_file:\n        GUTILs.save_adjusted_subplots(fig, output_file, dpi=dpi, verbose=verbose)\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.Collage","title":"<code>Collage</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Collage of images.</p> Source code in <code>hyfi/graphics/collage.py</code> <pre><code>class Collage(BaseModel):\n    \"\"\"Collage of images.\"\"\"\n\n    image: Image.Image\n    width: int\n    height: int\n    ncols: int\n    nrows: int\n    filepath: Optional[str] = None\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.GUTILs","title":"<code>GUTILs</code>","text":"<p>Image utils.</p> Source code in <code>hyfi/graphics/utils.py</code> <pre><code>class GUTILs:\n    \"\"\"Image utils.\"\"\"\n\n    @staticmethod\n    def get_grid_size(\n        num_images: int,\n        num_cols: Optional[int] = None,\n        num_rows: Optional[int] = None,\n        truncate: bool = True,\n        fit_to_grid: bool = True,\n    ) -&gt; Tuple[int, int, int]:\n        \"\"\"Get number of rows and columns for a grid of images.\n\n        Args:\n            num_images (int): Number of images.\n            num_cols (int, optional): Number of columns. Defaults to None.\n            num_rows (int, optional): Number of rows. Defaults to None.\n            truncate (bool, optional): Truncate number of images to fit grid. Defaults to True. If False, the number of images will be increased to fit the grid.\n\n        Returns:\n            Tuple[int, int, int]: Number of images, columns and rows.\n        \"\"\"\n        if not num_cols and num_images % num_cols != 0 and truncate:\n            num_images = (num_images // num_cols) * num_cols\n        if not num_cols or num_cols &gt; num_images or num_cols &lt; 1:\n            num_cols = num_images // 2\n        num_rows = num_images // num_cols\n\n        return num_images, num_cols, num_rows\n\n    @staticmethod\n    def scale_image(\n        image: Image.Image,\n        max_width: Optional[int] = None,\n        max_height: Optional[int] = None,\n        max_pixels: Optional[int] = None,\n        scale: float = 1.0,\n        resize_to_multiple_of: Optional[int] = None,\n        resample: int = Image.LANCZOS,\n    ) -&gt; Image.Image:\n        \"\"\"Scale image to have at most `max_pixels` pixels.\n\n        Args:\n            image: PIL image.\n            max_width: Maximum width.\n            max_height: Maximum height.\n            max_pixels: Maximum number of pixels.\n            scale: Scale factor.\n            resize_to_multiple_of: Resize to multiple of this value.\n            resample: Resampling filter.\n\n        Returns:\n            PIL image.\n        \"\"\"\n\n        w, h = image.size\n\n        if not max_width and max_height:\n            max_width = int(w * max_height / h)\n        elif not max_height and max_width:\n            max_height = int(h * max_width / w)\n        else:\n            max_width = max_width or w\n            max_height = max_height or h\n\n        if max_width and max_height:\n            max_pixels = max_width * max_height\n\n        scale = np.sqrt(max_pixels / (w * h)) if max_pixels &gt; 0 else scale or 1.0\n        max_width = int(w * scale)\n        max_height = int(h * scale)\n        if resize_to_multiple_of:\n            max_width = (max_width // resize_to_multiple_of) * resize_to_multiple_of\n            max_height = (max_height // resize_to_multiple_of) * resize_to_multiple_of\n\n        if scale &lt; 1.0 or w &gt; max_width or h &gt; max_height:\n            image = image.resize((max_width, max_height), resample=resample)  # type: ignore\n        return image\n\n    @staticmethod\n    def load_image_as_ndarray(\n        image_or_uri: Union[str, Path, Image.Image],\n    ) -&gt; np.ndarray:\n        \"\"\"Load image from file or URI.\"\"\"\n        return np.asarray(GUTILs.load_image(image_or_uri))\n\n    @staticmethod\n    def load_image(\n        image_or_uri: Union[str, Path, Image.Image],\n        max_width: Optional[int] = None,\n        max_height: Optional[int] = None,\n        max_pixels: Optional[int] = None,\n        scale: float = 1.0,\n        resize_to_multiple_of: Optional[int] = None,\n        crop_box: Optional[Tuple[int, int, int, int]] = None,\n        mode: str = \"RGB\",\n        **read_kwargs,\n    ) -&gt; Image.Image:\n        \"\"\"Load image from file or URI.\"\"\"\n        from PIL import Image\n\n        if isinstance(image_or_uri, Image.Image):\n            img = image_or_uri.convert(mode)\n        elif Path(image_or_uri).is_file():\n            img = Image.open(image_or_uri).convert(mode)\n        else:\n            img = Image.open(\n                io.BytesIO(IOLIBs.read(image_or_uri, **read_kwargs))\n            ).convert(mode)\n        img = GUTILs.scale_image(\n            img,\n            max_width=max_width,\n            max_height=max_height,\n            max_pixels=max_pixels,\n            scale=scale,\n            resize_to_multiple_of=resize_to_multiple_of,\n        )\n        if crop_box is not None:\n            img = img.crop(crop_box)\n        return img\n\n    @staticmethod\n    def load_images(\n        images_or_uris: List[Union[str, Image.Image]],\n        max_width: Optional[int] = None,\n        max_height: Optional[int] = None,\n        max_pixels: Optional[int] = None,\n        scale: float = 1.0,\n        resize_to_multiple_of: Optional[int] = None,\n        crop_to_min_size: bool = False,\n        mode: str = \"RGB\",\n        **kwargs,\n    ) -&gt; List[Image.Image]:\n        \"\"\"Load images from files or URIs.\"\"\"\n        imgs = [\n            GUTILs.load_image(\n                image_or_uri,\n                max_width=max_width,\n                max_height=max_height,\n                max_pixels=max_pixels,\n                scale=scale,\n                resize_to_multiple_of=resize_to_multiple_of,\n                mode=mode,\n                **kwargs,\n            )\n            for image_or_uri in images_or_uris\n        ]\n        if crop_to_min_size:\n            min_width = min(img.width for img in imgs)\n            min_height = min(img.height for img in imgs)\n            if resize_to_multiple_of is not None:\n                min_width = (min_width // resize_to_multiple_of) * resize_to_multiple_of\n                min_height = (\n                    min_height // resize_to_multiple_of\n                ) * resize_to_multiple_of\n            imgs = [img.crop((0, 0, min_width, min_height)) for img in imgs]\n\n        return imgs\n\n    @staticmethod\n    def get_image_font(\n        fontname: Optional[str] = None,\n        fontsize: int = 12,\n    ) -&gt; Optional[ImageFont.ImageFont]:\n        \"\"\"Get font for PIL image.\"\"\"\n        fontname, fontpath = GUTILs.get_plot_font(\n            fontname=fontname,\n            set_font_for_matplot=False,\n        )\n        return ImageFont.truetype(fontpath, fontsize) if fontpath else None\n\n    @staticmethod\n    def get_default_system_font(\n        fontname: Optional[str] = None,\n        fontpath: Optional[str] = None,\n        lang: str = \"ko\",\n        verbose: bool = False,\n    ) -&gt; Tuple[str, str]:\n        if platform.system() == \"Darwin\":\n            default_fontname = \"AppleGothic.ttf\" if lang == \"ko\" else \"Arial.ttf\"\n            fontname = fontname or default_fontname\n            fontpath = os.path.join(\"/System/Library/Fonts/Supplemental/\", fontname)\n        elif platform.system() == \"Windows\":\n            default_fontname = \"malgun.ttf\" if lang == \"ko\" else \"arial.ttf\"\n            fontname = fontname or default_fontname\n            fontpath = os.path.join(\"c:/Windows/Fonts/\", fontname)\n        elif platform.system() == \"Linux\":\n            default_fontname = \"NanumGothic.ttf\" if lang == \"ko\" else \"DejaVuSans.ttf\"\n            fontname = fontname or default_fontname\n            if fontname.lower().startswith(\"nanum\"):\n                fontpath = os.path.join(\"/usr/share/fonts/truetype/nanum/\", fontname)\n            else:\n                fontpath = os.path.join(\"/usr/share/fonts/truetype/\", fontname)\n        if fontpath and not Path(fontpath).is_file():\n            paths = GUTILs.find_font_file(fontname)\n            fontpath = paths[0] if len(paths) &gt; 0 else \"\"\n        if verbose:\n            logger.info(f\"Font path: {fontpath}\")\n        return fontname, fontpath\n\n    @staticmethod\n    def get_plot_font(\n        fontpath: Optional[str] = None,\n        fontname: Optional[str] = None,\n        lang: str = \"en\",\n        set_font_for_matplot: bool = True,\n        verbose: bool = False,\n    ) -&gt; Tuple[str, str]:\n        \"\"\"Get font for plot\n\n        Args:\n            fontpath: Font file path\n            fontname: Font name\n            lang: Language\n            set_font_for_matplot: Set font for matplot\n            verbose: Verbose mode\n\n        Returns:\n            Tuple of font name and font path\n\n        \"\"\"\n        if fontname and not fontname.endswith(\".ttf\"):\n            fontname += \".ttf\"\n        if not fontpath:\n            fontname, fontpath = GUTILs.get_default_system_font(\n                fontname, fontpath, lang, verbose\n            )\n\n        if fontpath and Path(fontpath).is_file():\n            font_manager.fontManager.addfont(fontpath)\n            fontname = font_manager.FontProperties(fname=fontpath).get_name()  # type: ignore\n\n            if set_font_for_matplot and fontname:\n                rc(\"font\", family=fontname)\n                plt.rcParams[\"axes.unicode_minus\"] = False\n                if verbose:\n                    font_family = plt.rcParams[\"font.family\"]\n                    logger.info(f\"font family: {font_family}\")\n            if verbose:\n                logger.info(f\"font name: {fontname}\")\n        else:\n            logger.warning(f\"Font file does not exist at {fontpath}\")\n            fontname = \"\"\n            fontpath = \"\"\n            if platform.system() == \"Linux\":\n                font_install_help = \"\"\"\n                apt install fontconfig\n                apt install fonts-nanum\n                fc-list | grep -i nanum\n                \"\"\"\n                print(font_install_help)\n        return fontname, fontpath\n\n    @staticmethod\n    def find_font_file(query: str) -&gt; List[str]:\n        \"\"\"Find font file by query string\"\"\"\n        return list(\n            filter(\n                lambda path: query in os.path.basename(path),\n                font_manager.findSystemFonts(),\n            )\n        )\n\n    @staticmethod\n    def convert_figure_to_image(\n        fig: plt.Figure,\n        dpi: int = 300,\n    ):\n        \"\"\"Convert a Matplotlib figure to a PIL Image and return it\"\"\"\n        buf = io.BytesIO()\n        fig.savefig(buf, format=\"png\", dpi=dpi, bbox_inches=\"tight\", pad_inches=0)\n        buf.seek(0)\n        return Image.open(buf)\n\n    @staticmethod\n    def print_filename_on_image(\n        image_or_uri,\n        print_filename: bool = False,\n        filename: Optional[str] = None,\n        filename_offset: Tuple[float, float] = (5, 5),\n        fontname: Optional[str] = None,\n        fontsize: int = 12,\n        fontcolor: Optional[str] = None,\n    ) -&gt; Image.Image:\n        \"\"\"\n        Convert an image to a PIL Image.\n\n        Args:\n            image_or_uri: The image or image URI.\n            print_filename: Whether to print the filename on the image.\n            filename: The filename to show on the image.\n            filename_offset: The offset of the filename from the top left corner.\n            fontname: The font name to use for the filename.\n            fontsize: The font size to use for the filename.\n            fontcolor: The font color to use for the filename.\n\n        Returns:\n            The PIL Image.\n        \"\"\"\n        img = GUTILs.load_image(image_or_uri)\n        if isinstance(image_or_uri, str) and filename is None:\n            filename = os.path.basename(image_or_uri)\n        if print_filename and filename:\n            font = GUTILs.get_image_font(fontname, fontsize)\n            draw = ImageDraw.Draw(img)\n            draw.text(filename_offset, filename, font=font, fill=fontcolor)\n\n        # img = img.convert(\"RGB\")\n        # img = np.array(img)\n        return img\n\n    @staticmethod\n    def get_ticks_from_lim(\n        lim: Tuple[float, float],\n        num_ticks: int,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Get n evenly spaced ticks from lim.\n\n        Args:\n            lim: Tuple of (min, max) values.\n            num_ticks: Number of ticks to get.\n\n        Returns:\n            Array of ticks.\n        \"\"\"\n        ticks = np.linspace(lim[0], lim[1], num_ticks + 1)\n        ticks = ticks - (ticks[1] - ticks[0]) / 2\n        ticks[0] = lim[0]\n        return ticks\n\n    @staticmethod\n    def save_adjusted_subplots(\n        fig: plt.Figure,\n        output_file: str,\n        left: float = 0.1,\n        right: float = 0.9,\n        bottom: float = 0.1,\n        top: float = 0.9,\n        wspace: float = 0,\n        hspace: float = 0,\n        tight_layout: bool = True,\n        bbox_inches: str = \"tight\",\n        pad_inches: float = 0,\n        transparent: bool = True,\n        dpi: int = 300,\n        verbose: bool = True,\n    ):\n        \"\"\"Save subplots after adjusting the figure\n\n        Args:\n            fig: Figure\n            output_file: Output file path\n            left: Left\n            right: Right\n            bottom: Bottom\n            top: Top\n            wspace: Wspace\n            hspace: Hspace\n            tight_layout: Tight layout\n            bbox_inches: Bbox inches\n            pad_inches: Pad inches\n            transparent: Transparent\n            dpi: DPI\n            verbose: Verbose mode\n        \"\"\"\n\n        # make the figure look better\n        fig.subplots_adjust(\n            left=left,\n            right=right,\n            bottom=bottom,\n            top=top,\n            wspace=wspace,\n            hspace=hspace,\n        )\n        if tight_layout:\n            fig.tight_layout()\n\n        Path(output_file).parent.mkdir(parents=True, exist_ok=True)\n        fig.savefig(\n            output_file,\n            dpi=dpi,\n            bbox_inches=bbox_inches,\n            pad_inches=pad_inches,\n            transparent=transparent,\n        )\n        if verbose:\n            logger.info(\"Saved subplots to %s\", output_file)\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.GUTILs.convert_figure_to_image","title":"<code>convert_figure_to_image(fig, dpi=300)</code>  <code>staticmethod</code>","text":"<p>Convert a Matplotlib figure to a PIL Image and return it</p> Source code in <code>hyfi/graphics/utils.py</code> <pre><code>@staticmethod\ndef convert_figure_to_image(\n    fig: plt.Figure,\n    dpi: int = 300,\n):\n    \"\"\"Convert a Matplotlib figure to a PIL Image and return it\"\"\"\n    buf = io.BytesIO()\n    fig.savefig(buf, format=\"png\", dpi=dpi, bbox_inches=\"tight\", pad_inches=0)\n    buf.seek(0)\n    return Image.open(buf)\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.GUTILs.find_font_file","title":"<code>find_font_file(query)</code>  <code>staticmethod</code>","text":"<p>Find font file by query string</p> Source code in <code>hyfi/graphics/utils.py</code> <pre><code>@staticmethod\ndef find_font_file(query: str) -&gt; List[str]:\n    \"\"\"Find font file by query string\"\"\"\n    return list(\n        filter(\n            lambda path: query in os.path.basename(path),\n            font_manager.findSystemFonts(),\n        )\n    )\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.GUTILs.get_grid_size","title":"<code>get_grid_size(num_images, num_cols=None, num_rows=None, truncate=True, fit_to_grid=True)</code>  <code>staticmethod</code>","text":"<p>Get number of rows and columns for a grid of images.</p> <p>Parameters:</p> Name Type Description Default <code>num_images</code> <code>int</code> <p>Number of images.</p> required <code>num_cols</code> <code>int</code> <p>Number of columns. Defaults to None.</p> <code>None</code> <code>num_rows</code> <code>int</code> <p>Number of rows. Defaults to None.</p> <code>None</code> <code>truncate</code> <code>bool</code> <p>Truncate number of images to fit grid. Defaults to True. If False, the number of images will be increased to fit the grid.</p> <code>True</code> <p>Returns:</p> Type Description <code>Tuple[int, int, int]</code> <p>Tuple[int, int, int]: Number of images, columns and rows.</p> Source code in <code>hyfi/graphics/utils.py</code> <pre><code>@staticmethod\ndef get_grid_size(\n    num_images: int,\n    num_cols: Optional[int] = None,\n    num_rows: Optional[int] = None,\n    truncate: bool = True,\n    fit_to_grid: bool = True,\n) -&gt; Tuple[int, int, int]:\n    \"\"\"Get number of rows and columns for a grid of images.\n\n    Args:\n        num_images (int): Number of images.\n        num_cols (int, optional): Number of columns. Defaults to None.\n        num_rows (int, optional): Number of rows. Defaults to None.\n        truncate (bool, optional): Truncate number of images to fit grid. Defaults to True. If False, the number of images will be increased to fit the grid.\n\n    Returns:\n        Tuple[int, int, int]: Number of images, columns and rows.\n    \"\"\"\n    if not num_cols and num_images % num_cols != 0 and truncate:\n        num_images = (num_images // num_cols) * num_cols\n    if not num_cols or num_cols &gt; num_images or num_cols &lt; 1:\n        num_cols = num_images // 2\n    num_rows = num_images // num_cols\n\n    return num_images, num_cols, num_rows\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.GUTILs.get_image_font","title":"<code>get_image_font(fontname=None, fontsize=12)</code>  <code>staticmethod</code>","text":"<p>Get font for PIL image.</p> Source code in <code>hyfi/graphics/utils.py</code> <pre><code>@staticmethod\ndef get_image_font(\n    fontname: Optional[str] = None,\n    fontsize: int = 12,\n) -&gt; Optional[ImageFont.ImageFont]:\n    \"\"\"Get font for PIL image.\"\"\"\n    fontname, fontpath = GUTILs.get_plot_font(\n        fontname=fontname,\n        set_font_for_matplot=False,\n    )\n    return ImageFont.truetype(fontpath, fontsize) if fontpath else None\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.GUTILs.get_plot_font","title":"<code>get_plot_font(fontpath=None, fontname=None, lang='en', set_font_for_matplot=True, verbose=False)</code>  <code>staticmethod</code>","text":"<p>Get font for plot</p> <p>Parameters:</p> Name Type Description Default <code>fontpath</code> <code>Optional[str]</code> <p>Font file path</p> <code>None</code> <code>fontname</code> <code>Optional[str]</code> <p>Font name</p> <code>None</code> <code>lang</code> <code>str</code> <p>Language</p> <code>'en'</code> <code>set_font_for_matplot</code> <code>bool</code> <p>Set font for matplot</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Verbose mode</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>Tuple of font name and font path</p> Source code in <code>hyfi/graphics/utils.py</code> <pre><code>@staticmethod\ndef get_plot_font(\n    fontpath: Optional[str] = None,\n    fontname: Optional[str] = None,\n    lang: str = \"en\",\n    set_font_for_matplot: bool = True,\n    verbose: bool = False,\n) -&gt; Tuple[str, str]:\n    \"\"\"Get font for plot\n\n    Args:\n        fontpath: Font file path\n        fontname: Font name\n        lang: Language\n        set_font_for_matplot: Set font for matplot\n        verbose: Verbose mode\n\n    Returns:\n        Tuple of font name and font path\n\n    \"\"\"\n    if fontname and not fontname.endswith(\".ttf\"):\n        fontname += \".ttf\"\n    if not fontpath:\n        fontname, fontpath = GUTILs.get_default_system_font(\n            fontname, fontpath, lang, verbose\n        )\n\n    if fontpath and Path(fontpath).is_file():\n        font_manager.fontManager.addfont(fontpath)\n        fontname = font_manager.FontProperties(fname=fontpath).get_name()  # type: ignore\n\n        if set_font_for_matplot and fontname:\n            rc(\"font\", family=fontname)\n            plt.rcParams[\"axes.unicode_minus\"] = False\n            if verbose:\n                font_family = plt.rcParams[\"font.family\"]\n                logger.info(f\"font family: {font_family}\")\n        if verbose:\n            logger.info(f\"font name: {fontname}\")\n    else:\n        logger.warning(f\"Font file does not exist at {fontpath}\")\n        fontname = \"\"\n        fontpath = \"\"\n        if platform.system() == \"Linux\":\n            font_install_help = \"\"\"\n            apt install fontconfig\n            apt install fonts-nanum\n            fc-list | grep -i nanum\n            \"\"\"\n            print(font_install_help)\n    return fontname, fontpath\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.GUTILs.get_ticks_from_lim","title":"<code>get_ticks_from_lim(lim, num_ticks)</code>  <code>staticmethod</code>","text":"<p>Get n evenly spaced ticks from lim.</p> <p>Parameters:</p> Name Type Description Default <code>lim</code> <code>Tuple[float, float]</code> <p>Tuple of (min, max) values.</p> required <code>num_ticks</code> <code>int</code> <p>Number of ticks to get.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of ticks.</p> Source code in <code>hyfi/graphics/utils.py</code> <pre><code>@staticmethod\ndef get_ticks_from_lim(\n    lim: Tuple[float, float],\n    num_ticks: int,\n) -&gt; np.ndarray:\n    \"\"\"\n    Get n evenly spaced ticks from lim.\n\n    Args:\n        lim: Tuple of (min, max) values.\n        num_ticks: Number of ticks to get.\n\n    Returns:\n        Array of ticks.\n    \"\"\"\n    ticks = np.linspace(lim[0], lim[1], num_ticks + 1)\n    ticks = ticks - (ticks[1] - ticks[0]) / 2\n    ticks[0] = lim[0]\n    return ticks\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.GUTILs.load_image","title":"<code>load_image(image_or_uri, max_width=None, max_height=None, max_pixels=None, scale=1.0, resize_to_multiple_of=None, crop_box=None, mode='RGB', **read_kwargs)</code>  <code>staticmethod</code>","text":"<p>Load image from file or URI.</p> Source code in <code>hyfi/graphics/utils.py</code> <pre><code>@staticmethod\ndef load_image(\n    image_or_uri: Union[str, Path, Image.Image],\n    max_width: Optional[int] = None,\n    max_height: Optional[int] = None,\n    max_pixels: Optional[int] = None,\n    scale: float = 1.0,\n    resize_to_multiple_of: Optional[int] = None,\n    crop_box: Optional[Tuple[int, int, int, int]] = None,\n    mode: str = \"RGB\",\n    **read_kwargs,\n) -&gt; Image.Image:\n    \"\"\"Load image from file or URI.\"\"\"\n    from PIL import Image\n\n    if isinstance(image_or_uri, Image.Image):\n        img = image_or_uri.convert(mode)\n    elif Path(image_or_uri).is_file():\n        img = Image.open(image_or_uri).convert(mode)\n    else:\n        img = Image.open(\n            io.BytesIO(IOLIBs.read(image_or_uri, **read_kwargs))\n        ).convert(mode)\n    img = GUTILs.scale_image(\n        img,\n        max_width=max_width,\n        max_height=max_height,\n        max_pixels=max_pixels,\n        scale=scale,\n        resize_to_multiple_of=resize_to_multiple_of,\n    )\n    if crop_box is not None:\n        img = img.crop(crop_box)\n    return img\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.GUTILs.load_image_as_ndarray","title":"<code>load_image_as_ndarray(image_or_uri)</code>  <code>staticmethod</code>","text":"<p>Load image from file or URI.</p> Source code in <code>hyfi/graphics/utils.py</code> <pre><code>@staticmethod\ndef load_image_as_ndarray(\n    image_or_uri: Union[str, Path, Image.Image],\n) -&gt; np.ndarray:\n    \"\"\"Load image from file or URI.\"\"\"\n    return np.asarray(GUTILs.load_image(image_or_uri))\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.GUTILs.load_images","title":"<code>load_images(images_or_uris, max_width=None, max_height=None, max_pixels=None, scale=1.0, resize_to_multiple_of=None, crop_to_min_size=False, mode='RGB', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Load images from files or URIs.</p> Source code in <code>hyfi/graphics/utils.py</code> <pre><code>@staticmethod\ndef load_images(\n    images_or_uris: List[Union[str, Image.Image]],\n    max_width: Optional[int] = None,\n    max_height: Optional[int] = None,\n    max_pixels: Optional[int] = None,\n    scale: float = 1.0,\n    resize_to_multiple_of: Optional[int] = None,\n    crop_to_min_size: bool = False,\n    mode: str = \"RGB\",\n    **kwargs,\n) -&gt; List[Image.Image]:\n    \"\"\"Load images from files or URIs.\"\"\"\n    imgs = [\n        GUTILs.load_image(\n            image_or_uri,\n            max_width=max_width,\n            max_height=max_height,\n            max_pixels=max_pixels,\n            scale=scale,\n            resize_to_multiple_of=resize_to_multiple_of,\n            mode=mode,\n            **kwargs,\n        )\n        for image_or_uri in images_or_uris\n    ]\n    if crop_to_min_size:\n        min_width = min(img.width for img in imgs)\n        min_height = min(img.height for img in imgs)\n        if resize_to_multiple_of is not None:\n            min_width = (min_width // resize_to_multiple_of) * resize_to_multiple_of\n            min_height = (\n                min_height // resize_to_multiple_of\n            ) * resize_to_multiple_of\n        imgs = [img.crop((0, 0, min_width, min_height)) for img in imgs]\n\n    return imgs\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.GUTILs.print_filename_on_image","title":"<code>print_filename_on_image(image_or_uri, print_filename=False, filename=None, filename_offset=(5, 5), fontname=None, fontsize=12, fontcolor=None)</code>  <code>staticmethod</code>","text":"<p>Convert an image to a PIL Image.</p> <p>Parameters:</p> Name Type Description Default <code>image_or_uri</code> <p>The image or image URI.</p> required <code>print_filename</code> <code>bool</code> <p>Whether to print the filename on the image.</p> <code>False</code> <code>filename</code> <code>Optional[str]</code> <p>The filename to show on the image.</p> <code>None</code> <code>filename_offset</code> <code>Tuple[float, float]</code> <p>The offset of the filename from the top left corner.</p> <code>(5, 5)</code> <code>fontname</code> <code>Optional[str]</code> <p>The font name to use for the filename.</p> <code>None</code> <code>fontsize</code> <code>int</code> <p>The font size to use for the filename.</p> <code>12</code> <code>fontcolor</code> <code>Optional[str]</code> <p>The font color to use for the filename.</p> <code>None</code> <p>Returns:</p> Type Description <code>Image</code> <p>The PIL Image.</p> Source code in <code>hyfi/graphics/utils.py</code> <pre><code>@staticmethod\ndef print_filename_on_image(\n    image_or_uri,\n    print_filename: bool = False,\n    filename: Optional[str] = None,\n    filename_offset: Tuple[float, float] = (5, 5),\n    fontname: Optional[str] = None,\n    fontsize: int = 12,\n    fontcolor: Optional[str] = None,\n) -&gt; Image.Image:\n    \"\"\"\n    Convert an image to a PIL Image.\n\n    Args:\n        image_or_uri: The image or image URI.\n        print_filename: Whether to print the filename on the image.\n        filename: The filename to show on the image.\n        filename_offset: The offset of the filename from the top left corner.\n        fontname: The font name to use for the filename.\n        fontsize: The font size to use for the filename.\n        fontcolor: The font color to use for the filename.\n\n    Returns:\n        The PIL Image.\n    \"\"\"\n    img = GUTILs.load_image(image_or_uri)\n    if isinstance(image_or_uri, str) and filename is None:\n        filename = os.path.basename(image_or_uri)\n    if print_filename and filename:\n        font = GUTILs.get_image_font(fontname, fontsize)\n        draw = ImageDraw.Draw(img)\n        draw.text(filename_offset, filename, font=font, fill=fontcolor)\n\n    # img = img.convert(\"RGB\")\n    # img = np.array(img)\n    return img\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.GUTILs.save_adjusted_subplots","title":"<code>save_adjusted_subplots(fig, output_file, left=0.1, right=0.9, bottom=0.1, top=0.9, wspace=0, hspace=0, tight_layout=True, bbox_inches='tight', pad_inches=0, transparent=True, dpi=300, verbose=True)</code>  <code>staticmethod</code>","text":"<p>Save subplots after adjusting the figure</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figure</p> required <code>output_file</code> <code>str</code> <p>Output file path</p> required <code>left</code> <code>float</code> <p>Left</p> <code>0.1</code> <code>right</code> <code>float</code> <p>Right</p> <code>0.9</code> <code>bottom</code> <code>float</code> <p>Bottom</p> <code>0.1</code> <code>top</code> <code>float</code> <p>Top</p> <code>0.9</code> <code>wspace</code> <code>float</code> <p>Wspace</p> <code>0</code> <code>hspace</code> <code>float</code> <p>Hspace</p> <code>0</code> <code>tight_layout</code> <code>bool</code> <p>Tight layout</p> <code>True</code> <code>bbox_inches</code> <code>str</code> <p>Bbox inches</p> <code>'tight'</code> <code>pad_inches</code> <code>float</code> <p>Pad inches</p> <code>0</code> <code>transparent</code> <code>bool</code> <p>Transparent</p> <code>True</code> <code>dpi</code> <code>int</code> <p>DPI</p> <code>300</code> <code>verbose</code> <code>bool</code> <p>Verbose mode</p> <code>True</code> Source code in <code>hyfi/graphics/utils.py</code> <pre><code>@staticmethod\ndef save_adjusted_subplots(\n    fig: plt.Figure,\n    output_file: str,\n    left: float = 0.1,\n    right: float = 0.9,\n    bottom: float = 0.1,\n    top: float = 0.9,\n    wspace: float = 0,\n    hspace: float = 0,\n    tight_layout: bool = True,\n    bbox_inches: str = \"tight\",\n    pad_inches: float = 0,\n    transparent: bool = True,\n    dpi: int = 300,\n    verbose: bool = True,\n):\n    \"\"\"Save subplots after adjusting the figure\n\n    Args:\n        fig: Figure\n        output_file: Output file path\n        left: Left\n        right: Right\n        bottom: Bottom\n        top: Top\n        wspace: Wspace\n        hspace: Hspace\n        tight_layout: Tight layout\n        bbox_inches: Bbox inches\n        pad_inches: Pad inches\n        transparent: Transparent\n        dpi: DPI\n        verbose: Verbose mode\n    \"\"\"\n\n    # make the figure look better\n    fig.subplots_adjust(\n        left=left,\n        right=right,\n        bottom=bottom,\n        top=top,\n        wspace=wspace,\n        hspace=hspace,\n    )\n    if tight_layout:\n        fig.tight_layout()\n\n    Path(output_file).parent.mkdir(parents=True, exist_ok=True)\n    fig.savefig(\n        output_file,\n        dpi=dpi,\n        bbox_inches=bbox_inches,\n        pad_inches=pad_inches,\n        transparent=transparent,\n    )\n    if verbose:\n        logger.info(\"Saved subplots to %s\", output_file)\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.GUTILs.scale_image","title":"<code>scale_image(image, max_width=None, max_height=None, max_pixels=None, scale=1.0, resize_to_multiple_of=None, resample=Image.LANCZOS)</code>  <code>staticmethod</code>","text":"<p>Scale image to have at most <code>max_pixels</code> pixels.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>PIL image.</p> required <code>max_width</code> <code>Optional[int]</code> <p>Maximum width.</p> <code>None</code> <code>max_height</code> <code>Optional[int]</code> <p>Maximum height.</p> <code>None</code> <code>max_pixels</code> <code>Optional[int]</code> <p>Maximum number of pixels.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Scale factor.</p> <code>1.0</code> <code>resize_to_multiple_of</code> <code>Optional[int]</code> <p>Resize to multiple of this value.</p> <code>None</code> <code>resample</code> <code>int</code> <p>Resampling filter.</p> <code>LANCZOS</code> <p>Returns:</p> Type Description <code>Image</code> <p>PIL image.</p> Source code in <code>hyfi/graphics/utils.py</code> <pre><code>@staticmethod\ndef scale_image(\n    image: Image.Image,\n    max_width: Optional[int] = None,\n    max_height: Optional[int] = None,\n    max_pixels: Optional[int] = None,\n    scale: float = 1.0,\n    resize_to_multiple_of: Optional[int] = None,\n    resample: int = Image.LANCZOS,\n) -&gt; Image.Image:\n    \"\"\"Scale image to have at most `max_pixels` pixels.\n\n    Args:\n        image: PIL image.\n        max_width: Maximum width.\n        max_height: Maximum height.\n        max_pixels: Maximum number of pixels.\n        scale: Scale factor.\n        resize_to_multiple_of: Resize to multiple of this value.\n        resample: Resampling filter.\n\n    Returns:\n        PIL image.\n    \"\"\"\n\n    w, h = image.size\n\n    if not max_width and max_height:\n        max_width = int(w * max_height / h)\n    elif not max_height and max_width:\n        max_height = int(h * max_width / w)\n    else:\n        max_width = max_width or w\n        max_height = max_height or h\n\n    if max_width and max_height:\n        max_pixels = max_width * max_height\n\n    scale = np.sqrt(max_pixels / (w * h)) if max_pixels &gt; 0 else scale or 1.0\n    max_width = int(w * scale)\n    max_height = int(h * scale)\n    if resize_to_multiple_of:\n        max_width = (max_width // resize_to_multiple_of) * resize_to_multiple_of\n        max_height = (max_height // resize_to_multiple_of) * resize_to_multiple_of\n\n    if scale &lt; 1.0 or w &gt; max_width or h &gt; max_height:\n        image = image.resize((max_width, max_height), resample=resample)  # type: ignore\n    return image\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.MOTION","title":"<code>MOTION</code>","text":"Source code in <code>hyfi/graphics/motion.py</code> <pre><code>class MOTION:\n    @staticmethod\n    def make_gif(\n        image_filepaths=None,\n        filename_patterns: Optional[str] = None,\n        base_dir: Optional[str] = None,\n        output_file: Optional[str] = None,\n        duration: int = 100,\n        loop: int = 0,\n        width: int = 0,\n        optimize: bool = True,\n        quality: int = 50,\n        display_to_notebook: bool = False,\n        force: bool = False,\n        **kwargs,\n    ) -&gt; Optional[str]:\n        \"\"\"\n        Create a GIF from a list of images or a list of filenames.\n        \"\"\"\n        output_file = output_file or \"\"\n        if os.path.exists(output_file) and not force:\n            logger.info(\"Skipping GIF creation, already exists: %s\", output_file)\n            logger.info(\"If you want to re-create the GIF, set force=True\")\n        else:\n            if image_filepaths is None and filename_patterns:\n                image_filepaths = sorted(\n                    IOLIBs.get_filepaths(filename_patterns, base_dir=base_dir)\n                )\n            if not image_filepaths:\n                logger.warning(\"no images found\")\n                return\n            if frames := GUTILs.load_images(image_filepaths):\n                frame_one = frames[0]\n                frame_one.save(\n                    output_file,\n                    format=\"GIF\",\n                    append_images=frames,\n                    save_all=True,\n                    duration=duration,\n                    loop=loop,\n                    optimize=optimize,\n                    quality=quality,\n                )\n                logger.info(\"Saved GIF to %s\", output_file)\n            else:\n                logger.warning(\"No frames found for %s\", filename_patterns)\n\n        if display_to_notebook and os.path.exists(output_file):\n            NBs.display_image(data=IOLIBs.read(output_file), width=width)\n\n        return output_file\n\n    @staticmethod\n    def extract_frames(\n        input_video_file: str,\n        every_nth_frame: int,\n        ouput_dir: str,\n        frame_filename_pattern: str = \"%04d.jpg\",\n        ffmpeg_path: str = \"/usr/bin/ffmpeg\",\n    ):\n        \"\"\"\n        Extract frames from a video.\n\n        Args:\n            input_video_file (str): Path to the video.\n            every_nth_frame (int): Extract every nth frame.\n            ouput_dir (str): Path to the output directory.\n            frame_filename_pattern (str, optional): Frame filename pattern. Defaults to \"%04d.jpg\".\n        \"\"\"\n        logger.info(\n            \"Exporting Video Frames (every %sth frame) to %s\",\n            every_nth_frame,\n            ouput_dir,\n        )\n        try:\n            for f in Path(f\"{ouput_dir}\").glob(\"*.jpg\"):\n                f.unlink()\n        except FileNotFoundError:\n            logger.info(\"No video frames found in %s\", ouput_dir)\n        vf = f\"select=not(mod(n\\\\,{every_nth_frame}))\"\n\n        if not os.path.exists(ffmpeg_path):\n            ffmpeg_path = \"ffmpeg\"\n        if os.path.exists(input_video_file):\n            subprocess.run(\n                [\n                    ffmpeg_path,\n                    \"-i\",\n                    f\"{input_video_file}\",\n                    \"-vf\",\n                    f\"{vf}\",\n                    \"-vsync\",\n                    \"vfr\",\n                    \"-q:v\",\n                    \"2\",\n                    \"-loglevel\",\n                    \"error\",\n                    \"-stats\",\n                    f\"{ouput_dir}/{frame_filename_pattern}\",\n                ],\n                stdout=subprocess.PIPE,\n            ).stdout.decode(\"utf-8\")\n        else:\n            logger.warning(\n                \"WARNING!\\n\\nVideo not found: %s.\\nPlease check your video path.\",\n                input_video_file,\n            )\n\n    @staticmethod\n    def create_video(\n        input_image_dir: str,\n        video_output_file: str,\n        input_url: str,\n        fps: int,\n        start_number: int,\n        vframes: int,\n        force: bool = False,\n    ) -&gt; Optional[str]:\n        \"\"\"\n        Create a video from a list of images.\n\n        Args:\n            input_image_dir (str): Base directory.\n            video_path (str): Path to the video.\n            input_url (str): Input URL.\n            fps (int): Frames per second.\n            start_number (int): Start number.\n            vframes (int): Number of frames.\n            force (bool, optional): Force video creation. Defaults to False.\n\n        Raises:\n            FileNotFoundError: If the video is not found.\n\n        \"\"\"\n\n        logger.info(\"Creating video from %s\", input_url)\n        if os.path.exists(video_output_file) and not force:\n            logger.info(\n                \"Skipping video creation, already exists: %s\", video_output_file\n            )\n            logger.info(\"If you want to re-create the video, set force=True\")\n            return video_output_file\n\n        cmd = [\n            \"ffmpeg\",\n            \"-y\",\n            \"-vcodec\",\n            \"png\",\n            \"-r\",\n            str(fps),\n            \"-start_number\",\n            str(start_number),\n            \"-i\",\n            input_url,\n            \"-frames:v\",\n            str(vframes),\n            \"-c:v\",\n            \"libx264\",\n            \"-vf\",\n            f\"fps={fps}\",\n            \"-pix_fmt\",\n            \"yuv420p\",\n            \"-crf\",\n            \"17\",\n            \"-preset\",\n            \"veryslow\",\n            video_output_file,\n        ]\n\n        process = subprocess.Popen(\n            cmd,\n            cwd=f\"{input_image_dir}\",\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n        _, stderr = process.communicate()\n        if process.returncode != 0:\n            logger.error(stderr)\n            raise RuntimeError(stderr)\n        else:\n            logger.info(\"Video created successfully and saved to %s\", video_output_file)\n\n        return video_output_file\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.MOTION.create_video","title":"<code>create_video(input_image_dir, video_output_file, input_url, fps, start_number, vframes, force=False)</code>  <code>staticmethod</code>","text":"<p>Create a video from a list of images.</p> <p>Parameters:</p> Name Type Description Default <code>input_image_dir</code> <code>str</code> <p>Base directory.</p> required <code>video_path</code> <code>str</code> <p>Path to the video.</p> required <code>input_url</code> <code>str</code> <p>Input URL.</p> required <code>fps</code> <code>int</code> <p>Frames per second.</p> required <code>start_number</code> <code>int</code> <p>Start number.</p> required <code>vframes</code> <code>int</code> <p>Number of frames.</p> required <code>force</code> <code>bool</code> <p>Force video creation. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the video is not found.</p> Source code in <code>hyfi/graphics/motion.py</code> <pre><code>@staticmethod\ndef create_video(\n    input_image_dir: str,\n    video_output_file: str,\n    input_url: str,\n    fps: int,\n    start_number: int,\n    vframes: int,\n    force: bool = False,\n) -&gt; Optional[str]:\n    \"\"\"\n    Create a video from a list of images.\n\n    Args:\n        input_image_dir (str): Base directory.\n        video_path (str): Path to the video.\n        input_url (str): Input URL.\n        fps (int): Frames per second.\n        start_number (int): Start number.\n        vframes (int): Number of frames.\n        force (bool, optional): Force video creation. Defaults to False.\n\n    Raises:\n        FileNotFoundError: If the video is not found.\n\n    \"\"\"\n\n    logger.info(\"Creating video from %s\", input_url)\n    if os.path.exists(video_output_file) and not force:\n        logger.info(\n            \"Skipping video creation, already exists: %s\", video_output_file\n        )\n        logger.info(\"If you want to re-create the video, set force=True\")\n        return video_output_file\n\n    cmd = [\n        \"ffmpeg\",\n        \"-y\",\n        \"-vcodec\",\n        \"png\",\n        \"-r\",\n        str(fps),\n        \"-start_number\",\n        str(start_number),\n        \"-i\",\n        input_url,\n        \"-frames:v\",\n        str(vframes),\n        \"-c:v\",\n        \"libx264\",\n        \"-vf\",\n        f\"fps={fps}\",\n        \"-pix_fmt\",\n        \"yuv420p\",\n        \"-crf\",\n        \"17\",\n        \"-preset\",\n        \"veryslow\",\n        video_output_file,\n    ]\n\n    process = subprocess.Popen(\n        cmd,\n        cwd=f\"{input_image_dir}\",\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n    )\n    _, stderr = process.communicate()\n    if process.returncode != 0:\n        logger.error(stderr)\n        raise RuntimeError(stderr)\n    else:\n        logger.info(\"Video created successfully and saved to %s\", video_output_file)\n\n    return video_output_file\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.MOTION.extract_frames","title":"<code>extract_frames(input_video_file, every_nth_frame, ouput_dir, frame_filename_pattern='%04d.jpg', ffmpeg_path='/usr/bin/ffmpeg')</code>  <code>staticmethod</code>","text":"<p>Extract frames from a video.</p> <p>Parameters:</p> Name Type Description Default <code>input_video_file</code> <code>str</code> <p>Path to the video.</p> required <code>every_nth_frame</code> <code>int</code> <p>Extract every nth frame.</p> required <code>ouput_dir</code> <code>str</code> <p>Path to the output directory.</p> required <code>frame_filename_pattern</code> <code>str</code> <p>Frame filename pattern. Defaults to \"%04d.jpg\".</p> <code>'%04d.jpg'</code> Source code in <code>hyfi/graphics/motion.py</code> <pre><code>@staticmethod\ndef extract_frames(\n    input_video_file: str,\n    every_nth_frame: int,\n    ouput_dir: str,\n    frame_filename_pattern: str = \"%04d.jpg\",\n    ffmpeg_path: str = \"/usr/bin/ffmpeg\",\n):\n    \"\"\"\n    Extract frames from a video.\n\n    Args:\n        input_video_file (str): Path to the video.\n        every_nth_frame (int): Extract every nth frame.\n        ouput_dir (str): Path to the output directory.\n        frame_filename_pattern (str, optional): Frame filename pattern. Defaults to \"%04d.jpg\".\n    \"\"\"\n    logger.info(\n        \"Exporting Video Frames (every %sth frame) to %s\",\n        every_nth_frame,\n        ouput_dir,\n    )\n    try:\n        for f in Path(f\"{ouput_dir}\").glob(\"*.jpg\"):\n            f.unlink()\n    except FileNotFoundError:\n        logger.info(\"No video frames found in %s\", ouput_dir)\n    vf = f\"select=not(mod(n\\\\,{every_nth_frame}))\"\n\n    if not os.path.exists(ffmpeg_path):\n        ffmpeg_path = \"ffmpeg\"\n    if os.path.exists(input_video_file):\n        subprocess.run(\n            [\n                ffmpeg_path,\n                \"-i\",\n                f\"{input_video_file}\",\n                \"-vf\",\n                f\"{vf}\",\n                \"-vsync\",\n                \"vfr\",\n                \"-q:v\",\n                \"2\",\n                \"-loglevel\",\n                \"error\",\n                \"-stats\",\n                f\"{ouput_dir}/{frame_filename_pattern}\",\n            ],\n            stdout=subprocess.PIPE,\n        ).stdout.decode(\"utf-8\")\n    else:\n        logger.warning(\n            \"WARNING!\\n\\nVideo not found: %s.\\nPlease check your video path.\",\n            input_video_file,\n        )\n</code></pre>"},{"location":"reference/graphics/#hyfi.graphics.MOTION.make_gif","title":"<code>make_gif(image_filepaths=None, filename_patterns=None, base_dir=None, output_file=None, duration=100, loop=0, width=0, optimize=True, quality=50, display_to_notebook=False, force=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a GIF from a list of images or a list of filenames.</p> Source code in <code>hyfi/graphics/motion.py</code> <pre><code>@staticmethod\ndef make_gif(\n    image_filepaths=None,\n    filename_patterns: Optional[str] = None,\n    base_dir: Optional[str] = None,\n    output_file: Optional[str] = None,\n    duration: int = 100,\n    loop: int = 0,\n    width: int = 0,\n    optimize: bool = True,\n    quality: int = 50,\n    display_to_notebook: bool = False,\n    force: bool = False,\n    **kwargs,\n) -&gt; Optional[str]:\n    \"\"\"\n    Create a GIF from a list of images or a list of filenames.\n    \"\"\"\n    output_file = output_file or \"\"\n    if os.path.exists(output_file) and not force:\n        logger.info(\"Skipping GIF creation, already exists: %s\", output_file)\n        logger.info(\"If you want to re-create the GIF, set force=True\")\n    else:\n        if image_filepaths is None and filename_patterns:\n            image_filepaths = sorted(\n                IOLIBs.get_filepaths(filename_patterns, base_dir=base_dir)\n            )\n        if not image_filepaths:\n            logger.warning(\"no images found\")\n            return\n        if frames := GUTILs.load_images(image_filepaths):\n            frame_one = frames[0]\n            frame_one.save(\n                output_file,\n                format=\"GIF\",\n                append_images=frames,\n                save_all=True,\n                duration=duration,\n                loop=loop,\n                optimize=optimize,\n                quality=quality,\n            )\n            logger.info(\"Saved GIF to %s\", output_file)\n        else:\n            logger.warning(\"No frames found for %s\", filename_patterns)\n\n    if display_to_notebook and os.path.exists(output_file):\n        NBs.display_image(data=IOLIBs.read(output_file), width=width)\n\n    return output_file\n</code></pre>"},{"location":"reference/joblib/","title":"<code>hyfi.joblib</code>","text":""},{"location":"reference/joblib/#hyfi.joblib.BATCHER","title":"<code>BATCHER</code>","text":"<p>A class to apply a function to a series or dataframe using joblib</p> Source code in <code>hyfi/joblib/joblib.py</code> <pre><code>class BATCHER:\n    \"\"\"\n    A class to apply a function to a series or dataframe using joblib\n    \"\"\"\n\n    @staticmethod\n    def apply(\n        func: Callable,\n        series: Union[pd.Series, pd.DataFrame, Sequence, Mapping],\n        description: Optional[str] = None,\n        use_batcher: bool = True,\n        minibatch_size: Optional[int] = None,\n        num_workers: Optional[int] = None,\n        **kwargs,\n    ):\n        batcher_instance = JobLib()._batcher_instance_\n        if use_batcher and batcher_instance is not None:\n            batcher_minibatch_size = batcher_instance.minibatch_size\n            if minibatch_size is None:\n                minibatch_size = batcher_minibatch_size\n            if num_workers is not None:\n                batcher_instance.procs = int(num_workers)\n            if batcher_instance.procs &gt; 1:\n                batcher_instance.minibatch_size = min(\n                    int(len(series) / batcher_instance.procs) + 1, minibatch_size\n                )\n                logger.info(\n                    f\"Using batcher with minibatch size: {batcher_instance.minibatch_size}\"\n                )\n                results = decorator_apply(\n                    func,\n                    batcher_instance,\n                    description=description,  # type: ignore\n                )(series)\n                if batcher_instance is not None:\n                    batcher_instance.minibatch_size = batcher_minibatch_size\n                return results\n\n        if batcher_instance is None:\n            logger.warning(\"batcher is not initialized\")\n        tqdm.pandas(desc=description)\n        return series.progress_apply(func)  # type: ignore\n</code></pre>"},{"location":"reference/joblib/#hyfi.joblib.JobLib","title":"<code>JobLib</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>JobLib Configuration</p> Source code in <code>hyfi/joblib/joblib.py</code> <pre><code>class JobLib(BaseConfig):\n    \"\"\"JobLib Configuration\"\"\"\n\n    _config_name_: str = \"__init__\"\n    _config_group_: str = \"/joblib\"\n\n    backend: str = \"joblib\"\n    initialize_backend: bool = False\n    minibatch_size: int = 1_000\n    num_workers: int = 1\n    num_gpus: int = 0\n\n    _initilized_: bool = PrivateAttr(False)\n    _batcher_instance_: Optional[Batcher] = PrivateAttr(None)\n\n    def initialize(self):\n        self.init_backend()\n\n    def init_backend(\n        self,\n    ):\n        \"\"\"Initialize the backend for joblib\"\"\"\n        if self.initialize_backend and not self._initilized_:\n            backend_handle = None\n            backend = self.backend\n\n            if backend == \"ray\":\n                import ray  # type: ignore\n\n                ray_cfg = {\"num_cpus\": self.num_workers}\n                logger.debug(f\"initializing ray with {ray_cfg}\")\n                ray.init(**ray_cfg)\n                backend_handle = ray\n\n            core.global_batcher = batcher.Batcher(\n                backend_handle=backend_handle,\n                backend=self.backend,\n                procs=self.num_workers,\n                minibatch_size=self.minibatch_size,\n                task_num_cpus=self.num_workers,\n                task_num_gpus=self.num_gpus,\n                verbose=self.verbose,\n            )\n            self._batcher_instance_ = core.global_batcher\n            logger.info(\"initialized batcher with %s\", core.global_batcher)\n        self._initilized_ = True\n\n    def stop_backend(self):\n        \"\"\"Stop the backend for joblib\"\"\"\n        backend = self.backend\n        if core.global_batcher:\n            logger.debug(\"stopping batcher\")\n            del core.global_batcher\n\n        logger.debug(\"stopping distributed framework\")\n        if self.initialize_backend and backend == \"ray\":\n            try:\n                import ray  # type: ignore\n\n                if ray.is_initialized():\n                    ray.shutdown()\n                    logger.debug(\"shutting down ray\")\n            except ImportError:\n                logger.warning(\"ray is not installed\")\n</code></pre>"},{"location":"reference/joblib/#hyfi.joblib.JobLib.init_backend","title":"<code>init_backend()</code>","text":"<p>Initialize the backend for joblib</p> Source code in <code>hyfi/joblib/joblib.py</code> <pre><code>def init_backend(\n    self,\n):\n    \"\"\"Initialize the backend for joblib\"\"\"\n    if self.initialize_backend and not self._initilized_:\n        backend_handle = None\n        backend = self.backend\n\n        if backend == \"ray\":\n            import ray  # type: ignore\n\n            ray_cfg = {\"num_cpus\": self.num_workers}\n            logger.debug(f\"initializing ray with {ray_cfg}\")\n            ray.init(**ray_cfg)\n            backend_handle = ray\n\n        core.global_batcher = batcher.Batcher(\n            backend_handle=backend_handle,\n            backend=self.backend,\n            procs=self.num_workers,\n            minibatch_size=self.minibatch_size,\n            task_num_cpus=self.num_workers,\n            task_num_gpus=self.num_gpus,\n            verbose=self.verbose,\n        )\n        self._batcher_instance_ = core.global_batcher\n        logger.info(\"initialized batcher with %s\", core.global_batcher)\n    self._initilized_ = True\n</code></pre>"},{"location":"reference/joblib/#hyfi.joblib.JobLib.stop_backend","title":"<code>stop_backend()</code>","text":"<p>Stop the backend for joblib</p> Source code in <code>hyfi/joblib/joblib.py</code> <pre><code>def stop_backend(self):\n    \"\"\"Stop the backend for joblib\"\"\"\n    backend = self.backend\n    if core.global_batcher:\n        logger.debug(\"stopping batcher\")\n        del core.global_batcher\n\n    logger.debug(\"stopping distributed framework\")\n    if self.initialize_backend and backend == \"ray\":\n        try:\n            import ray  # type: ignore\n\n            if ray.is_initialized():\n                ray.shutdown()\n                logger.debug(\"shutting down ray\")\n        except ImportError:\n            logger.warning(\"ray is not installed\")\n</code></pre>"},{"location":"reference/main/","title":"<code>hyfi.main</code>","text":"<p>This module serves as the entry point for the HyFI application.</p> <p>It imports the necessary classes and objects from the 'config' and 'main' modules, and defines the 'all' list to specify the public interface of this module.</p> <p>Classes: - GlobalConfig: Represents the global configuration for the HyFI application. - GlobalConfigResolver: Resolves the global configuration for the HyFI application. - HyFIConfig: Represents the configuration for the HyFI application. - HyFI: Represents the main class of the HyFI application.</p> <p>Objects: - global_config: An instance of the GlobalConfig class representing the global configuration.</p>"},{"location":"reference/main/#hyfi.main.GlobalConfig","title":"<code>GlobalConfig</code>","text":"<p>               Bases: <code>UTILs</code></p> <p>HyFI global config class.  This class is used to store the global configuration</p> Source code in <code>hyfi/main/config.py</code> <pre><code>class GlobalConfig(UTILs):\n    \"\"\"HyFI global config class.  This class is used to store the global configuration\"\"\"\n\n    __config__: Optional[HyFIConfig] = None\n\n    _about_: Optional[About] = None\n    _project_: Optional[Project] = None\n    _version_: str = PrivateAttr(global_hyfi.version)\n\n    def __init__(self, **config_kwargs):\n        if config_kwargs:\n            self.__config__ = HyFIConfig(**config_kwargs)\n\n    @property\n    def about(self) -&gt; About:\n        \"\"\"\n        Returns the About object associated with the configuration.\n\n        If the About object is not yet created, it will be created using the\n        configuration's package name.\n\n        Returns:\n            The About object associated with the configuration.\n        \"\"\"\n        if self._about_ is None:\n            config_name = (\n                \"__init__\"\n                if global_hyfi.package_name == \"hyfi\"\n                else global_hyfi.package_name\n            )\n            kwargs = {\"_config_name_\": config_name}\n            self._about_ = About(**kwargs)\n        return self._about_\n\n    @property\n    def project(self) -&gt; Optional[Project]:\n        \"\"\"\n        Returns the project associated with the configuration.\n\n        Returns:\n            Optional[Project]: The project associated with the configuration, or None if no project is set.\n        \"\"\"\n        return self._project_\n\n    def inititialize(\n        self,\n        project_name: Optional[str] = None,\n        project_description: Optional[str] = None,\n        project_root: Optional[str] = None,\n        project_workspace_name: Optional[str] = None,\n        global_hyfi_root: Optional[str] = None,\n        global_workspace_name: Optional[str] = None,\n        num_workers: Optional[int] = None,\n        logging_level: Optional[str] = None,\n        plugins: Optional[List[str]] = None,\n        user_config_path: Optional[str] = None,\n        dotenv_file: Optional[str] = None,\n        secrets_dir: Optional[str] = None,\n        reinit: bool = True,\n        autotime: bool = True,\n        retina: bool = True,\n        verbose: Union[bool, int] = False,\n        **project_kwargs,\n    ):\n        \"\"\"\n        Initialize and start hyfi.\n\n        Args:\n            project_name: Name of the project to use.\n            project_description: Description of the project that will be used.\n            project_root: Root directory of the project.\n            project_workspace_name: Name of the project's workspace directory.\n            global_hyfi_root: Root directory of the global hyfi.\n            global_workspace_name: Name of the global hierachical workspace directory.\n            num_workers: Number of workers to run.\n            log_level: Log level for the log.\n            plugins: A list of plugins to load. e.g. `[\"hyfi.conf\"]`\n            user_config_path: Path to the user configuration directory. e.g. `./config`\n            config_dirname: Name of the configuration directory. e.g. `conf`\n            dotenv_file: Name of the dotenv file. e.g. `.env`\n            secrets_dir: Name of the secrets directory. e.g. `secrets`\n            reinit: Whether to reinitialize the global config.\n            autotime: Whether to automatically set time and / or keep track of run times.\n            retina: Whether to use retina or not.\n            verbose: Enables or disables logging\n        \"\"\"\n        if self.project and not reinit:\n            return\n        # Set the log level to the given log level.\n        if logging_level:\n            GlobalConfig.setLogger(logging_level)\n            logger.setLevel(logging_level)\n\n        global_hyfi.reinitialize(\n            plugins=plugins,\n            user_config_path=user_config_path,\n            dotenv_file=dotenv_file,\n            secrets_dir=secrets_dir,\n        )\n\n        # Load the extentions for the autotime extension.\n        if autotime:\n            GlobalConfig.load_extentions(exts=[\"autotime\"])\n        # Set the retina matplotlib formats.\n        if retina:\n            GlobalConfig.set_matplotlib_formats(\"retina\")\n        if project_name:\n            project_kwargs[\"project_name\"] = project_name\n        if project_description:\n            project_kwargs[\"project_description\"] = project_description\n        if project_root:\n            project_kwargs[\"project_root\"] = ENVs.expand_posix_vars(project_root)\n        if project_workspace_name:\n            project_kwargs[\"project_workspace_name\"] = project_workspace_name\n        # Expand the hyfi_root environment variable.\n        if global_hyfi_root:\n            project_kwargs[\"global_hyfi_root\"] = ENVs.expand_posix_vars(\n                global_hyfi_root\n            )\n        if global_workspace_name:\n            project_kwargs[\"global_workspace_name\"] = global_workspace_name\n        if num_workers:\n            project_kwargs[\"num_workers\"] = num_workers\n        project_kwargs[\"verbose\"] = verbose\n\n        self._project_ = Project(**project_kwargs)\n        logger.info(\"HyFi project [%s] initialized\", self._project_.project_name)\n\n    def terminate(self) -&gt; None:\n        \"\"\"\n        Terminate hyfi config by stopping joblib\n\n        Returns:\n            True if successful False\n        \"\"\"\n        # Stop the backend if the joblib is running.\n        if self.project and self.project.joblib:\n            self.project.joblib.stop_backend()\n\n    def __repr__(self):\n        \"\"\"\n        Returns a string representation of GlobalConfig.\n        \"\"\"\n        return f\"GlobalConfig(project={self.project})\"\n\n    def __str__(self):\n        \"\"\"\n        Returns a string representation of the object.\n        \"\"\"\n        return self.__repr__()\n\n    @property\n    def app_version(self):\n        \"\"\"\n        Get the version of the application.\n        \"\"\"\n        return global_hyfi.version\n\n    @property\n    def app_name(self):\n        \"\"\"\n        Get the name of the application.\n        \"\"\"\n        return self.about.name\n\n    @property\n    def package_name(self):\n        \"\"\"\n        Get the name of the package.\n        \"\"\"\n        return global_hyfi.package_name\n\n    def print_about(self, **kwargs):\n        if not kwargs:\n            config_name = (\n                \"__init__\"\n                if global_hyfi.package_name == \"hyfi\"\n                else global_hyfi.package_name\n            )\n            kwargs = {\"_config_name_\": config_name}\n        self._about_ = About(**kwargs)\n        pkg_name = self.package_name\n        name = self.app_name\n        print()\n        for k, v in self.about.model_dump().items():\n            if k.startswith(\"_\") or k == \"version\":\n                continue\n            print(f\"{k:11} : {v}\")\n        print(f\"{'version':11} : {self.app_version}\")\n        if pkg_name:\n            print(f\"\\nExecute `{pkg_name} --help` to see what you can do with {name}\")\n        if kwargs.get(\"_open_link_\", False) and kwargs.get(\"homepage\"):\n            webbrowser.open_new_tab(kwargs[\"homepage\"])\n\n    @property\n    def project_dir(self) -&gt; Path:\n        \"\"\"Get the project root directory.\"\"\"\n        return (\n            self.project.root_dir\n            if self.project\n            else Path(__default_project_root__).absolute()\n        )\n\n    @property\n    def project_workspace_dir(self) -&gt; Path:\n        \"\"\"Get the project workspace directory.\"\"\"\n        return (\n            self.project.workspace_dir\n            if self.project\n            else self.project_dir / __default_workspace_name__\n        )\n\n    def get_path(\n        self,\n        path_name: str,\n        base_dir: Optional[Union[Path, str]] = None,\n        ensure_exists: bool = False,\n    ) -&gt; Optional[Path]:\n        \"\"\"\n        Get the path to a directory or file.\n        \"\"\"\n        return (\n            self.project.get_path(\n                path_name, base_dir=base_dir, ensure_exists=ensure_exists\n            )\n            if self.project\n            else None\n        )\n</code></pre>"},{"location":"reference/main/#hyfi.main.GlobalConfig.about","title":"<code>about: About</code>  <code>property</code>","text":"<p>Returns the About object associated with the configuration.</p> <p>If the About object is not yet created, it will be created using the configuration's package name.</p> <p>Returns:</p> Type Description <code>About</code> <p>The About object associated with the configuration.</p>"},{"location":"reference/main/#hyfi.main.GlobalConfig.app_name","title":"<code>app_name</code>  <code>property</code>","text":"<p>Get the name of the application.</p>"},{"location":"reference/main/#hyfi.main.GlobalConfig.app_version","title":"<code>app_version</code>  <code>property</code>","text":"<p>Get the version of the application.</p>"},{"location":"reference/main/#hyfi.main.GlobalConfig.package_name","title":"<code>package_name</code>  <code>property</code>","text":"<p>Get the name of the package.</p>"},{"location":"reference/main/#hyfi.main.GlobalConfig.project","title":"<code>project: Optional[Project]</code>  <code>property</code>","text":"<p>Returns the project associated with the configuration.</p> <p>Returns:</p> Type Description <code>Optional[Project]</code> <p>Optional[Project]: The project associated with the configuration, or None if no project is set.</p>"},{"location":"reference/main/#hyfi.main.GlobalConfig.project_dir","title":"<code>project_dir: Path</code>  <code>property</code>","text":"<p>Get the project root directory.</p>"},{"location":"reference/main/#hyfi.main.GlobalConfig.project_workspace_dir","title":"<code>project_workspace_dir: Path</code>  <code>property</code>","text":"<p>Get the project workspace directory.</p>"},{"location":"reference/main/#hyfi.main.GlobalConfig.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns a string representation of GlobalConfig.</p> Source code in <code>hyfi/main/config.py</code> <pre><code>def __repr__(self):\n    \"\"\"\n    Returns a string representation of GlobalConfig.\n    \"\"\"\n    return f\"GlobalConfig(project={self.project})\"\n</code></pre>"},{"location":"reference/main/#hyfi.main.GlobalConfig.__str__","title":"<code>__str__()</code>","text":"<p>Returns a string representation of the object.</p> Source code in <code>hyfi/main/config.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Returns a string representation of the object.\n    \"\"\"\n    return self.__repr__()\n</code></pre>"},{"location":"reference/main/#hyfi.main.GlobalConfig.get_path","title":"<code>get_path(path_name, base_dir=None, ensure_exists=False)</code>","text":"<p>Get the path to a directory or file.</p> Source code in <code>hyfi/main/config.py</code> <pre><code>def get_path(\n    self,\n    path_name: str,\n    base_dir: Optional[Union[Path, str]] = None,\n    ensure_exists: bool = False,\n) -&gt; Optional[Path]:\n    \"\"\"\n    Get the path to a directory or file.\n    \"\"\"\n    return (\n        self.project.get_path(\n            path_name, base_dir=base_dir, ensure_exists=ensure_exists\n        )\n        if self.project\n        else None\n    )\n</code></pre>"},{"location":"reference/main/#hyfi.main.GlobalConfig.inititialize","title":"<code>inititialize(project_name=None, project_description=None, project_root=None, project_workspace_name=None, global_hyfi_root=None, global_workspace_name=None, num_workers=None, logging_level=None, plugins=None, user_config_path=None, dotenv_file=None, secrets_dir=None, reinit=True, autotime=True, retina=True, verbose=False, **project_kwargs)</code>","text":"<p>Initialize and start hyfi.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>Optional[str]</code> <p>Name of the project to use.</p> <code>None</code> <code>project_description</code> <code>Optional[str]</code> <p>Description of the project that will be used.</p> <code>None</code> <code>project_root</code> <code>Optional[str]</code> <p>Root directory of the project.</p> <code>None</code> <code>project_workspace_name</code> <code>Optional[str]</code> <p>Name of the project's workspace directory.</p> <code>None</code> <code>global_hyfi_root</code> <code>Optional[str]</code> <p>Root directory of the global hyfi.</p> <code>None</code> <code>global_workspace_name</code> <code>Optional[str]</code> <p>Name of the global hierachical workspace directory.</p> <code>None</code> <code>num_workers</code> <code>Optional[int]</code> <p>Number of workers to run.</p> <code>None</code> <code>log_level</code> <p>Log level for the log.</p> required <code>plugins</code> <code>Optional[List[str]]</code> <p>A list of plugins to load. e.g. <code>[\"hyfi.conf\"]</code></p> <code>None</code> <code>user_config_path</code> <code>Optional[str]</code> <p>Path to the user configuration directory. e.g. <code>./config</code></p> <code>None</code> <code>config_dirname</code> <p>Name of the configuration directory. e.g. <code>conf</code></p> required <code>dotenv_file</code> <code>Optional[str]</code> <p>Name of the dotenv file. e.g. <code>.env</code></p> <code>None</code> <code>secrets_dir</code> <code>Optional[str]</code> <p>Name of the secrets directory. e.g. <code>secrets</code></p> <code>None</code> <code>reinit</code> <code>bool</code> <p>Whether to reinitialize the global config.</p> <code>True</code> <code>autotime</code> <code>bool</code> <p>Whether to automatically set time and / or keep track of run times.</p> <code>True</code> <code>retina</code> <code>bool</code> <p>Whether to use retina or not.</p> <code>True</code> <code>verbose</code> <code>Union[bool, int]</code> <p>Enables or disables logging</p> <code>False</code> Source code in <code>hyfi/main/config.py</code> <pre><code>def inititialize(\n    self,\n    project_name: Optional[str] = None,\n    project_description: Optional[str] = None,\n    project_root: Optional[str] = None,\n    project_workspace_name: Optional[str] = None,\n    global_hyfi_root: Optional[str] = None,\n    global_workspace_name: Optional[str] = None,\n    num_workers: Optional[int] = None,\n    logging_level: Optional[str] = None,\n    plugins: Optional[List[str]] = None,\n    user_config_path: Optional[str] = None,\n    dotenv_file: Optional[str] = None,\n    secrets_dir: Optional[str] = None,\n    reinit: bool = True,\n    autotime: bool = True,\n    retina: bool = True,\n    verbose: Union[bool, int] = False,\n    **project_kwargs,\n):\n    \"\"\"\n    Initialize and start hyfi.\n\n    Args:\n        project_name: Name of the project to use.\n        project_description: Description of the project that will be used.\n        project_root: Root directory of the project.\n        project_workspace_name: Name of the project's workspace directory.\n        global_hyfi_root: Root directory of the global hyfi.\n        global_workspace_name: Name of the global hierachical workspace directory.\n        num_workers: Number of workers to run.\n        log_level: Log level for the log.\n        plugins: A list of plugins to load. e.g. `[\"hyfi.conf\"]`\n        user_config_path: Path to the user configuration directory. e.g. `./config`\n        config_dirname: Name of the configuration directory. e.g. `conf`\n        dotenv_file: Name of the dotenv file. e.g. `.env`\n        secrets_dir: Name of the secrets directory. e.g. `secrets`\n        reinit: Whether to reinitialize the global config.\n        autotime: Whether to automatically set time and / or keep track of run times.\n        retina: Whether to use retina or not.\n        verbose: Enables or disables logging\n    \"\"\"\n    if self.project and not reinit:\n        return\n    # Set the log level to the given log level.\n    if logging_level:\n        GlobalConfig.setLogger(logging_level)\n        logger.setLevel(logging_level)\n\n    global_hyfi.reinitialize(\n        plugins=plugins,\n        user_config_path=user_config_path,\n        dotenv_file=dotenv_file,\n        secrets_dir=secrets_dir,\n    )\n\n    # Load the extentions for the autotime extension.\n    if autotime:\n        GlobalConfig.load_extentions(exts=[\"autotime\"])\n    # Set the retina matplotlib formats.\n    if retina:\n        GlobalConfig.set_matplotlib_formats(\"retina\")\n    if project_name:\n        project_kwargs[\"project_name\"] = project_name\n    if project_description:\n        project_kwargs[\"project_description\"] = project_description\n    if project_root:\n        project_kwargs[\"project_root\"] = ENVs.expand_posix_vars(project_root)\n    if project_workspace_name:\n        project_kwargs[\"project_workspace_name\"] = project_workspace_name\n    # Expand the hyfi_root environment variable.\n    if global_hyfi_root:\n        project_kwargs[\"global_hyfi_root\"] = ENVs.expand_posix_vars(\n            global_hyfi_root\n        )\n    if global_workspace_name:\n        project_kwargs[\"global_workspace_name\"] = global_workspace_name\n    if num_workers:\n        project_kwargs[\"num_workers\"] = num_workers\n    project_kwargs[\"verbose\"] = verbose\n\n    self._project_ = Project(**project_kwargs)\n    logger.info(\"HyFi project [%s] initialized\", self._project_.project_name)\n</code></pre>"},{"location":"reference/main/#hyfi.main.GlobalConfig.terminate","title":"<code>terminate()</code>","text":"<p>Terminate hyfi config by stopping joblib</p> <p>Returns:</p> Type Description <code>None</code> <p>True if successful False</p> Source code in <code>hyfi/main/config.py</code> <pre><code>def terminate(self) -&gt; None:\n    \"\"\"\n    Terminate hyfi config by stopping joblib\n\n    Returns:\n        True if successful False\n    \"\"\"\n    # Stop the backend if the joblib is running.\n    if self.project and self.project.joblib:\n        self.project.joblib.stop_backend()\n</code></pre>"},{"location":"reference/main/#hyfi.main.GlobalConfigResolver","title":"<code>GlobalConfigResolver</code>","text":"<p>A class that resolves global configuration paths for HyFI.</p> Source code in <code>hyfi/main/config.py</code> <pre><code>class GlobalConfigResolver:\n    \"\"\"\n    A class that resolves global configuration paths for HyFI.\n    \"\"\"\n\n    @staticmethod\n    def __project_root_path__() -&gt; str:\n        \"\"\"Global HyFI config path for the project root.\"\"\"\n        return str(global_config.project_dir or \"\")\n\n    @staticmethod\n    def __project_workspace_path__() -&gt; str:\n        \"\"\"Global HyFI config path for the project workspace directory.\"\"\"\n        return str(global_config.project_workspace_dir or \"\")\n\n    @staticmethod\n    def __get_path__(path_name: str, base_dir: Optional[str] = None) -&gt; str:\n        \"\"\"\n        Get the path to a directory or file.\n\n        Args:\n            path_name (str): The name of the path.\n            base_dir (Optional[str], optional): The base directory to resolve the path from. Defaults to None.\n\n        Returns:\n            str: The resolved path.\n        \"\"\"\n        return str(global_config.get_path(path_name, base_dir=base_dir) or \"\")\n</code></pre>"},{"location":"reference/main/#hyfi.main.GlobalConfigResolver.__get_path__","title":"<code>__get_path__(path_name, base_dir=None)</code>  <code>staticmethod</code>","text":"<p>Get the path to a directory or file.</p> <p>Parameters:</p> Name Type Description Default <code>path_name</code> <code>str</code> <p>The name of the path.</p> required <code>base_dir</code> <code>Optional[str]</code> <p>The base directory to resolve the path from. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The resolved path.</p> Source code in <code>hyfi/main/config.py</code> <pre><code>@staticmethod\ndef __get_path__(path_name: str, base_dir: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Get the path to a directory or file.\n\n    Args:\n        path_name (str): The name of the path.\n        base_dir (Optional[str], optional): The base directory to resolve the path from. Defaults to None.\n\n    Returns:\n        str: The resolved path.\n    \"\"\"\n    return str(global_config.get_path(path_name, base_dir=base_dir) or \"\")\n</code></pre>"},{"location":"reference/main/#hyfi.main.GlobalConfigResolver.__project_root_path__","title":"<code>__project_root_path__()</code>  <code>staticmethod</code>","text":"<p>Global HyFI config path for the project root.</p> Source code in <code>hyfi/main/config.py</code> <pre><code>@staticmethod\ndef __project_root_path__() -&gt; str:\n    \"\"\"Global HyFI config path for the project root.\"\"\"\n    return str(global_config.project_dir or \"\")\n</code></pre>"},{"location":"reference/main/#hyfi.main.GlobalConfigResolver.__project_workspace_path__","title":"<code>__project_workspace_path__()</code>  <code>staticmethod</code>","text":"<p>Global HyFI config path for the project workspace directory.</p> Source code in <code>hyfi/main/config.py</code> <pre><code>@staticmethod\ndef __project_workspace_path__() -&gt; str:\n    \"\"\"Global HyFI config path for the project workspace directory.\"\"\"\n    return str(global_config.project_workspace_dir or \"\")\n</code></pre>"},{"location":"reference/main/#hyfi.main.HyFI","title":"<code>HyFI</code>","text":"<p>               Bases: <code>BATCHER</code>, <code>Composer</code>, <code>GRAPHICs</code>, <code>PIPELINEs</code></p> <p>Primary class for the hyfi config package</p> Source code in <code>hyfi/main/main.py</code> <pre><code>class HyFI(\n    BATCHER,\n    Composer,\n    GRAPHICs,\n    PIPELINEs,\n):\n    \"\"\"Primary class for the hyfi config package\"\"\"\n\n    __config__: Optional[HyFIConfig] = None\n    __variables__: Optional[Variables] = None\n\n    __version__ = GlobalHyFIResolver.__hyfi_version__()\n    __hyfi_path__ = GlobalHyFIResolver.__hyfi_path__()\n    __home_path__ = GlobalHyFIResolver.__home_path__()\n    __package_name__ = GlobalHyFIResolver.__package_name__()\n    __package_path__ = GlobalHyFIResolver.__package_path__()\n    __app_version__ = GlobalHyFIResolver.__app_version__()\n\n    def __init__(self, **config_kwargs):\n        if config_kwargs:\n            self.__config__ = HyFIConfig(**config_kwargs)\n            if self.__config__.project:\n                self.initialize(**self.__config__.project)\n\n    @property\n    def config(self) -&gt; HyFIConfig:\n        \"\"\"Get the global config.\"\"\"\n        return self.__config__\n\n    @property\n    def project(self) -&gt; Optional[Project]:\n        \"\"\"Get the project.\"\"\"\n        if global_config.project:\n            return global_config.project\n        else:\n            raise ValueError(\"Project not initialized.\")\n\n    @project.setter\n    def project(self, project: Project) -&gt; None:\n        \"\"\"Set the project.\"\"\"\n        global_config.project = project\n\n    @staticmethod\n    def set_project(project: Project) -&gt; None:\n        \"\"\"\n        Set the project.\n\n        Args:\n            project: Project to set.\n        \"\"\"\n        logger.info(f\"Setting the global project to {project.project_name}\")\n        global_config.project = project\n\n    @staticmethod\n    def initialize(\n        project_name: Optional[str] = None,\n        project_description: Optional[str] = None,\n        project_root: Optional[str] = None,\n        project_workspace_name: Optional[str] = None,\n        global_hyfi_root: Optional[str] = None,\n        global_workspace_name: Optional[str] = None,\n        num_workers: Optional[int] = None,\n        logging_level: Optional[str] = None,\n        plugins: Optional[List[str]] = None,\n        user_config_path: Optional[str] = None,\n        dotenv_file: Optional[str] = None,\n        secrets_dir: Optional[str] = None,\n        reinit: bool = True,\n        autotime: bool = True,\n        retina: bool = True,\n        verbose: Union[bool, int] = False,\n        **project_kwargs,\n    ) -&gt; \"HyFI\":\n        \"\"\"\n        Initialize and start hyfi.\n\n        Args:\n            project_name: Name of the project to use.\n            project_description: Description of the project that will be used.\n            project_root: Root directory of the project.\n            project_workspace_name: Name of the project's workspace directory.\n            global_hyfi_root: Root directory of the global hyfi.\n            global_workspace_name: Name of the global hierachical workspace directory.\n            num_workers: Number of workers to run.\n            logging_level: Log level for the log.\n            plugins: A list of plugins to load. e.g. `[\"hyfi.conf\"]`\n            user_config_path: Path to the user configuration directory. e.g. `./config`\n            config_dirname: Name of the configuration directory. e.g. `conf`\n            dotenv_file: Name of the dotenv file. e.g. `.env`\n            secrets_dir: Name of the secrets directory. e.g. `secrets`\n            reinit: Whether to reinitialize the global config.\n            autotime: Whether to automatically set time and / or keep track of run times.\n            retina: Whether to use retina or not.\n            verbose: Enables or disables logging\n        \"\"\"\n        global_config.inititialize(\n            project_name=project_name,\n            project_description=project_description,\n            project_root=project_root,\n            project_workspace_name=project_workspace_name,\n            global_hyfi_root=global_hyfi_root,\n            global_workspace_name=global_workspace_name,\n            num_workers=num_workers,\n            logging_level=logging_level,\n            plugins=plugins,\n            user_config_path=user_config_path,\n            dotenv_file=dotenv_file,\n            secrets_dir=secrets_dir,\n            reinit=reinit,\n            autotime=autotime,\n            retina=retina,\n            verbose=verbose,\n            **HyFI.to_dict(project_kwargs),\n        )\n        return HyFI()\n\n    @staticmethod\n    def terminate() -&gt; None:\n        \"\"\"\n        Terminate the global config.\n\n        Returns:\n            bool: True if termination was successful, False otherwise.\n        \"\"\"\n        global_config.terminate()\n\n    @staticmethod\n    def initialize_global_hyfi(\n        package_path: str,\n        version: str,\n        plugins: Optional[List[str]] = None,\n        user_config_path: Optional[str] = None,\n        config_dirname: Optional[str] = None,\n        dotenv_file: Optional[str] = None,\n        secrets_dir: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Initializes the global HyFI instance.\n        This function should be called before any other HyFI function.\n        A plugin is a python module which contains a configuration module.\n\n        Args:\n            package_path: Path to the package root folder. e.g. `./src/hyfi`\n            version: Version of the package. e.g. `0.1.0`\n            plugins: A list of plugins to load. e.g. `[\"hyfi.conf\"]`\n            user_config_path: Path to the user configuration directory. e.g. `./config`\n            config_dirname: Name of the configuration directory. e.g. `conf`\n            dotenv_file: Name of the dotenv file. e.g. `.env`\n            secrets_dir: Name of the secrets directory. e.g. `secrets`\n            **kwargs: Additional arguments to be set as attributes.\n        \"\"\"\n        global_hyfi.initialize(\n            package_path=package_path,\n            version=version,\n            plugins=plugins,\n            user_config_path=user_config_path,\n            config_dirname=config_dirname,\n            dotenv_file=dotenv_file,\n            secrets_dir=secrets_dir,\n            **kwargs,\n        )\n\n    @property\n    def dryrun(self) -&gt; bool:\n        \"\"\"Get the dryrun flag.\"\"\"\n        return self.config.dryrun or self.config.noop\n\n    @property\n    def variables(self) -&gt; Variables:\n        \"\"\"Get the global variables.\"\"\"\n        if self.__variables__ is None:\n            self.__variables__ = Variables()\n        return self.__variables__\n\n    @property\n    def resolve(self) -&gt; bool:\n        \"\"\"Get the resolve flag.\"\"\"\n        return self.config.resolve\n\n    @property\n    def verbose(self) -&gt; bool:\n        \"\"\"Get the verbose flag.\"\"\"\n        return self.config.verbose or self.dryrun\n\n    @property\n    def app_name(self):\n        \"\"\"\n        Get the name of the application.\n        \"\"\"\n        return global_config.app_name\n\n    @property\n    def app_version(self):\n        \"\"\"\n        Get the version of the application.\n        \"\"\"\n        return global_config.app_version\n\n    @staticmethod\n    def print_about(**args) -&gt; None:\n        \"\"\"Print the about information\"\"\"\n        global_config.print_about(**args)\n\n    @staticmethod\n    def Variables(**kwargs) -&gt; Variables:\n        \"\"\"\n        Return the Variables.\n\n        Args:\n            **kwargs: Additional keyword arguments to pass to the Variables constructor.\n\n        Returns:\n            Variables: An instance of the Variables class.\n        \"\"\"\n        return Variables(**kwargs)\n\n    @staticmethod\n    def JobLib(**kwargs) -&gt; JobLib:\n        \"\"\"\n        Return the joblib pipe.\n\n        Args:\n            **kwargs: Additional keyword arguments to pass to the JobLibConfig constructor.\n\n        Returns:\n            JobLibConfig: An instance of the JobLibConfig class.\n        \"\"\"\n        return JobLib(**kwargs)\n\n    @staticmethod\n    def Env(**kwargs) -&gt; Env:\n        \"\"\"\n        Return the Env.\n\n        Args:\n            **kwargs: Additional keyword arguments to pass to the Env constructor.\n\n        Returns:\n            Env: An instance of the Env class.\n        \"\"\"\n        return Env(**kwargs)\n\n    @staticmethod\n    def Task(**kwargs) -&gt; Task:\n        \"\"\"\n        Return the TaskConfig.\n\n        Args:\n            **kwargs: Additional keyword arguments to pass to the TaskConfig constructor.\n\n        Returns:\n            TaskConfig: An instance of the TaskConfig class.\n        \"\"\"\n        return Task(**kwargs)\n\n    @staticmethod\n    def Workflow(**kwargs) -&gt; Workflow:\n        \"\"\"\n        Return the WorkflowConfig.\n\n        Args:\n            **kwargs: Additional keyword arguments to pass to the WorkflowConfig constructor.\n\n        Returns:\n            WorkflowConfig: An instance of the WorkflowConfig class.\n        \"\"\"\n        return Workflow(**kwargs)\n\n    ###############################\n    # Pipeline related functions\n    ###############################\n    @staticmethod\n    def run_command(**config):\n        \"\"\"Run a command\"\"\"\n        return HyFI.run_config(config)\n\n    @staticmethod\n    def run(\n        config_group: Optional[str] = None,\n        overrides: Optional[List[str]] = None,\n        config_data: Optional[Union[Dict[str, Any], DictConfig]] = None,\n        global_package=False,\n        dryrun=False,\n        **kwargs,\n    ):\n        \"\"\"Run the config by composing it and running it\"\"\"\n        if config_group:\n            logger.info(\"Composing the HyFI config from config group %s\", config_group)\n            config = HyFI.compose_as_dict(\n                config_group=config_group,\n                overrides=overrides,\n                config_data=config_data,\n                global_package=global_package,\n            )\n        HyFI.run_config(config, dryrun=dryrun)\n\n    @staticmethod\n    def run_intantiatable(\n        config: Dict[str, Any],\n        dryrun=False,\n    ):\n        \"\"\"Run the config by composing it and running it\"\"\"\n        logger.info(\"Instantiating the HyFI config\")\n        if dryrun:\n            print(\"\\nDryrun is enabled, not running the HyFI config\\n\")\n            return\n        task = HyFI.instantiate(config)\n        if task and getattr(task, \"__call__\", None):\n            logger.info(\"The HyFI config is callable, running it\")\n            task()\n\n    @staticmethod\n    def run_config(\n        config: Union[Dict[str, Any], DictConfig],\n        dryrun=False,\n    ):\n        \"\"\"Run the provided config\"\"\"\n        config = HyFI.to_dict(config) if config else {}\n        # Check if the config is instantiatable\n        if HyFI.is_instantiatable(config):\n            HyFI.run_intantiatable(config, dryrun=dryrun)\n            return\n\n        logger.info(\n            \"The HyFI config is not instantiatable, running HyFI task with the config\"\n        )\n        # Run the HyFI task\n        cmd_name = config.get(\"cmd_name\")\n        config_group = config.get(\"_config_group_\", \"\")\n        if not cmd_name:\n            if config_group == \"/workflow\":\n                cmd_name = \"run_workflow\"\n            elif \"task\" in config:\n                cmd_name = \"run_task\"\n            elif \"copier\" in config:\n                cmd_name = \"copy_conf\"\n\n        if cmd_name == \"run_workflow\":\n            workflow = HyFI.Workflow(**config)\n            HyFI.run_workflow(workflow, dryrun=dryrun)\n        elif cmd_name == \"run_task\":\n            if \"project\" in config:\n                HyFI.initialize(**config[\"project\"])\n            task = HyFI.Task(**config[\"task\"])\n            HyFI.run_task(task, dryrun=dryrun)\n        elif cmd_name == \"copy_conf\":\n            copier_cfg = config[\"copier\"]\n            copier_cfg[\"dryrun\"] = dryrun\n            with Copier(**copier_cfg) as worker:\n                worker.run_copy()\n        else:\n            for _, cfg in config.items():\n                if HyFI.is_instantiatable(cfg):\n                    HyFI.run_intantiatable(cfg, dryrun)\n                    return\n            if not dryrun:\n                HyFI.print_about(**config.get(\"about\", {}))\n</code></pre>"},{"location":"reference/main/#hyfi.main.HyFI.app_name","title":"<code>app_name</code>  <code>property</code>","text":"<p>Get the name of the application.</p>"},{"location":"reference/main/#hyfi.main.HyFI.app_version","title":"<code>app_version</code>  <code>property</code>","text":"<p>Get the version of the application.</p>"},{"location":"reference/main/#hyfi.main.HyFI.config","title":"<code>config: HyFIConfig</code>  <code>property</code>","text":"<p>Get the global config.</p>"},{"location":"reference/main/#hyfi.main.HyFI.dryrun","title":"<code>dryrun: bool</code>  <code>property</code>","text":"<p>Get the dryrun flag.</p>"},{"location":"reference/main/#hyfi.main.HyFI.project","title":"<code>project: Optional[Project]</code>  <code>property</code> <code>writable</code>","text":"<p>Get the project.</p>"},{"location":"reference/main/#hyfi.main.HyFI.resolve","title":"<code>resolve: bool</code>  <code>property</code>","text":"<p>Get the resolve flag.</p>"},{"location":"reference/main/#hyfi.main.HyFI.variables","title":"<code>variables: Variables</code>  <code>property</code>","text":"<p>Get the global variables.</p>"},{"location":"reference/main/#hyfi.main.HyFI.verbose","title":"<code>verbose: bool</code>  <code>property</code>","text":"<p>Get the verbose flag.</p>"},{"location":"reference/main/#hyfi.main.HyFI.Env","title":"<code>Env(**kwargs)</code>  <code>staticmethod</code>","text":"<p>Return the Env.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments to pass to the Env constructor.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Env</code> <code>Env</code> <p>An instance of the Env class.</p> Source code in <code>hyfi/main/main.py</code> <pre><code>@staticmethod\ndef Env(**kwargs) -&gt; Env:\n    \"\"\"\n    Return the Env.\n\n    Args:\n        **kwargs: Additional keyword arguments to pass to the Env constructor.\n\n    Returns:\n        Env: An instance of the Env class.\n    \"\"\"\n    return Env(**kwargs)\n</code></pre>"},{"location":"reference/main/#hyfi.main.HyFI.JobLib","title":"<code>JobLib(**kwargs)</code>  <code>staticmethod</code>","text":"<p>Return the joblib pipe.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments to pass to the JobLibConfig constructor.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>JobLibConfig</code> <code>JobLib</code> <p>An instance of the JobLibConfig class.</p> Source code in <code>hyfi/main/main.py</code> <pre><code>@staticmethod\ndef JobLib(**kwargs) -&gt; JobLib:\n    \"\"\"\n    Return the joblib pipe.\n\n    Args:\n        **kwargs: Additional keyword arguments to pass to the JobLibConfig constructor.\n\n    Returns:\n        JobLibConfig: An instance of the JobLibConfig class.\n    \"\"\"\n    return JobLib(**kwargs)\n</code></pre>"},{"location":"reference/main/#hyfi.main.HyFI.Task","title":"<code>Task(**kwargs)</code>  <code>staticmethod</code>","text":"<p>Return the TaskConfig.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments to pass to the TaskConfig constructor.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>TaskConfig</code> <code>Task</code> <p>An instance of the TaskConfig class.</p> Source code in <code>hyfi/main/main.py</code> <pre><code>@staticmethod\ndef Task(**kwargs) -&gt; Task:\n    \"\"\"\n    Return the TaskConfig.\n\n    Args:\n        **kwargs: Additional keyword arguments to pass to the TaskConfig constructor.\n\n    Returns:\n        TaskConfig: An instance of the TaskConfig class.\n    \"\"\"\n    return Task(**kwargs)\n</code></pre>"},{"location":"reference/main/#hyfi.main.HyFI.Variables","title":"<code>Variables(**kwargs)</code>  <code>staticmethod</code>","text":"<p>Return the Variables.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments to pass to the Variables constructor.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Variables</code> <code>Variables</code> <p>An instance of the Variables class.</p> Source code in <code>hyfi/main/main.py</code> <pre><code>@staticmethod\ndef Variables(**kwargs) -&gt; Variables:\n    \"\"\"\n    Return the Variables.\n\n    Args:\n        **kwargs: Additional keyword arguments to pass to the Variables constructor.\n\n    Returns:\n        Variables: An instance of the Variables class.\n    \"\"\"\n    return Variables(**kwargs)\n</code></pre>"},{"location":"reference/main/#hyfi.main.HyFI.Workflow","title":"<code>Workflow(**kwargs)</code>  <code>staticmethod</code>","text":"<p>Return the WorkflowConfig.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments to pass to the WorkflowConfig constructor.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>WorkflowConfig</code> <code>Workflow</code> <p>An instance of the WorkflowConfig class.</p> Source code in <code>hyfi/main/main.py</code> <pre><code>@staticmethod\ndef Workflow(**kwargs) -&gt; Workflow:\n    \"\"\"\n    Return the WorkflowConfig.\n\n    Args:\n        **kwargs: Additional keyword arguments to pass to the WorkflowConfig constructor.\n\n    Returns:\n        WorkflowConfig: An instance of the WorkflowConfig class.\n    \"\"\"\n    return Workflow(**kwargs)\n</code></pre>"},{"location":"reference/main/#hyfi.main.HyFI.initialize","title":"<code>initialize(project_name=None, project_description=None, project_root=None, project_workspace_name=None, global_hyfi_root=None, global_workspace_name=None, num_workers=None, logging_level=None, plugins=None, user_config_path=None, dotenv_file=None, secrets_dir=None, reinit=True, autotime=True, retina=True, verbose=False, **project_kwargs)</code>  <code>staticmethod</code>","text":"<p>Initialize and start hyfi.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>Optional[str]</code> <p>Name of the project to use.</p> <code>None</code> <code>project_description</code> <code>Optional[str]</code> <p>Description of the project that will be used.</p> <code>None</code> <code>project_root</code> <code>Optional[str]</code> <p>Root directory of the project.</p> <code>None</code> <code>project_workspace_name</code> <code>Optional[str]</code> <p>Name of the project's workspace directory.</p> <code>None</code> <code>global_hyfi_root</code> <code>Optional[str]</code> <p>Root directory of the global hyfi.</p> <code>None</code> <code>global_workspace_name</code> <code>Optional[str]</code> <p>Name of the global hierachical workspace directory.</p> <code>None</code> <code>num_workers</code> <code>Optional[int]</code> <p>Number of workers to run.</p> <code>None</code> <code>logging_level</code> <code>Optional[str]</code> <p>Log level for the log.</p> <code>None</code> <code>plugins</code> <code>Optional[List[str]]</code> <p>A list of plugins to load. e.g. <code>[\"hyfi.conf\"]</code></p> <code>None</code> <code>user_config_path</code> <code>Optional[str]</code> <p>Path to the user configuration directory. e.g. <code>./config</code></p> <code>None</code> <code>config_dirname</code> <p>Name of the configuration directory. e.g. <code>conf</code></p> required <code>dotenv_file</code> <code>Optional[str]</code> <p>Name of the dotenv file. e.g. <code>.env</code></p> <code>None</code> <code>secrets_dir</code> <code>Optional[str]</code> <p>Name of the secrets directory. e.g. <code>secrets</code></p> <code>None</code> <code>reinit</code> <code>bool</code> <p>Whether to reinitialize the global config.</p> <code>True</code> <code>autotime</code> <code>bool</code> <p>Whether to automatically set time and / or keep track of run times.</p> <code>True</code> <code>retina</code> <code>bool</code> <p>Whether to use retina or not.</p> <code>True</code> <code>verbose</code> <code>Union[bool, int]</code> <p>Enables or disables logging</p> <code>False</code> Source code in <code>hyfi/main/main.py</code> <pre><code>@staticmethod\ndef initialize(\n    project_name: Optional[str] = None,\n    project_description: Optional[str] = None,\n    project_root: Optional[str] = None,\n    project_workspace_name: Optional[str] = None,\n    global_hyfi_root: Optional[str] = None,\n    global_workspace_name: Optional[str] = None,\n    num_workers: Optional[int] = None,\n    logging_level: Optional[str] = None,\n    plugins: Optional[List[str]] = None,\n    user_config_path: Optional[str] = None,\n    dotenv_file: Optional[str] = None,\n    secrets_dir: Optional[str] = None,\n    reinit: bool = True,\n    autotime: bool = True,\n    retina: bool = True,\n    verbose: Union[bool, int] = False,\n    **project_kwargs,\n) -&gt; \"HyFI\":\n    \"\"\"\n    Initialize and start hyfi.\n\n    Args:\n        project_name: Name of the project to use.\n        project_description: Description of the project that will be used.\n        project_root: Root directory of the project.\n        project_workspace_name: Name of the project's workspace directory.\n        global_hyfi_root: Root directory of the global hyfi.\n        global_workspace_name: Name of the global hierachical workspace directory.\n        num_workers: Number of workers to run.\n        logging_level: Log level for the log.\n        plugins: A list of plugins to load. e.g. `[\"hyfi.conf\"]`\n        user_config_path: Path to the user configuration directory. e.g. `./config`\n        config_dirname: Name of the configuration directory. e.g. `conf`\n        dotenv_file: Name of the dotenv file. e.g. `.env`\n        secrets_dir: Name of the secrets directory. e.g. `secrets`\n        reinit: Whether to reinitialize the global config.\n        autotime: Whether to automatically set time and / or keep track of run times.\n        retina: Whether to use retina or not.\n        verbose: Enables or disables logging\n    \"\"\"\n    global_config.inititialize(\n        project_name=project_name,\n        project_description=project_description,\n        project_root=project_root,\n        project_workspace_name=project_workspace_name,\n        global_hyfi_root=global_hyfi_root,\n        global_workspace_name=global_workspace_name,\n        num_workers=num_workers,\n        logging_level=logging_level,\n        plugins=plugins,\n        user_config_path=user_config_path,\n        dotenv_file=dotenv_file,\n        secrets_dir=secrets_dir,\n        reinit=reinit,\n        autotime=autotime,\n        retina=retina,\n        verbose=verbose,\n        **HyFI.to_dict(project_kwargs),\n    )\n    return HyFI()\n</code></pre>"},{"location":"reference/main/#hyfi.main.HyFI.initialize_global_hyfi","title":"<code>initialize_global_hyfi(package_path, version, plugins=None, user_config_path=None, config_dirname=None, dotenv_file=None, secrets_dir=None, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Initializes the global HyFI instance. This function should be called before any other HyFI function. A plugin is a python module which contains a configuration module.</p> <p>Parameters:</p> Name Type Description Default <code>package_path</code> <code>str</code> <p>Path to the package root folder. e.g. <code>./src/hyfi</code></p> required <code>version</code> <code>str</code> <p>Version of the package. e.g. <code>0.1.0</code></p> required <code>plugins</code> <code>Optional[List[str]]</code> <p>A list of plugins to load. e.g. <code>[\"hyfi.conf\"]</code></p> <code>None</code> <code>user_config_path</code> <code>Optional[str]</code> <p>Path to the user configuration directory. e.g. <code>./config</code></p> <code>None</code> <code>config_dirname</code> <code>Optional[str]</code> <p>Name of the configuration directory. e.g. <code>conf</code></p> <code>None</code> <code>dotenv_file</code> <code>Optional[str]</code> <p>Name of the dotenv file. e.g. <code>.env</code></p> <code>None</code> <code>secrets_dir</code> <code>Optional[str]</code> <p>Name of the secrets directory. e.g. <code>secrets</code></p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to be set as attributes.</p> <code>{}</code> Source code in <code>hyfi/main/main.py</code> <pre><code>@staticmethod\ndef initialize_global_hyfi(\n    package_path: str,\n    version: str,\n    plugins: Optional[List[str]] = None,\n    user_config_path: Optional[str] = None,\n    config_dirname: Optional[str] = None,\n    dotenv_file: Optional[str] = None,\n    secrets_dir: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Initializes the global HyFI instance.\n    This function should be called before any other HyFI function.\n    A plugin is a python module which contains a configuration module.\n\n    Args:\n        package_path: Path to the package root folder. e.g. `./src/hyfi`\n        version: Version of the package. e.g. `0.1.0`\n        plugins: A list of plugins to load. e.g. `[\"hyfi.conf\"]`\n        user_config_path: Path to the user configuration directory. e.g. `./config`\n        config_dirname: Name of the configuration directory. e.g. `conf`\n        dotenv_file: Name of the dotenv file. e.g. `.env`\n        secrets_dir: Name of the secrets directory. e.g. `secrets`\n        **kwargs: Additional arguments to be set as attributes.\n    \"\"\"\n    global_hyfi.initialize(\n        package_path=package_path,\n        version=version,\n        plugins=plugins,\n        user_config_path=user_config_path,\n        config_dirname=config_dirname,\n        dotenv_file=dotenv_file,\n        secrets_dir=secrets_dir,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/main/#hyfi.main.HyFI.print_about","title":"<code>print_about(**args)</code>  <code>staticmethod</code>","text":"<p>Print the about information</p> Source code in <code>hyfi/main/main.py</code> <pre><code>@staticmethod\ndef print_about(**args) -&gt; None:\n    \"\"\"Print the about information\"\"\"\n    global_config.print_about(**args)\n</code></pre>"},{"location":"reference/main/#hyfi.main.HyFI.run","title":"<code>run(config_group=None, overrides=None, config_data=None, global_package=False, dryrun=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Run the config by composing it and running it</p> Source code in <code>hyfi/main/main.py</code> <pre><code>@staticmethod\ndef run(\n    config_group: Optional[str] = None,\n    overrides: Optional[List[str]] = None,\n    config_data: Optional[Union[Dict[str, Any], DictConfig]] = None,\n    global_package=False,\n    dryrun=False,\n    **kwargs,\n):\n    \"\"\"Run the config by composing it and running it\"\"\"\n    if config_group:\n        logger.info(\"Composing the HyFI config from config group %s\", config_group)\n        config = HyFI.compose_as_dict(\n            config_group=config_group,\n            overrides=overrides,\n            config_data=config_data,\n            global_package=global_package,\n        )\n    HyFI.run_config(config, dryrun=dryrun)\n</code></pre>"},{"location":"reference/main/#hyfi.main.HyFI.run_command","title":"<code>run_command(**config)</code>  <code>staticmethod</code>","text":"<p>Run a command</p> Source code in <code>hyfi/main/main.py</code> <pre><code>@staticmethod\ndef run_command(**config):\n    \"\"\"Run a command\"\"\"\n    return HyFI.run_config(config)\n</code></pre>"},{"location":"reference/main/#hyfi.main.HyFI.run_config","title":"<code>run_config(config, dryrun=False)</code>  <code>staticmethod</code>","text":"<p>Run the provided config</p> Source code in <code>hyfi/main/main.py</code> <pre><code>@staticmethod\ndef run_config(\n    config: Union[Dict[str, Any], DictConfig],\n    dryrun=False,\n):\n    \"\"\"Run the provided config\"\"\"\n    config = HyFI.to_dict(config) if config else {}\n    # Check if the config is instantiatable\n    if HyFI.is_instantiatable(config):\n        HyFI.run_intantiatable(config, dryrun=dryrun)\n        return\n\n    logger.info(\n        \"The HyFI config is not instantiatable, running HyFI task with the config\"\n    )\n    # Run the HyFI task\n    cmd_name = config.get(\"cmd_name\")\n    config_group = config.get(\"_config_group_\", \"\")\n    if not cmd_name:\n        if config_group == \"/workflow\":\n            cmd_name = \"run_workflow\"\n        elif \"task\" in config:\n            cmd_name = \"run_task\"\n        elif \"copier\" in config:\n            cmd_name = \"copy_conf\"\n\n    if cmd_name == \"run_workflow\":\n        workflow = HyFI.Workflow(**config)\n        HyFI.run_workflow(workflow, dryrun=dryrun)\n    elif cmd_name == \"run_task\":\n        if \"project\" in config:\n            HyFI.initialize(**config[\"project\"])\n        task = HyFI.Task(**config[\"task\"])\n        HyFI.run_task(task, dryrun=dryrun)\n    elif cmd_name == \"copy_conf\":\n        copier_cfg = config[\"copier\"]\n        copier_cfg[\"dryrun\"] = dryrun\n        with Copier(**copier_cfg) as worker:\n            worker.run_copy()\n    else:\n        for _, cfg in config.items():\n            if HyFI.is_instantiatable(cfg):\n                HyFI.run_intantiatable(cfg, dryrun)\n                return\n        if not dryrun:\n            HyFI.print_about(**config.get(\"about\", {}))\n</code></pre>"},{"location":"reference/main/#hyfi.main.HyFI.run_intantiatable","title":"<code>run_intantiatable(config, dryrun=False)</code>  <code>staticmethod</code>","text":"<p>Run the config by composing it and running it</p> Source code in <code>hyfi/main/main.py</code> <pre><code>@staticmethod\ndef run_intantiatable(\n    config: Dict[str, Any],\n    dryrun=False,\n):\n    \"\"\"Run the config by composing it and running it\"\"\"\n    logger.info(\"Instantiating the HyFI config\")\n    if dryrun:\n        print(\"\\nDryrun is enabled, not running the HyFI config\\n\")\n        return\n    task = HyFI.instantiate(config)\n    if task and getattr(task, \"__call__\", None):\n        logger.info(\"The HyFI config is callable, running it\")\n        task()\n</code></pre>"},{"location":"reference/main/#hyfi.main.HyFI.set_project","title":"<code>set_project(project)</code>  <code>staticmethod</code>","text":"<p>Set the project.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>Project to set.</p> required Source code in <code>hyfi/main/main.py</code> <pre><code>@staticmethod\ndef set_project(project: Project) -&gt; None:\n    \"\"\"\n    Set the project.\n\n    Args:\n        project: Project to set.\n    \"\"\"\n    logger.info(f\"Setting the global project to {project.project_name}\")\n    global_config.project = project\n</code></pre>"},{"location":"reference/main/#hyfi.main.HyFI.terminate","title":"<code>terminate()</code>  <code>staticmethod</code>","text":"<p>Terminate the global config.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>None</code> <p>True if termination was successful, False otherwise.</p> Source code in <code>hyfi/main/main.py</code> <pre><code>@staticmethod\ndef terminate() -&gt; None:\n    \"\"\"\n    Terminate the global config.\n\n    Returns:\n        bool: True if termination was successful, False otherwise.\n    \"\"\"\n    global_config.terminate()\n</code></pre>"},{"location":"reference/main/#hyfi.main.HyFIConfig","title":"<code>HyFIConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>HyFI root config class.  This class is used to store the configuration</p> Source code in <code>hyfi/main/config.py</code> <pre><code>class HyFIConfig(BaseModel):\n    \"\"\"HyFI root config class.  This class is used to store the configuration\"\"\"\n\n    _config_name_: str = \"config\"\n    _config_group_: str = \"/\"\n\n    debug_mode: bool = False\n    noop: bool = False\n    dryrun: bool = False\n    resolve: bool = False\n    verbose: bool = False\n    logging_level: str = \"WARNING\"\n\n    hydra: Optional[ConfigType] = None\n\n    about: Optional[ConfigType] = None\n    copier: Optional[ConfigType] = None\n    project: Optional[ConfigType] = None\n    pipeline: Optional[ConfigType] = None\n    task: Optional[ConfigType] = None\n    variables: Optional[ConfigType] = None\n    workflow: Optional[ConfigType] = None\n    tasks: Optional[List[str]] = None\n    workflows: Optional[List[str]] = None\n\n    model_config = ConfigDict(\n        arbitrary_types_allowed=True,\n        validate_assignment=True,\n        extra=\"allow\",\n    )  # type: ignore\n\n    @field_validator(\"logging_level\")\n    def _validate_logging_level(cls, v, info: ValidationInfo):\n        \"\"\"\n        Validate and set the logging level\n        \"\"\"\n        verbose = info.data.get(\"verbose\", False)\n        # Set verbose to INFO.\n        if verbose and v == \"WARNING\":\n            v = \"INFO\"\n        logger.setLevel(v)\n        return v\n</code></pre>"},{"location":"reference/module/","title":"<code>hyfi.module</code>","text":""},{"location":"reference/module/#hyfi.module.Module","title":"<code>Module</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Module Configuration</p> Source code in <code>hyfi/module/module.py</code> <pre><code>class Module(BaseModel):\n    \"\"\"Module Configuration\"\"\"\n\n    library_dir: str = \"\"\n    modules: Optional[List[Any]] = None\n</code></pre>"},{"location":"reference/path/","title":"<code>hyfi.path</code>","text":""},{"location":"reference/pipe/","title":"<code>hyfi.pipe</code>","text":""},{"location":"reference/pipe/#hyfi.pipe.dataframe_external_funcs","title":"<code>dataframe_external_funcs(data, config)</code>","text":"<p>Applies a dataframe external function to a dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The dataframe to apply the function to.</p> required <code>config</code> <code>DataframePipeConfig</code> <p>The configuration for the pipeline.</p> required <p>Returns:</p> Type Description <p>pd.DataFrame: The dataframe with the function applied.</p> Source code in <code>hyfi/pipe/pipes.py</code> <pre><code>def dataframe_external_funcs(data: pd.DataFrame, config: DataframePipe):\n    \"\"\"\n    Applies a dataframe external function to a dataframe.\n\n    Args:\n        data (pd.DataFrame): The dataframe to apply the function to.\n        config (DataframePipeConfig): The configuration for the pipeline.\n\n    Returns:\n        pd.DataFrame: The dataframe with the function applied.\n    \"\"\"\n    config = DataframePipe(**config.model_dump())\n    _fn = config.get_run_func()\n    if _fn is None:\n        logger.warning(\"No function found for %s\", config)\n        return data\n    with elapsed_timer(format_time=True) as elapsed:\n        if config.columns:\n            for key in config.columns:\n                logger.info(\"processing column: %s\", key)\n                data[key] = (\n                    BATCHER.apply(\n                        _fn,\n                        data[key],\n                        use_batcher=config.use_batcher,\n                        num_workers=config.num_workers,\n                    )\n                    if config.use_batcher\n                    else data[key].apply(_fn)\n                )\n        elif config.use_batcher:\n            data_ = BATCHER.apply(\n                _fn,\n                data,\n                use_batcher=config.use_batcher,\n                num_workers=config.num_workers,\n            )\n            # return original data if no return value to continue pipeline\n            data = data if config.return_pipe_obj or data_ is None else data_\n        else:\n            data_arg = (\n                {config.pipe_obj_arg_name: data}\n                if config.pipe_obj_arg_name and config.use_pipe_obj\n                else {}\n            )\n            data_ = (\n                _fn(**data_arg)\n                if data_arg\n                else _fn(data) if data is not None and config.use_pipe_obj else _fn()\n            )\n            # return original data if no return value to continue pipeline\n            data = data if config.return_pipe_obj or data_ is None else data_\n        if config.verbose:\n            logger.info(\" &gt;&gt; elapsed time: %s\", elapsed())\n            print(data.head())\n    return data\n</code></pre>"},{"location":"reference/pipe/#hyfi.pipe.dataframe_instance_methods","title":"<code>dataframe_instance_methods(data, config)</code>","text":"<p>Applies a dataframe instance method to a dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The dataframe to apply the method to.</p> required <code>config</code> <code>DataframePipeConfig</code> <p>The configuration for the pipeline.</p> required <p>Returns:</p> Type Description <p>pd.DataFrame: The dataframe with the method applied.</p> Source code in <code>hyfi/pipe/pipes.py</code> <pre><code>def dataframe_instance_methods(data: pd.DataFrame, config: DataframePipe):\n    \"\"\"\n    Applies a dataframe instance method to a dataframe.\n\n    Args:\n        data (pd.DataFrame): The dataframe to apply the method to.\n        config (DataframePipeConfig): The configuration for the pipeline.\n\n    Returns:\n        pd.DataFrame: The dataframe with the method applied.\n    \"\"\"\n    config = DataframePipe(**config.model_dump())\n    run_target = config.run_target\n    run_kwargs = config.run_kwargs\n    if not run_target:\n        logger.warning(\"No target found for %s\", config)\n        return data\n    with elapsed_timer(format_time=True) as elapsed:\n        if config.columns:\n            for col_name in config.columns:\n                logger.info(\"processing column: %s\", col_name)\n                data[col_name] = getattr(data[col_name], run_target)(**run_kwargs)\n        else:\n            data = getattr(data, run_target)(**run_kwargs)\n\n        if config.verbose:\n            logger.info(\" &gt;&gt; elapsed time: %s\", elapsed())\n            print(data.head())\n    return data\n</code></pre>"},{"location":"reference/pipe/#hyfi.pipe.general_external_funcs","title":"<code>general_external_funcs(obj, config)</code>","text":"<p>Applies a general external function to an object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to apply the function to.</p> required <code>config</code> <code>PipeConfig</code> <p>The configuration for the pipeline.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>The object with the function applied.</p> Source code in <code>hyfi/pipe/pipes.py</code> <pre><code>def general_external_funcs(obj: Any, config: Pipe):\n    \"\"\"\n    Applies a general external function to an object.\n\n    Args:\n        obj (Any): The object to apply the function to.\n        config (PipeConfig): The configuration for the pipeline.\n\n    Returns:\n        Any: The object with the function applied.\n    \"\"\"\n    _fn = config.get_run_func()\n    if _fn is None:\n        logger.warning(\"No function found for %s\", config)\n        return obj\n    with elapsed_timer(format_time=True) as elapsed:\n        obj_arg = (\n            {config.pipe_obj_arg_name: obj}\n            if config.pipe_obj_arg_name and config.use_pipe_obj\n            else {}\n        )\n        obj_ = (\n            _fn(**obj_arg)\n            if obj_arg\n            else _fn(obj) if obj is not None and config.use_pipe_obj else _fn()\n        )\n        # return original data if no return value to continue pipeline\n        obj = obj if config.return_pipe_obj or obj_ is None else obj_\n        if config.verbose:\n            logger.info(\" &gt;&gt; elapsed time: %s\", elapsed())\n    return obj\n</code></pre>"},{"location":"reference/pipe/#hyfi.pipe.general_instance_methods","title":"<code>general_instance_methods(obj, config)</code>","text":"<p>Applies a general instance method to an object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to apply the method to.</p> required <code>config</code> <code>PipeConfig</code> <p>The configuration for the pipeline.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>The object with the method applied.</p> Source code in <code>hyfi/pipe/pipes.py</code> <pre><code>def general_instance_methods(obj: Any, config: Pipe):\n    \"\"\"\n    Applies a general instance method to an object.\n\n    Args:\n        obj (Any): The object to apply the method to.\n        config (PipeConfig): The configuration for the pipeline.\n\n    Returns:\n        Any: The object with the method applied.\n    \"\"\"\n    run_target = config.run_target\n    run_kwargs = config.run_kwargs\n    if not run_target:\n        logger.warning(\"No target found for %s\", config)\n        return obj\n    with elapsed_timer(format_time=True) as elapsed:\n        obj = getattr(obj, run_target)(**run_kwargs)\n\n        if config.verbose:\n            logger.info(\" &gt;&gt; elapsed time: %s\", elapsed())\n    return obj\n</code></pre>"},{"location":"reference/pipeline/","title":"<code>hyfi.pipeline</code>","text":""},{"location":"reference/pipeline/#hyfi.pipeline.BaseRun","title":"<code>BaseRun</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Run Configuration</p> Source code in <code>hyfi/pipeline/config.py</code> <pre><code>class BaseRun(BaseModel):\n    \"\"\"Run Configuration\"\"\"\n\n    run: Optional[Union[str, Dict[str, Any]]] = {}\n    verbose: bool = False\n\n    model_config = ConfigDict(\n        arbitrary_types_allowed=True,\n        extra=\"allow\",\n        validate_assignment=False,\n        alias_generator=Composer.generate_alias_for_special_keys,\n    )  # type: ignore\n\n    @model_validator(mode=\"before\")\n    def validate_model_config_before(cls, data):\n        # logger.debug(\"Validating model config before validating each field.\")\n        return Composer.replace_special_keys(Composer.to_dict(data))\n\n    @property\n    def run_config(self) -&gt; Dict[str, Any]:\n        if self.run and isinstance(self.run, str):\n            return {\"_target_\": self.run}\n        return Composer.to_dict(self.run) or {}\n\n    @property\n    def run_target(self) -&gt; str:\n        return self.run_config.get(\"_target_\") or \"\"\n\n    @property\n    def run_kwargs(self) -&gt; Dict[str, Any]:\n        _kwargs = self.run_config.copy()\n        _kwargs.pop(\"_target_\", None)\n        _kwargs.pop(\"_partial_\", None)\n        return _kwargs\n</code></pre>"},{"location":"reference/pipeline/#hyfi.pipeline.PIPELINEs","title":"<code>PIPELINEs</code>","text":"<p>A class to run a pipeline.</p> Source code in <code>hyfi/pipeline/pipeline.py</code> <pre><code>class PIPELINEs:\n    \"\"\"\n    A class to run a pipeline.\n    \"\"\"\n\n    @staticmethod\n    def run_pipeline(\n        config: Union[Dict, Pipeline],\n        initial_object: Optional[Any] = None,\n        task: Optional[Task] = None,\n    ) -&gt; Any:\n        \"\"\"\n        Run a pipeline given a config\n\n        Args:\n            config: PipelineConfig to run the pipeline\n            initial_obj: Object to use as initial value\n            task: TaskConfig to use as task\n\n        Returns:\n            The result of the pipeline\n        \"\"\"\n        if task is None:\n            task = Task()\n        return task.run_pipeline(config, initial_object)\n\n    @staticmethod\n    def run_pipe(\n        obj: Any,\n        config: Union[Dict, Pipe],\n    ) -&gt; Any:\n        \"\"\"\n        Run a pipe on an object\n\n        Args:\n            obj: The object to pipe on\n            config: The configuration for the pipe\n\n        Returns:\n            The result of the pipe\n        \"\"\"\n        return run_pipe(obj, config)\n\n    @staticmethod\n    def run_task(\n        task: Task,\n        dryrun: bool = False,\n    ):\n        \"\"\"\n        Run pipelines specified in the task\n\n        Args:\n            task: TaskConfig to run pipelines for\n            project: ProjectConfig to run pipelines\n        \"\"\"\n        if dryrun:\n            print(\"\\nDryrun is enabled, not running the HyFI task\\n\")\n            return\n        task.run()\n\n    @staticmethod\n    def run_workflow(workflow: Workflow, dryrun: bool = False):\n        \"\"\"\n        Run the tasks specified in the workflow\n\n        Args:\n            workflow: WorkflowConfig object to run\n        \"\"\"\n        if dryrun:\n            print(\"\\nDryrun is enabled, not running the HyFI workflow\\n\")\n            return\n        workflow.run()\n\n    @staticmethod\n    def pipe(**kwargs) -&gt; Pipe:\n        \"\"\"\n        Return the PipeConfig.\n\n        Args:\n            **kwargs: Additional keyword arguments to pass to the PipeConfig constructor.\n\n        Returns:\n            PipeConfig: An instance of the PipeConfig class.\n        \"\"\"\n        return Pipe(**kwargs)\n</code></pre>"},{"location":"reference/pipeline/#hyfi.pipeline.PIPELINEs.pipe","title":"<code>pipe(**kwargs)</code>  <code>staticmethod</code>","text":"<p>Return the PipeConfig.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments to pass to the PipeConfig constructor.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>PipeConfig</code> <code>Pipe</code> <p>An instance of the PipeConfig class.</p> Source code in <code>hyfi/pipeline/pipeline.py</code> <pre><code>@staticmethod\ndef pipe(**kwargs) -&gt; Pipe:\n    \"\"\"\n    Return the PipeConfig.\n\n    Args:\n        **kwargs: Additional keyword arguments to pass to the PipeConfig constructor.\n\n    Returns:\n        PipeConfig: An instance of the PipeConfig class.\n    \"\"\"\n    return Pipe(**kwargs)\n</code></pre>"},{"location":"reference/pipeline/#hyfi.pipeline.PIPELINEs.run_pipe","title":"<code>run_pipe(obj, config)</code>  <code>staticmethod</code>","text":"<p>Run a pipe on an object</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to pipe on</p> required <code>config</code> <code>Union[Dict, Pipe]</code> <p>The configuration for the pipe</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The result of the pipe</p> Source code in <code>hyfi/pipeline/pipeline.py</code> <pre><code>@staticmethod\ndef run_pipe(\n    obj: Any,\n    config: Union[Dict, Pipe],\n) -&gt; Any:\n    \"\"\"\n    Run a pipe on an object\n\n    Args:\n        obj: The object to pipe on\n        config: The configuration for the pipe\n\n    Returns:\n        The result of the pipe\n    \"\"\"\n    return run_pipe(obj, config)\n</code></pre>"},{"location":"reference/pipeline/#hyfi.pipeline.PIPELINEs.run_pipeline","title":"<code>run_pipeline(config, initial_object=None, task=None)</code>  <code>staticmethod</code>","text":"<p>Run a pipeline given a config</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Union[Dict, Pipeline]</code> <p>PipelineConfig to run the pipeline</p> required <code>initial_obj</code> <p>Object to use as initial value</p> required <code>task</code> <code>Optional[Task]</code> <p>TaskConfig to use as task</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the pipeline</p> Source code in <code>hyfi/pipeline/pipeline.py</code> <pre><code>@staticmethod\ndef run_pipeline(\n    config: Union[Dict, Pipeline],\n    initial_object: Optional[Any] = None,\n    task: Optional[Task] = None,\n) -&gt; Any:\n    \"\"\"\n    Run a pipeline given a config\n\n    Args:\n        config: PipelineConfig to run the pipeline\n        initial_obj: Object to use as initial value\n        task: TaskConfig to use as task\n\n    Returns:\n        The result of the pipeline\n    \"\"\"\n    if task is None:\n        task = Task()\n    return task.run_pipeline(config, initial_object)\n</code></pre>"},{"location":"reference/pipeline/#hyfi.pipeline.PIPELINEs.run_task","title":"<code>run_task(task, dryrun=False)</code>  <code>staticmethod</code>","text":"<p>Run pipelines specified in the task</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>TaskConfig to run pipelines for</p> required <code>project</code> <p>ProjectConfig to run pipelines</p> required Source code in <code>hyfi/pipeline/pipeline.py</code> <pre><code>@staticmethod\ndef run_task(\n    task: Task,\n    dryrun: bool = False,\n):\n    \"\"\"\n    Run pipelines specified in the task\n\n    Args:\n        task: TaskConfig to run pipelines for\n        project: ProjectConfig to run pipelines\n    \"\"\"\n    if dryrun:\n        print(\"\\nDryrun is enabled, not running the HyFI task\\n\")\n        return\n    task.run()\n</code></pre>"},{"location":"reference/pipeline/#hyfi.pipeline.PIPELINEs.run_workflow","title":"<code>run_workflow(workflow, dryrun=False)</code>  <code>staticmethod</code>","text":"<p>Run the tasks specified in the workflow</p> <p>Parameters:</p> Name Type Description Default <code>workflow</code> <code>Workflow</code> <p>WorkflowConfig object to run</p> required Source code in <code>hyfi/pipeline/pipeline.py</code> <pre><code>@staticmethod\ndef run_workflow(workflow: Workflow, dryrun: bool = False):\n    \"\"\"\n    Run the tasks specified in the workflow\n\n    Args:\n        workflow: WorkflowConfig object to run\n    \"\"\"\n    if dryrun:\n        print(\"\\nDryrun is enabled, not running the HyFI workflow\\n\")\n        return\n    workflow.run()\n</code></pre>"},{"location":"reference/pipeline/#hyfi.pipeline.Pipe","title":"<code>Pipe</code>","text":"<p>               Bases: <code>BaseRun</code></p> <p>Pipe Configuration</p> Source code in <code>hyfi/pipeline/config.py</code> <pre><code>class Pipe(BaseRun):\n    \"\"\"Pipe Configuration\"\"\"\n\n    pipe_target: str = \"\"\n    name: Optional[str] = \"\"\n    desc: Optional[str] = \"\"\n    env: Optional[Dict[str, Any]] = {}\n    use_pipe_obj: bool = True\n    pipe_obj_arg_name: Optional[str] = \"\"\n    return_pipe_obj: bool = False\n    # task: Optional[TaskConfig] = None\n\n    def set_enviroment(self):\n        if self.env:\n            ENVs.check_and_set_osenv_vars(self.env)\n\n    def get_pipe_func(self) -&gt; Optional[Callable]:\n        if self.pipe_target.startswith(\"lambda\"):\n            raise NotImplementedError(\"Lambda functions are not supported. (dangerous)\")\n            # return eval(self.pipe_target)\n        elif self.pipe_target:\n            return Composer.partial(self.pipe_target)\n        else:\n            return None\n\n    def get_run_func(self) -&gt; Optional[Callable]:\n        run_cfg = self.run_config\n        run_target = self.run_target\n        if run_target and run_target.startswith(\"lambda\"):\n            raise NotImplementedError(\"Lambda functions are not supported. (dangerous)\")\n            # return eval(run_target)\n        elif run_cfg:\n            if self.pipe_obj_arg_name:\n                run_cfg.pop(self.pipe_obj_arg_name)\n            logger.info(\n                \"Returning partial function: %s with kwargs: %s\", run_target, run_cfg\n            )\n            return Composer.partial(run_cfg)\n        else:\n            logger.warning(\"No function found for %s\", self)\n            return None\n</code></pre>"},{"location":"reference/pipeline/#hyfi.pipeline.Pipeline","title":"<code>Pipeline</code>","text":"<p>               Bases: <code>BaseRun</code></p> <p>Pipeline Configuration</p> Source code in <code>hyfi/pipeline/config.py</code> <pre><code>class Pipeline(BaseRun):\n    \"\"\"Pipeline Configuration\"\"\"\n\n    name: Optional[str] = \"\"\n    steps: Optional[List[Union[str, Dict]]] = []\n    initial_object: Optional[Any] = None\n    use_task_as_initial_object: bool = False\n\n    @field_validator(\"steps\", mode=\"before\")\n    def steps_to_list(cls, v):\n        \"\"\"\n        Convert a list of steps to a list\n\n        Args:\n            cls: class to use for conversion\n            v: list of steps to convert\n\n        Returns:\n            list of steps converted to\n        \"\"\"\n        return [v] if isinstance(v, str) else Composer.to_dict(v)\n\n    def update_configs(\n        self,\n        rc: Union[Dict, Running],\n    ):\n        \"\"\"\n        Update running config with values from another config\n\n        Args:\n            rc: RunningConfig to update from\n        \"\"\"\n        # If rc is a dict or dict it will be converted to RunningConfig.\n        if isinstance(rc, dict):\n            rc = Running(**rc)\n        self.name = rc.name or self.name\n        self.desc = rc.desc or self.desc\n\n    def get_pipes(self) -&gt; Pipes:\n        \"\"\"\n        Get all pipes that this task is aware of\n\n        Args:\n            task: The task to use for the pipe\n\n        Returns:\n            A list of : class : `PipeConfig` objects\n        \"\"\"\n        pipes: Pipes = []\n        self.steps = self.steps or []\n        # Add pipes to the pipeline.\n        for rc in get_running_configs(self.steps):\n            # Add a pipe to the pipeline.\n            config = getattr(self, rc.uses, None)\n            if isinstance(config, dict):\n                pipe = Pipe(**Composer.update(config, rc.model_dump()))\n                # Set the task to be used for the pipe.\n                # if task is not None:\n                #     pipe.task = task\n                pipes.append(pipe)\n        return pipes\n</code></pre>"},{"location":"reference/pipeline/#hyfi.pipeline.Pipeline.get_pipes","title":"<code>get_pipes()</code>","text":"<p>Get all pipes that this task is aware of</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <p>The task to use for the pipe</p> required <p>Returns:</p> Type Description <code>Pipes</code> <p>A list of : class : <code>PipeConfig</code> objects</p> Source code in <code>hyfi/pipeline/config.py</code> <pre><code>def get_pipes(self) -&gt; Pipes:\n    \"\"\"\n    Get all pipes that this task is aware of\n\n    Args:\n        task: The task to use for the pipe\n\n    Returns:\n        A list of : class : `PipeConfig` objects\n    \"\"\"\n    pipes: Pipes = []\n    self.steps = self.steps or []\n    # Add pipes to the pipeline.\n    for rc in get_running_configs(self.steps):\n        # Add a pipe to the pipeline.\n        config = getattr(self, rc.uses, None)\n        if isinstance(config, dict):\n            pipe = Pipe(**Composer.update(config, rc.model_dump()))\n            # Set the task to be used for the pipe.\n            # if task is not None:\n            #     pipe.task = task\n            pipes.append(pipe)\n    return pipes\n</code></pre>"},{"location":"reference/pipeline/#hyfi.pipeline.Pipeline.steps_to_list","title":"<code>steps_to_list(v)</code>","text":"<p>Convert a list of steps to a list</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <p>class to use for conversion</p> required <code>v</code> <p>list of steps to convert</p> required <p>Returns:</p> Type Description <p>list of steps converted to</p> Source code in <code>hyfi/pipeline/config.py</code> <pre><code>@field_validator(\"steps\", mode=\"before\")\ndef steps_to_list(cls, v):\n    \"\"\"\n    Convert a list of steps to a list\n\n    Args:\n        cls: class to use for conversion\n        v: list of steps to convert\n\n    Returns:\n        list of steps converted to\n    \"\"\"\n    return [v] if isinstance(v, str) else Composer.to_dict(v)\n</code></pre>"},{"location":"reference/pipeline/#hyfi.pipeline.Pipeline.update_configs","title":"<code>update_configs(rc)</code>","text":"<p>Update running config with values from another config</p> <p>Parameters:</p> Name Type Description Default <code>rc</code> <code>Union[Dict, Running]</code> <p>RunningConfig to update from</p> required Source code in <code>hyfi/pipeline/config.py</code> <pre><code>def update_configs(\n    self,\n    rc: Union[Dict, Running],\n):\n    \"\"\"\n    Update running config with values from another config\n\n    Args:\n        rc: RunningConfig to update from\n    \"\"\"\n    # If rc is a dict or dict it will be converted to RunningConfig.\n    if isinstance(rc, dict):\n        rc = Running(**rc)\n    self.name = rc.name or self.name\n    self.desc = rc.desc or self.desc\n</code></pre>"},{"location":"reference/pipeline/#hyfi.pipeline.Running","title":"<code>Running</code>","text":"<p>               Bases: <code>BaseRun</code></p> <p>Running Configuration</p> Source code in <code>hyfi/pipeline/config.py</code> <pre><code>class Running(BaseRun):\n    \"\"\"Running Configuration\"\"\"\n\n    uses: str = \"\"\n</code></pre>"},{"location":"reference/project/","title":"<code>hyfi.project</code>","text":""},{"location":"reference/project/#hyfi.project.Project","title":"<code>Project</code>","text":"<p>               Bases: <code>BaseConfig</code>, <code>Composer</code></p> <p>Project Config</p> Source code in <code>hyfi/project/project.py</code> <pre><code>class Project(BaseConfig, Composer):\n    \"\"\"Project Config\"\"\"\n\n    _config_name_: str = \"__init__\"\n    _config_group_: str = \"/project\"\n    # Project Config\n    project_name: str = \"hyfi\"\n    project_description: Optional[str] = None\n    project_root: str = \".\"\n    project_workspace_name: str = \"workspace\"\n    global_hyfi_root: str = \".\"\n    global_workspace_name: str = \".hyfi\"\n    num_workers: int = 1\n    use_huggingface_hub: bool = False\n    use_wandb: bool = False\n    verbose: Union[bool, int] = False\n    # Config Classes\n    env: ProjectEnv = None\n    joblib: Optional[JobLib] = None\n    path: ProjectPath = None\n\n    _property_set_methods_ = {\n        \"project_name\": \"set_project_name\",\n        \"project_root\": \"set_project_root\",\n    }\n\n    def set_project_root(self, val: Union[str, Path]):\n        if not self.project_root or self.project_root != val:\n            self.path.project_root = str(val)\n\n    def set_project_name(self, val):\n        if not self.project_name or self.project_name != val:\n            self.path.project_name = val\n\n    @field_validator(\"project_name\")\n    def _validate_project_name(cls, v):\n        if v is None:\n            raise ValueError(\"Project name must be specified.\")\n        return v\n\n    @field_validator(\"verbose\")\n    def _validate_verbose(cls, v):\n        if isinstance(v, str):\n            if v.lower() in {\"true\", \"1\"}:\n                v = True\n            elif v.lower() in {\"false\", \"0\"}:\n                v = False\n            else:\n                raise ValueError(\"verbose must be a boolean or a string of 0 or 1\")\n        return v\n\n    def __init__(self, **config_kwargs):\n        super().__init__(**config_kwargs)\n        self.initialize()\n\n    def initialize(self):\n        logger.debug(\"Initializing Project Config: %s\", self.project_name)\n        self.env = ProjectEnv()\n\n        self.env.HYFI_PROJECT_NAME = self.project_name\n        if self.project_description:\n            self.env.HYFI_PROJECT_DESC = self.project_description\n        if self.project_root:\n            self.env.HYFI_PROJECT_ROOT = self.project_root\n        if self.project_workspace_name:\n            self.env.HYFI_PROJECT_WORKSPACE_NAME = self.project_workspace_name\n        if self.global_hyfi_root:\n            self.env.HYFI_GLOBAL_ROOT = self.global_hyfi_root\n        if self.global_workspace_name:\n            self.env.HYFI_GLOBAL_WORKSPACE_NAME = self.global_workspace_name\n        if self.num_workers:\n            self.env.HYFI_NUM_WORKERS = self.num_workers\n        self.env.HYFI_VERBOSE = self.verbose\n\n        if self.joblib:\n            self.joblib.init_backend()\n        else:\n            logger.warning(\"JoblibConfig not initialized\")\n\n        self.init_wandb()\n        if self.use_huggingface_hub:\n            self.init_huggingface_hub()\n\n    def init_wandb(self):\n        if self.path is None:\n            raise ValueError(\"Path object not initialized\")\n        if self.env is None:\n            raise ValueError(\"Env object not initialized\")\n\n        if not self.use_wandb:\n            return\n        try:\n            self._init_wandb()\n        except ImportError:\n            logger.warning(\"wandb is not installed, please install it to use wandb.\")\n\n    def _init_wandb(self):\n        import wandb  # type: ignore\n\n        self.env.WANDB_DIR = str(self.path.log_dir)\n        project_name = self.project_name.replace(\"/\", \"-\").replace(\"\\\\\", \"-\")\n        self.env.WANDB_PROJECT = project_name\n        notebook_name = self.path.log_dir / f\"{project_name}-nb\"\n        notebook_name.mkdir(parents=True, exist_ok=True)\n        self.env.WANDB_NOTEBOOK_NAME = str(notebook_name)\n        self.env.WANDB_SILENT = str(not self.verbose)\n\n        wandb.init(project=project_name)\n\n    def init_huggingface_hub(self):\n        \"\"\"Initialize huggingface_hub\"\"\"\n        try:\n            from huggingface_hub import notebook_login  # type: ignore\n            from huggingface_hub.hf_api import HfFolder  # type: ignore\n        except ImportError:\n            logger.warning(\n                \"huggingface_hub is not installed, please install it to use huggingface_hub.\"\n            )\n            return\n\n        self.env = ProjectEnv()\n        if (\n            self.env.HUGGING_FACE_HUB_TOKEN is None\n            and self.env.HF_USER_ACCESS_TOKEN is not None\n        ):\n            self.env.HUGGING_FACE_HUB_TOKEN = self.env.HF_USER_ACCESS_TOKEN\n\n        local_token = HfFolder.get_token()\n        if local_token is None:\n            if Project.is_notebook():\n                notebook_login()\n            else:\n                logger.info(\n                    \"huggingface_hub.notebook_login() is only available in notebook,\"\n                    \"set HUGGING_FACE_HUB_TOKEN manually\"\n                )\n\n    @property\n    def osenv(self):\n        return os.environ\n\n    @property\n    def root_dir(self) -&gt; Path:\n        self.path.project_root = self.project_root\n        return self.path.root_dir\n\n    @property\n    def workspace_dir(self) -&gt; Path:\n        self.path.project_workspace_name = self.project_workspace_name\n        return self.path.workspace_dir\n\n    @property\n    def global_root_dir(self) -&gt; Path:\n        self.path.global_hyfi_root = self.global_hyfi_root\n        return self.path.global_root_dir\n\n    @property\n    def global_workspace_dir(self) -&gt; Path:\n        self.path.global_workspace_name = self.global_workspace_name\n        return self.path.global_workspace_dir\n\n    def get_path(\n        self,\n        path_name: str,\n        base_dir: Optional[Union[Path, str]] = None,\n        ensure_exists: bool = False,\n    ) -&gt; Optional[Path]:\n        \"\"\"\n        Get the path to a directory or file.\n        \"\"\"\n        return (\n            self.path.get_path(\n                path_name, base_dir=base_dir, ensure_exists=ensure_exists\n            )\n            if self.path\n            else None\n        )\n</code></pre>"},{"location":"reference/project/#hyfi.project.Project.get_path","title":"<code>get_path(path_name, base_dir=None, ensure_exists=False)</code>","text":"<p>Get the path to a directory or file.</p> Source code in <code>hyfi/project/project.py</code> <pre><code>def get_path(\n    self,\n    path_name: str,\n    base_dir: Optional[Union[Path, str]] = None,\n    ensure_exists: bool = False,\n) -&gt; Optional[Path]:\n    \"\"\"\n    Get the path to a directory or file.\n    \"\"\"\n    return (\n        self.path.get_path(\n            path_name, base_dir=base_dir, ensure_exists=ensure_exists\n        )\n        if self.path\n        else None\n    )\n</code></pre>"},{"location":"reference/project/#hyfi.project.Project.init_huggingface_hub","title":"<code>init_huggingface_hub()</code>","text":"<p>Initialize huggingface_hub</p> Source code in <code>hyfi/project/project.py</code> <pre><code>def init_huggingface_hub(self):\n    \"\"\"Initialize huggingface_hub\"\"\"\n    try:\n        from huggingface_hub import notebook_login  # type: ignore\n        from huggingface_hub.hf_api import HfFolder  # type: ignore\n    except ImportError:\n        logger.warning(\n            \"huggingface_hub is not installed, please install it to use huggingface_hub.\"\n        )\n        return\n\n    self.env = ProjectEnv()\n    if (\n        self.env.HUGGING_FACE_HUB_TOKEN is None\n        and self.env.HF_USER_ACCESS_TOKEN is not None\n    ):\n        self.env.HUGGING_FACE_HUB_TOKEN = self.env.HF_USER_ACCESS_TOKEN\n\n    local_token = HfFolder.get_token()\n    if local_token is None:\n        if Project.is_notebook():\n            notebook_login()\n        else:\n            logger.info(\n                \"huggingface_hub.notebook_login() is only available in notebook,\"\n                \"set HUGGING_FACE_HUB_TOKEN manually\"\n            )\n</code></pre>"},{"location":"reference/project/#hyfi.project.ProjectPath","title":"<code>ProjectPath</code>","text":"<p>               Bases: <code>BasePath</code></p> Source code in <code>hyfi/path/project.py</code> <pre><code>class ProjectPath(BasePath):\n    _config_name_: str = \"__project__\"\n\n    # internal paths for hyfi\n    home: str\n    hyfi: str\n    resources: str\n    runtime: str\n    # global paths\n    global_hyfi_root: str = \".\"\n    global_workspace_name: str = \".hyfi\"\n    # project specific paths\n    project_name: str\n    project_root: str = \".\"\n    project_workspace_name: str = \"workspace\"\n\n    @property\n    def home_dir(self) -&gt; Path:\n        \"\"\"\n        Return the path to the home directory.\n\n        Returns:\n            path to the home directory\n        \"\"\"\n        return Path(self.home).absolute() if self.home else Path.home()\n\n    @property\n    def global_root_dir(self) -&gt; Path:\n        \"\"\"\n        Create and return the path to the hyfi directory.\n\n        Returns:\n            path to the hyfi directory\n        \"\"\"\n        path_ = Path(self.global_hyfi_root)\n        if not path_.is_absolute():\n            path_ = self.home_dir / path_\n        return path_\n\n    @property\n    def global_workspace_dir(self) -&gt; Path:\n        \"\"\"\n        Create and return the path to the glboal workspace directory.\n\n        Returns:\n            path to the global workspace directory\n        \"\"\"\n        return self.global_root_dir / self.global_workspace_name\n\n    @property\n    def global_archive_dir(self) -&gt; Path:\n        \"\"\"\n        Create and return the path to the global archive directory.\n\n        Returns:\n            path to the global archive directory\n        \"\"\"\n        return self.get_path(\"archives\", self.global_workspace_dir)\n\n    @property\n    def glboal_dataset_dir(self) -&gt; Path:\n        \"\"\"\n        Create and return the path to the global datasets directory.\n\n        Returns:\n            path to the global datasets directory\n        \"\"\"\n        return self.get_path(\"datasets\", self.global_workspace_dir)\n\n    @property\n    def global_model_dir(self) -&gt; Path:\n        \"\"\"\n        Create and return the path to the global models directory.\n\n        Returns:\n            path to the global models directory\n        \"\"\"\n        return self.get_path(\"models\", self.global_workspace_dir)\n\n    @property\n    def glboal_module_dir(self) -&gt; Path:\n        \"\"\"\n        Create and return the path to the global modules directory.\n\n        Returns:\n            path to the global modules directory\n        \"\"\"\n        return self.get_path(\"modules\", self.global_workspace_dir)\n\n    @property\n    def global_library_dir(self) -&gt; Path:\n        \"\"\"\n        Create and return the path to the global library directory.\n\n        Returns:\n            path to the global library directory\n        \"\"\"\n        return self.get_path(\"library\", self.global_workspace_dir)\n\n    @property\n    def glboal_log_dir(self) -&gt; Path:\n        \"\"\"\n        Create and return the path to the global log directory.\n\n        Returns:\n            path to the global log directory\n        \"\"\"\n        return self.get_path(\"logs\", self.global_workspace_dir)\n\n    @property\n    def global_cache_dir(self) -&gt; Path:\n        \"\"\"\n        Create and return the path to the global cache directory.\n\n        Returns:\n            path to the global cache directory\n        \"\"\"\n        return self.get_path(\"cache\", self.global_workspace_dir)\n\n    @property\n    def global_tmp_dir(self) -&gt; Path:\n        \"\"\"\n        Create and return the path to the global tmp directory.\n\n        Returns:\n            path to the global tmp directory\n        \"\"\"\n        return self.get_path(\"tmp\", self.global_workspace_dir)\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Returns the name of the path configuration.\n        \"\"\"\n        return self.project_name\n\n    @property\n    def root_dir(self) -&gt; Path:\n        \"\"\"\n        Create and return the path to the project directory.\n\n        Returns:\n            path to the project directory\n        \"\"\"\n        path_ = Path(self.project_root)\n        return path_.absolute()\n\n    @property\n    def workspace_dir(self) -&gt; Path:\n        \"\"\"\n        Create and return the path to the project workspace directory.\n\n        Returns:\n            path to the project workspace directory\n        \"\"\"\n        return self.root_dir / self.project_workspace_name\n</code></pre>"},{"location":"reference/project/#hyfi.project.ProjectPath.glboal_dataset_dir","title":"<code>glboal_dataset_dir: Path</code>  <code>property</code>","text":"<p>Create and return the path to the global datasets directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>path to the global datasets directory</p>"},{"location":"reference/project/#hyfi.project.ProjectPath.glboal_log_dir","title":"<code>glboal_log_dir: Path</code>  <code>property</code>","text":"<p>Create and return the path to the global log directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>path to the global log directory</p>"},{"location":"reference/project/#hyfi.project.ProjectPath.glboal_module_dir","title":"<code>glboal_module_dir: Path</code>  <code>property</code>","text":"<p>Create and return the path to the global modules directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>path to the global modules directory</p>"},{"location":"reference/project/#hyfi.project.ProjectPath.global_archive_dir","title":"<code>global_archive_dir: Path</code>  <code>property</code>","text":"<p>Create and return the path to the global archive directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>path to the global archive directory</p>"},{"location":"reference/project/#hyfi.project.ProjectPath.global_cache_dir","title":"<code>global_cache_dir: Path</code>  <code>property</code>","text":"<p>Create and return the path to the global cache directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>path to the global cache directory</p>"},{"location":"reference/project/#hyfi.project.ProjectPath.global_library_dir","title":"<code>global_library_dir: Path</code>  <code>property</code>","text":"<p>Create and return the path to the global library directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>path to the global library directory</p>"},{"location":"reference/project/#hyfi.project.ProjectPath.global_model_dir","title":"<code>global_model_dir: Path</code>  <code>property</code>","text":"<p>Create and return the path to the global models directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>path to the global models directory</p>"},{"location":"reference/project/#hyfi.project.ProjectPath.global_root_dir","title":"<code>global_root_dir: Path</code>  <code>property</code>","text":"<p>Create and return the path to the hyfi directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>path to the hyfi directory</p>"},{"location":"reference/project/#hyfi.project.ProjectPath.global_tmp_dir","title":"<code>global_tmp_dir: Path</code>  <code>property</code>","text":"<p>Create and return the path to the global tmp directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>path to the global tmp directory</p>"},{"location":"reference/project/#hyfi.project.ProjectPath.global_workspace_dir","title":"<code>global_workspace_dir: Path</code>  <code>property</code>","text":"<p>Create and return the path to the glboal workspace directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>path to the global workspace directory</p>"},{"location":"reference/project/#hyfi.project.ProjectPath.home_dir","title":"<code>home_dir: Path</code>  <code>property</code>","text":"<p>Return the path to the home directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>path to the home directory</p>"},{"location":"reference/project/#hyfi.project.ProjectPath.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns the name of the path configuration.</p>"},{"location":"reference/project/#hyfi.project.ProjectPath.root_dir","title":"<code>root_dir: Path</code>  <code>property</code>","text":"<p>Create and return the path to the project directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>path to the project directory</p>"},{"location":"reference/project/#hyfi.project.ProjectPath.workspace_dir","title":"<code>workspace_dir: Path</code>  <code>property</code>","text":"<p>Create and return the path to the project workspace directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>path to the project workspace directory</p>"},{"location":"reference/run/","title":"<code>hyfi.run</code>","text":""},{"location":"reference/run/#hyfi.run.Run","title":"<code>Run</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Run Configuration</p> Source code in <code>hyfi/run/run.py</code> <pre><code>class Run(BaseModel):\n    \"\"\"Run Configuration\"\"\"\n\n    _config_group_: str = \"/run\"\n    _auto_populate_ = True\n    _target_: Optional[str] = None\n    _partial_: bool = True\n\n    @property\n    def config(self) -&gt; Dict[str, Any]:\n        return {\n            k: v\n            for k, v in self.model_extra.items()\n            if not k.startswith(\"_\") or k in [\"_target_\", \"_partial_\"]\n        }\n\n    @property\n    def kwargs(self) -&gt; Dict[str, Any]:\n        return {k: v for k, v in self.model_extra.items() if not k.startswith(\"_\")}\n\n    @property\n    def target(self) -&gt; str:\n        return self._target_\n\n    def generate_config(\n        self,\n        config_name: Optional[str] = None,\n        config_path: str = None,\n        config_root: Optional[str] = None,\n        save: bool = True,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Saves a HyFI config for itself.\n\n        Args:\n            config_name (Optional[str]): The name of the config. If not provided, the name of the target will be used.\n            config_path (Optional[str]): The path to save the config to (relative to the config root). Defaults to \"run\".\n            config_root (Optional[str]): The root of the config path. If not provided, the global hyfi config directory will be used.\n            **kwargs_for_target: Keyword arguments to pass to the target.\n        \"\"\"\n        # if self.target is None:\n        #     raise ValueError(\"Cannot generate config for RunConfig without a target.\")\n\n        cfg = self.sanitized_config(self.config)\n\n        if not save:\n            return cfg\n\n        config_name = config_name or self._config_name_ or self._target_.split(\".\")[-1]\n        filename = f\"{config_name}.yaml\"\n        config_root = config_root or global_hyfi.config_root\n        _config_group_ = self._config_group_\n        if _config_group_ and _config_group_.startswith(\"/\"):\n            _config_group_ = _config_group_[1:]\n        config_path = config_path or _config_group_ or \"test\"\n        config_path = Path(config_root) / config_path\n        config_path.mkdir(parents=True, exist_ok=True)\n        config_path /= filename\n        Composer.save(cfg, config_path)\n        logger.info(\"Saved HyFI config for %s to %s.\", self._target_, config_path)\n        return cfg\n</code></pre>"},{"location":"reference/run/#hyfi.run.Run.generate_config","title":"<code>generate_config(config_name=None, config_path=None, config_root=None, save=True)</code>","text":"<p>Saves a HyFI config for itself.</p> <p>Parameters:</p> Name Type Description Default <code>config_name</code> <code>Optional[str]</code> <p>The name of the config. If not provided, the name of the target will be used.</p> <code>None</code> <code>config_path</code> <code>Optional[str]</code> <p>The path to save the config to (relative to the config root). Defaults to \"run\".</p> <code>None</code> <code>config_root</code> <code>Optional[str]</code> <p>The root of the config path. If not provided, the global hyfi config directory will be used.</p> <code>None</code> <code>**kwargs_for_target</code> <p>Keyword arguments to pass to the target.</p> required Source code in <code>hyfi/run/run.py</code> <pre><code>def generate_config(\n    self,\n    config_name: Optional[str] = None,\n    config_path: str = None,\n    config_root: Optional[str] = None,\n    save: bool = True,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Saves a HyFI config for itself.\n\n    Args:\n        config_name (Optional[str]): The name of the config. If not provided, the name of the target will be used.\n        config_path (Optional[str]): The path to save the config to (relative to the config root). Defaults to \"run\".\n        config_root (Optional[str]): The root of the config path. If not provided, the global hyfi config directory will be used.\n        **kwargs_for_target: Keyword arguments to pass to the target.\n    \"\"\"\n    # if self.target is None:\n    #     raise ValueError(\"Cannot generate config for RunConfig without a target.\")\n\n    cfg = self.sanitized_config(self.config)\n\n    if not save:\n        return cfg\n\n    config_name = config_name or self._config_name_ or self._target_.split(\".\")[-1]\n    filename = f\"{config_name}.yaml\"\n    config_root = config_root or global_hyfi.config_root\n    _config_group_ = self._config_group_\n    if _config_group_ and _config_group_.startswith(\"/\"):\n        _config_group_ = _config_group_[1:]\n    config_path = config_path or _config_group_ or \"test\"\n    config_path = Path(config_root) / config_path\n    config_path.mkdir(parents=True, exist_ok=True)\n    config_path /= filename\n    Composer.save(cfg, config_path)\n    logger.info(\"Saved HyFI config for %s to %s.\", self._target_, config_path)\n    return cfg\n</code></pre>"},{"location":"reference/runner/","title":"<code>hyfi.runner</code>","text":""},{"location":"reference/runner/#hyfi.runner.Runner","title":"<code>Runner</code>","text":"<p>               Bases: <code>BatchTask</code></p> Source code in <code>hyfi/runner/base.py</code> <pre><code>class Runner(BatchTask):\n    _config_group_: str = \"/runner\"\n    _config_name_: str = \"__init__\"\n\n    calls: Optional[List[Union[str, Dict]]] = []\n\n    def __call__(self) -&gt; None:\n        self.run()\n\n    def run(self):\n        self.run_calls()\n\n    def get_running_calls(self) -&gt; RunningCalls:\n        return get_running_configs(self.calls or [])\n\n    def run_call(self, rc: Running) -&gt; None:\n        method_ = getattr(self, rc.uses, None)\n        if method_ and callable(method_):\n            method_(**rc.run_kwargs)\n\n    def run_calls(self):\n        \"\"\"\n        Run the calls specified in the runner\n        \"\"\"\n        calls = self.get_running_calls()\n        if self.verbose:\n            logger.info(\"Running %s call(s)\", len(calls))\n        # Run all calls in the runner\n        with elapsed_timer(format_time=True) as elapsed:\n            for rc in calls:\n                logger.info(\"Running call [%s] with [%s]\", rc.uses, rc.run_kwargs)\n                self.run_call(rc)\n            if self.verbose:\n                logger.info(\n                    \" &gt;&gt; elapsed time for the runner with %s calls: %s\",\n                    len(self.calls or []),\n                    elapsed(),\n                )\n</code></pre>"},{"location":"reference/runner/#hyfi.runner.Runner.run_calls","title":"<code>run_calls()</code>","text":"<p>Run the calls specified in the runner</p> Source code in <code>hyfi/runner/base.py</code> <pre><code>def run_calls(self):\n    \"\"\"\n    Run the calls specified in the runner\n    \"\"\"\n    calls = self.get_running_calls()\n    if self.verbose:\n        logger.info(\"Running %s call(s)\", len(calls))\n    # Run all calls in the runner\n    with elapsed_timer(format_time=True) as elapsed:\n        for rc in calls:\n            logger.info(\"Running call [%s] with [%s]\", rc.uses, rc.run_kwargs)\n            self.run_call(rc)\n        if self.verbose:\n            logger.info(\n                \" &gt;&gt; elapsed time for the runner with %s calls: %s\",\n                len(self.calls or []),\n                elapsed(),\n            )\n</code></pre>"},{"location":"reference/task/","title":"<code>hyfi.task</code>","text":""},{"location":"reference/task/#hyfi.task.BatchPath","title":"<code>BatchPath</code>","text":"<p>               Bases: <code>TaskPath</code></p> Source code in <code>hyfi/path/batch.py</code> <pre><code>class BatchPath(TaskPath):\n    _config_name_: str = \"__batch__\"\n\n    batch_name: str = \"demo-batch\"\n\n    @property\n    def batch_dir(self) -&gt; Path:\n        \"\"\"\n        Returns the path to the batch directory.\n        \"\"\"\n        return self.task_dir / self.batch_name\n\n    @property\n    def workspace_dir(self) -&gt; Path:\n        \"\"\"\n        Returns the path to the task root directory.\n\n        Returns:\n            an path to the task root directory or None if it doesn't exist or cannot be converted to a path object\n        \"\"\"\n        return self.batch_dir\n</code></pre>"},{"location":"reference/task/#hyfi.task.BatchPath.batch_dir","title":"<code>batch_dir: Path</code>  <code>property</code>","text":"<p>Returns the path to the batch directory.</p>"},{"location":"reference/task/#hyfi.task.BatchPath.workspace_dir","title":"<code>workspace_dir: Path</code>  <code>property</code>","text":"<p>Returns the path to the task root directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>an path to the task root directory or None if it doesn't exist or cannot be converted to a path object</p>"},{"location":"reference/task/#hyfi.task.BatchTask","title":"<code>BatchTask</code>","text":"<p>               Bases: <code>Task</code></p> <p>Configuration class for batch tasks. Inherits from TaskConfig.</p> <p>Attributes:</p> Name Type Description <code>_config_name_</code> <code>str</code> <p>The name of the configuration.</p> <code>_config_group_</code> <code>str</code> <p>The configuration group.</p> <code>batch_name</code> <code>str</code> <p>The name of the batch.</p> <code>batch</code> <code>BatchConfig</code> <p>The batch configuration.</p> <code>_property_set_methods_</code> <code>Dict[str, str]</code> <p>A dictionary of property set methods.</p> Source code in <code>hyfi/task/batch.py</code> <pre><code>class BatchTask(Task):\n    \"\"\"\n    Configuration class for batch tasks. Inherits from TaskConfig.\n\n    Attributes:\n        _config_name_ (str): The name of the configuration.\n        _config_group_ (str): The configuration group.\n        batch_name (str): The name of the batch.\n        batch (BatchConfig): The batch configuration.\n        _property_set_methods_ (Dict[str, str]): A dictionary of property set methods.\n    \"\"\"\n\n    _config_name_: str = \"__batch__\"\n\n    batch_name: str = \"demo\"\n    batch: Batch = Batch()\n    path: BatchPath = BatchPath()\n\n    _property_set_methods_ = {\n        \"task_name\": \"set_task_name\",\n        \"task_root\": \"set_task_root\",\n        \"batch_name\": \"set_batch_name\",\n    }\n    # _subconfigs_ = {\"batch\": BatchConfig}\n\n    def set_batch_name(self, val: str):\n        if not val:\n            raise ValueError(\"Batch name cannot be empty\")\n        if not self.batch_name or self.batch_name != val:\n            self.path.batch_name = val\n            self.batch.batch_name = val\n\n    def set_batch_num(self, val: Optional[int] = None):\n        self.batch.batch_num = val\n\n    def set_task_name(self, val: str):\n        if not val:\n            raise ValueError(\"Task name cannot be empty\")\n        if not self.task_name or self.task_name != val:\n            self.path.task_name = val\n            self.batch.batch_root = str(self.output_dir)\n\n    def set_task_root(self, val: Union[str, Path]):\n        if not val:\n            raise ValueError(\"Task root cannot be empty\")\n        if not self.task_root or self.task_root != val:\n            self.path.task_root = str(val)\n            self.batch.batch_root = str(self.path.task_dir)\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        # At init, set the batch root to the task root\n        # Othertimes, the batch root is set to the task root when the task root is set\n        self.batch.batch_root = str(self.path.task_dir)\n        # Call set_batch_num to set the batch_num and batch_id correctly after init\n        if self.batch.batch_num_auto:\n            self.batch.set_batch_num()\n        logger.info(\n            \"Initalized batch: %s(%s) in %s\",\n            self.batch_name,\n            self.batch_num,\n            self.batch_dir,\n        )\n\n    @property\n    def batch_num(self) -&gt; int:\n        return self.batch.batch_num\n\n    @batch_num.setter\n    def batch_num(self, val: Optional[int]):\n        self.set_batch_num(val)\n\n    @property\n    def batch_id(self) -&gt; str:\n        return self.batch.batch_id\n\n    @property\n    def seed(self) -&gt; int:\n        return self.batch.seed\n\n    @property\n    def batch_dir(self) -&gt; Path:\n        return self.batch.batch_dir\n\n    @property\n    def device(self) -&gt; str:\n        return self.batch.device\n\n    @property\n    def num_devices(self) -&gt; int:\n        return self.batch.num_devices\n\n    def save_config(\n        self,\n        filepath: Optional[Union[str, Path]] = None,\n        exclude: Optional[Union[str, List[str], Set[str], None]] = None,\n        exclude_none: bool = True,\n        only_include: Optional[Union[str, List[str], Set[str], None]] = None,\n        save_as_json_as_well: bool = True,\n    ) -&gt; str:\n        \"\"\"\n        Save the batch configuration to file.\n\n        Args:\n            filepath (Optional[Union[str, Path]]): The filepath to save the configuration to. Defaults to None.\n            exclude (Optional[Union[str, List[str], Set[str], None]]): Keys to exclude from the saved configuration.\n                Defaults to None.\n            exclude_none (bool): Whether to exclude keys with None values from the saved configuration. Defaults to True.\n            only_include (Optional[Union[str, List[str], Set[str], None]]): Keys to include in the saved configuration.\n                Defaults to None.\n            save_as_json_as_well (bool): Whether to save the configuration as a json file as well. Defaults to True.\n\n        Returns:\n            str: The filename of the saved configuration.\n        \"\"\"\n        if not self.batch:\n            raise ValueError(\"No batch configuration to save\")\n        if not filepath:\n            filepath = self.batch.config_filepath\n\n        if save_as_json_as_well:\n            self.save_config_as_json(\n                exclude=exclude,\n                exclude_none=exclude_none,\n                only_include=only_include,\n            )\n        return super().save_config(\n            filepath=filepath,\n            exclude=exclude,\n            exclude_none=exclude_none,\n            only_include=only_include,\n        )\n\n    def save_config_as_json(\n        self,\n        filepath: Optional[Union[str, Path]] = None,\n        exclude: Optional[Union[str, List[str], Set[str], None]] = None,\n        exclude_none: bool = True,\n        only_include: Optional[Union[str, List[str], Set[str], None]] = None,\n    ) -&gt; str:\n        if not self.batch:\n            raise ValueError(\"No batch configuration to save\")\n        if not filepath:\n            filepath = self.batch.config_jsonpath\n        return super().save_config_as_json(\n            filepath=filepath,\n            exclude=exclude,\n            exclude_none=exclude_none,\n            only_include=only_include,\n        )\n\n    def load_config(\n        self,\n        batch_name: Optional[str] = None,\n        batch_num: Optional[int] = None,\n        filepath: Optional[Union[str, Path]] = None,\n        **config_kwargs,\n    ) -&gt; Dict:\n        \"\"\"Load the config from the batch config file\"\"\"\n        if not self.batch:\n            raise ValueError(\"No batch configuration to load\")\n        if not batch_name:\n            batch_name = self.batch_name\n        if batch_num is None:\n            batch_num = -1\n        if not filepath and batch_num &gt;= 0:\n            batch = Batch(\n                batch_root=self.batch.batch_root,\n                batch_name=batch_name,\n                batch_num=batch_num,\n            )\n            filepath = batch.config_filepath\n        if isinstance(filepath, str):\n            filepath = Path(filepath)\n\n        if self.verbose:\n            logger.info(\n                \"&gt; Loading config for batch_name: %s batch_num: %s\",\n                batch_name,\n                batch_num,\n            )\n        cfg = self.export_config()\n        if filepath:\n            if filepath.is_file():\n                logger.info(\"Loading config from %s\", filepath)\n                batch_cfg = Composer.load(filepath)\n                logger.info(\"Merging config with the loaded config\")\n                cfg = Composer.merge(cfg, batch_cfg)\n            else:\n                logger.info(\"No config file found at %s\", filepath)\n        if self.verbose:\n            logger.info(\"Updating config with config_kwargs: %s\", config_kwargs)\n        cfg = Composer.update(Composer.to_dict(cfg), config_kwargs)\n\n        # initialize self with the config\n        self.__init__(**cfg)\n\n        return self.model_dump()\n\n    def print_config(\n        self,\n        batch_name: Optional[str] = None,\n        batch_num: Optional[int] = None,\n    ):\n        self.load_config(batch_name, batch_num)\n        Composer.print(self.model_dump())\n</code></pre>"},{"location":"reference/task/#hyfi.task.BatchTask.load_config","title":"<code>load_config(batch_name=None, batch_num=None, filepath=None, **config_kwargs)</code>","text":"<p>Load the config from the batch config file</p> Source code in <code>hyfi/task/batch.py</code> <pre><code>def load_config(\n    self,\n    batch_name: Optional[str] = None,\n    batch_num: Optional[int] = None,\n    filepath: Optional[Union[str, Path]] = None,\n    **config_kwargs,\n) -&gt; Dict:\n    \"\"\"Load the config from the batch config file\"\"\"\n    if not self.batch:\n        raise ValueError(\"No batch configuration to load\")\n    if not batch_name:\n        batch_name = self.batch_name\n    if batch_num is None:\n        batch_num = -1\n    if not filepath and batch_num &gt;= 0:\n        batch = Batch(\n            batch_root=self.batch.batch_root,\n            batch_name=batch_name,\n            batch_num=batch_num,\n        )\n        filepath = batch.config_filepath\n    if isinstance(filepath, str):\n        filepath = Path(filepath)\n\n    if self.verbose:\n        logger.info(\n            \"&gt; Loading config for batch_name: %s batch_num: %s\",\n            batch_name,\n            batch_num,\n        )\n    cfg = self.export_config()\n    if filepath:\n        if filepath.is_file():\n            logger.info(\"Loading config from %s\", filepath)\n            batch_cfg = Composer.load(filepath)\n            logger.info(\"Merging config with the loaded config\")\n            cfg = Composer.merge(cfg, batch_cfg)\n        else:\n            logger.info(\"No config file found at %s\", filepath)\n    if self.verbose:\n        logger.info(\"Updating config with config_kwargs: %s\", config_kwargs)\n    cfg = Composer.update(Composer.to_dict(cfg), config_kwargs)\n\n    # initialize self with the config\n    self.__init__(**cfg)\n\n    return self.model_dump()\n</code></pre>"},{"location":"reference/task/#hyfi.task.BatchTask.save_config","title":"<code>save_config(filepath=None, exclude=None, exclude_none=True, only_include=None, save_as_json_as_well=True)</code>","text":"<p>Save the batch configuration to file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Optional[Union[str, Path]]</code> <p>The filepath to save the configuration to. Defaults to None.</p> <code>None</code> <code>exclude</code> <code>Optional[Union[str, List[str], Set[str], None]]</code> <p>Keys to exclude from the saved configuration. Defaults to None.</p> <code>None</code> <code>exclude_none</code> <code>bool</code> <p>Whether to exclude keys with None values from the saved configuration. Defaults to True.</p> <code>True</code> <code>only_include</code> <code>Optional[Union[str, List[str], Set[str], None]]</code> <p>Keys to include in the saved configuration. Defaults to None.</p> <code>None</code> <code>save_as_json_as_well</code> <code>bool</code> <p>Whether to save the configuration as a json file as well. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The filename of the saved configuration.</p> Source code in <code>hyfi/task/batch.py</code> <pre><code>def save_config(\n    self,\n    filepath: Optional[Union[str, Path]] = None,\n    exclude: Optional[Union[str, List[str], Set[str], None]] = None,\n    exclude_none: bool = True,\n    only_include: Optional[Union[str, List[str], Set[str], None]] = None,\n    save_as_json_as_well: bool = True,\n) -&gt; str:\n    \"\"\"\n    Save the batch configuration to file.\n\n    Args:\n        filepath (Optional[Union[str, Path]]): The filepath to save the configuration to. Defaults to None.\n        exclude (Optional[Union[str, List[str], Set[str], None]]): Keys to exclude from the saved configuration.\n            Defaults to None.\n        exclude_none (bool): Whether to exclude keys with None values from the saved configuration. Defaults to True.\n        only_include (Optional[Union[str, List[str], Set[str], None]]): Keys to include in the saved configuration.\n            Defaults to None.\n        save_as_json_as_well (bool): Whether to save the configuration as a json file as well. Defaults to True.\n\n    Returns:\n        str: The filename of the saved configuration.\n    \"\"\"\n    if not self.batch:\n        raise ValueError(\"No batch configuration to save\")\n    if not filepath:\n        filepath = self.batch.config_filepath\n\n    if save_as_json_as_well:\n        self.save_config_as_json(\n            exclude=exclude,\n            exclude_none=exclude_none,\n            only_include=only_include,\n        )\n    return super().save_config(\n        filepath=filepath,\n        exclude=exclude,\n        exclude_none=exclude_none,\n        only_include=only_include,\n    )\n</code></pre>"},{"location":"reference/task/#hyfi.task.Task","title":"<code>Task</code>","text":"<p>               Bases: <code>BaseConfig</code></p> Source code in <code>hyfi/task/task.py</code> <pre><code>class Task(BaseConfig):\n    _config_name_: str = \"__init__\"\n    _config_group_: str = \"/task\"\n\n    task_name: str = \"demo-task\"\n    task_root: str = \"workspace\"\n    version: str = \"0.0.0\"\n    module: Optional[Module] = None\n    path: TaskPath = TaskPath()\n    pipelines: Optional[List[Union[str, Dict]]] = []\n\n    _property_set_methods_ = {\n        \"task_name\": \"set_task_name\",\n        \"task_root\": \"set_task_root\",\n    }\n\n    def set_task_root(self, val: Union[str, Path]):\n        if not self.task_root or self.task_root != val:\n            self.path.task_root = str(val)\n\n    def set_task_name(self, val):\n        if not self.task_name or self.task_name != val:\n            self.path.task_name = val\n\n    @property\n    def config(self):\n        return self.model_dump()\n\n    @property\n    def root_dir(self) -&gt; Path:\n        return self.path.root_dir\n\n    @property\n    def task_dir(self) -&gt; Path:\n        return self.path.task_dir\n\n    @property\n    def project_dir(self) -&gt; Path:\n        return self.path.project_dir\n\n    @property\n    def workspace_dir(self) -&gt; Path:\n        return self.path.workspace_dir\n\n    @property\n    def output_dir(self) -&gt; Path:\n        return self.path.output_dir\n\n    @property\n    def model_dir(self) -&gt; Path:\n        return self.path.model_dir\n\n    @property\n    def log_dir(self) -&gt; Path:\n        return self.path.log_dir\n\n    @property\n    def cache_dir(self) -&gt; Path:\n        return self.path.cache_dir\n\n    @property\n    def library_dir(self) -&gt; Path:\n        return self.path.library_dir\n\n    @property\n    def dataset_dir(self):\n        return self.path.dataset_dir\n\n    def print_config(self):\n        Composer.print(self.config)\n\n    def load_modules(self):\n        \"\"\"Load the modules\"\"\"\n        if not self.module:\n            logger.info(\"No module to load\")\n            return\n        if not self.module.modules:\n            logger.info(\"No modules to load\")\n            return\n        library_dir = self.library_dir\n        for module in self.module.modules:\n            name = module.name\n            libname = module.libname\n            liburi = module.liburi\n            specname = module.specname\n            libpath = library_dir / libname\n            syspath = module.get(\"syspath\")\n            if syspath is not None:\n                syspath = library_dir / syspath\n            PKGs.ensure_import_module(name, libpath, liburi, specname, syspath)\n\n    def reset(self, objects=None, release_gpu_memory=True):\n        \"\"\"Reset the memory cache\"\"\"\n        if isinstance(objects, list):\n            for obj in objects:\n                del obj\n        if release_gpu_memory:\n            from hyfi.utils.gpumon import GPUMon\n\n            GPUMon.release_gpu_memory()\n\n    def get_pipelines(self) -&gt; Pipelines:\n        \"\"\"\n        Get the list of pipelines for a task\n\n        Args:\n            task: The task to get the pipelines for\n\n        Returns:\n            A list of PipelineConfig objects\n        \"\"\"\n        self.pipelines = self.pipelines or []\n        pipelines: Pipelines = []\n        for name in self.pipelines:\n            if isinstance(name, str) and isinstance(getattr(self, name), dict):\n                pipeline = Pipeline(**getattr(self, name))\n                if not pipeline.name:\n                    pipeline.name = name\n                pipelines.append(pipeline)\n        return pipelines\n\n    def run(\n        self,\n        pipelines: Optional[Pipelines] = None,\n    ):\n        \"\"\"\n        Run pipelines specified in the task\n\n        Args:\n            pipelines: The pipelines to run\n        \"\"\"\n        # Run all pipelines in the task.\n        pipelines = pipelines or self.get_pipelines()\n        if self.verbose:\n            logger.info(\"Running %s pipeline(s)\", len(pipelines or []))\n        with elapsed_timer(format_time=True) as elapsed:\n            for pipeline in pipelines:\n                if self.verbose:\n                    logger.info(\"Running pipeline: %s\", pipeline.name)\n                initial_object = self if pipeline.use_task_as_initial_object else None\n                self.run_pipeline(pipeline, initial_object)\n            # Print the elapsed time.\n            if self.verbose:\n                logger.info(\n                    \" &gt;&gt; elapsed time for the task with %s pipelines: %s\",\n                    len(pipelines or []),\n                    elapsed(),\n                )\n\n    def run_pipeline(\n        self,\n        pipeline: Union[Dict, Pipeline],\n        initial_object: Optional[Any] = None,\n    ) -&gt; Any:\n        \"\"\"\n        Run a pipeline given a config\n\n        Args:\n            config: PipelineConfig to run the pipeline\n            initial_obj: Object to use as initial value\n            task: TaskConfig to use as task\n\n        Returns:\n            The result of the pipeline\n        \"\"\"\n        # If config is not a PipelineConfig object it will be converted to a PipelineConfig object.\n        if not isinstance(pipeline, Pipeline):\n            pipeline = Pipeline(**Composer.to_dict(pipeline))\n        pipes = pipeline.get_pipes()\n        if (\n            initial_object is None\n            and pipeline.initial_object is not None\n            and Composer.is_instantiatable(pipeline.initial_object)\n        ):\n            initial_object = Composer.instantiate(pipeline.initial_object)\n        # Return initial object for the initial object\n        if not pipes:\n            logger.warning(\"No pipes specified\")\n            return initial_object\n\n        pipe_names = [pipe.run for pipe in pipes]\n        logger.info(\"Applying %s pipes: %s\", len(pipe_names), pipe_names)\n        # Run the task in the current directory.\n        if self is None:\n            self = Task()\n        with elapsed_timer(format_time=True) as elapsed:\n            with change_directory(self.workspace_dir):\n                rst = reduce(run_pipe, pipes, initial_object)\n            # Print the elapsed time.\n            if pipeline.verbose:\n                logger.info(\n                    \" &gt;&gt; elapsed time for the pipeline with %s pipes: %s\",\n                    len(pipes),\n                    elapsed(),\n                )\n        return rst\n</code></pre>"},{"location":"reference/task/#hyfi.task.Task.get_pipelines","title":"<code>get_pipelines()</code>","text":"<p>Get the list of pipelines for a task</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <p>The task to get the pipelines for</p> required <p>Returns:</p> Type Description <code>Pipelines</code> <p>A list of PipelineConfig objects</p> Source code in <code>hyfi/task/task.py</code> <pre><code>def get_pipelines(self) -&gt; Pipelines:\n    \"\"\"\n    Get the list of pipelines for a task\n\n    Args:\n        task: The task to get the pipelines for\n\n    Returns:\n        A list of PipelineConfig objects\n    \"\"\"\n    self.pipelines = self.pipelines or []\n    pipelines: Pipelines = []\n    for name in self.pipelines:\n        if isinstance(name, str) and isinstance(getattr(self, name), dict):\n            pipeline = Pipeline(**getattr(self, name))\n            if not pipeline.name:\n                pipeline.name = name\n            pipelines.append(pipeline)\n    return pipelines\n</code></pre>"},{"location":"reference/task/#hyfi.task.Task.load_modules","title":"<code>load_modules()</code>","text":"<p>Load the modules</p> Source code in <code>hyfi/task/task.py</code> <pre><code>def load_modules(self):\n    \"\"\"Load the modules\"\"\"\n    if not self.module:\n        logger.info(\"No module to load\")\n        return\n    if not self.module.modules:\n        logger.info(\"No modules to load\")\n        return\n    library_dir = self.library_dir\n    for module in self.module.modules:\n        name = module.name\n        libname = module.libname\n        liburi = module.liburi\n        specname = module.specname\n        libpath = library_dir / libname\n        syspath = module.get(\"syspath\")\n        if syspath is not None:\n            syspath = library_dir / syspath\n        PKGs.ensure_import_module(name, libpath, liburi, specname, syspath)\n</code></pre>"},{"location":"reference/task/#hyfi.task.Task.reset","title":"<code>reset(objects=None, release_gpu_memory=True)</code>","text":"<p>Reset the memory cache</p> Source code in <code>hyfi/task/task.py</code> <pre><code>def reset(self, objects=None, release_gpu_memory=True):\n    \"\"\"Reset the memory cache\"\"\"\n    if isinstance(objects, list):\n        for obj in objects:\n            del obj\n    if release_gpu_memory:\n        from hyfi.utils.gpumon import GPUMon\n\n        GPUMon.release_gpu_memory()\n</code></pre>"},{"location":"reference/task/#hyfi.task.Task.run","title":"<code>run(pipelines=None)</code>","text":"<p>Run pipelines specified in the task</p> <p>Parameters:</p> Name Type Description Default <code>pipelines</code> <code>Optional[Pipelines]</code> <p>The pipelines to run</p> <code>None</code> Source code in <code>hyfi/task/task.py</code> <pre><code>def run(\n    self,\n    pipelines: Optional[Pipelines] = None,\n):\n    \"\"\"\n    Run pipelines specified in the task\n\n    Args:\n        pipelines: The pipelines to run\n    \"\"\"\n    # Run all pipelines in the task.\n    pipelines = pipelines or self.get_pipelines()\n    if self.verbose:\n        logger.info(\"Running %s pipeline(s)\", len(pipelines or []))\n    with elapsed_timer(format_time=True) as elapsed:\n        for pipeline in pipelines:\n            if self.verbose:\n                logger.info(\"Running pipeline: %s\", pipeline.name)\n            initial_object = self if pipeline.use_task_as_initial_object else None\n            self.run_pipeline(pipeline, initial_object)\n        # Print the elapsed time.\n        if self.verbose:\n            logger.info(\n                \" &gt;&gt; elapsed time for the task with %s pipelines: %s\",\n                len(pipelines or []),\n                elapsed(),\n            )\n</code></pre>"},{"location":"reference/task/#hyfi.task.Task.run_pipeline","title":"<code>run_pipeline(pipeline, initial_object=None)</code>","text":"<p>Run a pipeline given a config</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <p>PipelineConfig to run the pipeline</p> required <code>initial_obj</code> <p>Object to use as initial value</p> required <code>task</code> <p>TaskConfig to use as task</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The result of the pipeline</p> Source code in <code>hyfi/task/task.py</code> <pre><code>def run_pipeline(\n    self,\n    pipeline: Union[Dict, Pipeline],\n    initial_object: Optional[Any] = None,\n) -&gt; Any:\n    \"\"\"\n    Run a pipeline given a config\n\n    Args:\n        config: PipelineConfig to run the pipeline\n        initial_obj: Object to use as initial value\n        task: TaskConfig to use as task\n\n    Returns:\n        The result of the pipeline\n    \"\"\"\n    # If config is not a PipelineConfig object it will be converted to a PipelineConfig object.\n    if not isinstance(pipeline, Pipeline):\n        pipeline = Pipeline(**Composer.to_dict(pipeline))\n    pipes = pipeline.get_pipes()\n    if (\n        initial_object is None\n        and pipeline.initial_object is not None\n        and Composer.is_instantiatable(pipeline.initial_object)\n    ):\n        initial_object = Composer.instantiate(pipeline.initial_object)\n    # Return initial object for the initial object\n    if not pipes:\n        logger.warning(\"No pipes specified\")\n        return initial_object\n\n    pipe_names = [pipe.run for pipe in pipes]\n    logger.info(\"Applying %s pipes: %s\", len(pipe_names), pipe_names)\n    # Run the task in the current directory.\n    if self is None:\n        self = Task()\n    with elapsed_timer(format_time=True) as elapsed:\n        with change_directory(self.workspace_dir):\n            rst = reduce(run_pipe, pipes, initial_object)\n        # Print the elapsed time.\n        if pipeline.verbose:\n            logger.info(\n                \" &gt;&gt; elapsed time for the pipeline with %s pipes: %s\",\n                len(pipes),\n                elapsed(),\n            )\n    return rst\n</code></pre>"},{"location":"reference/task/#hyfi.task.TaskPath","title":"<code>TaskPath</code>","text":"<p>               Bases: <code>BasePath</code></p> Source code in <code>hyfi/path/task.py</code> <pre><code>class TaskPath(BasePath):\n    _config_name_: str = \"__task__\"\n\n    task_name: str = __default_task_name__\n    task_root: str = __default_task_root__\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Returns the name of the path configuration.\n        \"\"\"\n        return self.task_name\n\n    @property\n    def project_dir(self) -&gt; Path:\n        return global_config.project_dir\n\n    @property\n    def project_workspace_dir(self) -&gt; Path:\n        return global_config.project_workspace_dir\n\n    @property\n    def root_dir(self) -&gt; Path:\n        \"\"\"\n        Returns the path to the task root directory.\n\n        Returns:\n            an path to the task root directory or None if it doesn't exist or cannot be converted to a path object\n        \"\"\"\n        # return as an path\n        if self.task_root == __default_task_root__:\n            path_ = self.project_workspace_dir\n        else:\n            path_ = Path(self.task_root)\n            if not path_.is_absolute():\n                path_ = self.project_dir / path_\n        return path_.absolute()\n\n    @property\n    def task_dir(self) -&gt; Path:\n        \"\"\"\n        Returns the path to the task root directory.\n\n        Returns:\n            an path to the task root directory or None if it doesn't exist or cannot be converted to a path object\n        \"\"\"\n        return self.root_dir / self.task_name\n\n    @property\n    def workspace_dir(self) -&gt; Path:\n        \"\"\"\n        Returns the path to the task root directory.\n\n        Returns:\n            an path to the task root directory or None if it doesn't exist or cannot be converted to a path object\n        \"\"\"\n        return self.root_dir\n</code></pre>"},{"location":"reference/task/#hyfi.task.TaskPath.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns the name of the path configuration.</p>"},{"location":"reference/task/#hyfi.task.TaskPath.root_dir","title":"<code>root_dir: Path</code>  <code>property</code>","text":"<p>Returns the path to the task root directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>an path to the task root directory or None if it doesn't exist or cannot be converted to a path object</p>"},{"location":"reference/task/#hyfi.task.TaskPath.task_dir","title":"<code>task_dir: Path</code>  <code>property</code>","text":"<p>Returns the path to the task root directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>an path to the task root directory or None if it doesn't exist or cannot be converted to a path object</p>"},{"location":"reference/task/#hyfi.task.TaskPath.workspace_dir","title":"<code>workspace_dir: Path</code>  <code>property</code>","text":"<p>Returns the path to the task root directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>an path to the task root directory or None if it doesn't exist or cannot be converted to a path object</p>"},{"location":"reference/utils/","title":"<code>hyfi.utils</code>","text":""},{"location":"reference/utils/#hyfi.utils.CONFs","title":"<code>CONFs</code>","text":"Source code in <code>hyfi/utils/conf.py</code> <pre><code>class CONFs:\n    @staticmethod\n    def select(\n        cfg: Any,\n        key: str,\n        default: Any = None,\n        throw_on_resolution_failure: bool = True,\n        throw_on_missing: bool = False,\n    ):\n        \"\"\"\n        Wrapper for OmegaConf. select value from a config object using a key.\n\n        Args:\n            cfg: Config node to select from\n            key: Key to select\n            default: Default value to return if key is not found\n            throw_on_resolution_failure: Raise an exception if an interpolation\n                resolution error occurs, otherwise return None\n            throw_on_missing: Raise an exception if an attempt to select a missing key (with the value '???')\n                is made, otherwise return None\n\n        Returns:\n            selected value or None if not found.\n        \"\"\"\n        key = key.replace(\"/\", \".\")\n        return OmegaConf.select(\n            cfg,\n            key=key,\n            default=default,\n            throw_on_resolution_failure=throw_on_resolution_failure,\n            throw_on_missing=throw_on_missing,\n        )\n\n    @staticmethod\n    def to_dict(cfg: Any) -&gt; Any:\n        \"\"\"\n        Convert a config to a dict\n\n        Args:\n            cfg: The config to convert.\n\n        Returns:\n            The dict representation of the config.\n        \"\"\"\n        # Convert a config object to a config object.\n        if isinstance(cfg, dict):\n            cfg = CONFs.to_config(cfg)\n        # Returns a container for the given config.\n        if isinstance(cfg, (DictConfig, ListConfig)):\n            return OmegaConf.to_container(\n                cfg,\n                resolve=True,\n                throw_on_missing=False,\n                structured_config_mode=SCMode.DICT,\n            )\n        return cfg\n\n    @staticmethod\n    def to_config(cfg: Any) -&gt; Union[DictConfig, ListConfig]:\n        \"\"\"\n        Convert a config object to OmegaConf\n\n        Args:\n            cfg: The config to convert.\n\n        Returns:\n            A Config object that corresponds to the given config.\n        \"\"\"\n        return OmegaConf.create(cfg)\n\n    @staticmethod\n    def print(cfg: Any, resolve: bool = True, **kwargs):\n        \"\"\"\n        Prints the configuration object in a human-readable format.\n\n        Args:\n            cfg (Any): The configuration object to print.\n            resolve (bool, optional): Whether to resolve the configuration object before printing. Defaults to True.\n            **kwargs: Additional keyword arguments to pass to the pprint.pprint function.\n\n        Returns:\n            None\n        \"\"\"\n        import pprint\n\n        if CONFs.is_config(cfg):\n            if resolve:\n                pprint.pprint(CONFs.to_dict(cfg), **kwargs)\n            else:\n                pprint.pprint(cfg, **kwargs)\n        else:\n            print(cfg)\n\n    @staticmethod\n    def is_dictlike(cfg: Any):\n        \"\"\"\n        Determines whether the input object is a valid dictionary configuration object.\n\n        Args:\n            cfg (Any): The object to check.\n\n        Returns:\n            bool: True if the object is a valid dictionary configuration object, False otherwise.\n        \"\"\"\n        return isinstance(cfg, DictLike)\n\n    @staticmethod\n    def is_listlike(cfg: Any):\n        \"\"\"\n        Determines whether the input object is a valid list configuration object.\n\n        Args:\n            cfg (Any): The object to check.\n\n        Returns:\n            bool: True if the object is a valid list configuration object, False otherwise.\n        \"\"\"\n        return isinstance(cfg, ListLike)\n\n    @staticmethod\n    def is_config(cfg: Any):\n        \"\"\"\n        Determines whether the input object is a valid configuration object.\n\n        Args:\n            cfg (Any): The object to check.\n\n        Returns:\n            bool: True if the object is a valid configuration object, False otherwise.\n        \"\"\"\n        return isinstance(cfg, (DictConfig, dict))\n\n    @staticmethod\n    def is_list(cfg: Any):\n        \"\"\"\n        Determines whether the input object is a valid list configuration object.\n\n        Args:\n            cfg (Any): The object to check.\n\n        Returns:\n            bool: True if the object is a valid list configuration object, False otherwise.\n        \"\"\"\n        return isinstance(cfg, (ListConfig, list))\n\n    @staticmethod\n    def load(file_: Union[str, Path, IO[Any]]) -&gt; Union[DictConfig, ListConfig]:\n        \"\"\"\n        Load a configuration file and return a configuration object.\n\n        Args:\n            file_ (Union[str, Path, IO[Any]]): The path to the configuration file or a file-like object.\n\n        Returns:\n            Union[DictConfig, ListConfig]: The configuration object.\n        \"\"\"\n        return OmegaConf.load(file_)\n\n    @staticmethod\n    def save(config: Any, f: Union[str, Path, IO[Any]], resolve: bool = False) -&gt; None:\n        \"\"\"\n        Save a configuration object to a file.\n\n        Args:\n            config (Any): The configuration object to save.\n            f (Union[str, Path, IO[Any]]): The path to the file or a file-like object.\n            resolve (bool, optional): Whether to resolve the configuration object before saving. Defaults to False.\n        \"\"\"\n        os.makedirs(os.path.dirname(str(f)), exist_ok=True)\n        OmegaConf.save(config, f, resolve=resolve)\n\n    @staticmethod\n    def save_json(\n        json_dict: dict,\n        f: Union[str, Path, IO[Any]],\n        indent=4,\n        ensure_ascii=False,\n        default=None,\n        encoding=\"utf-8\",\n        **kwargs,\n    ):\n        \"\"\"\n        Save a dictionary to a JSON file.\n\n        Args:\n            json_dict (dict): The dictionary to save.\n            f (Union[str, Path, IO[Any]]): The path to the file or a file-like object.\n            indent (int, optional): The number of spaces to use for indentation. Defaults to 4.\n            ensure_ascii (bool, optional): Whether to escape non-ASCII characters. Defaults to False.\n            default (Any, optional): A function to convert non-serializable objects. Defaults to None.\n            encoding (str, optional): The encoding to use. Defaults to \"utf-8\".\n            **kwargs: Additional arguments to pass to json.dump().\n        \"\"\"\n        f = str(f)\n        os.makedirs(os.path.dirname(f), exist_ok=True)\n        with open(f, \"w\", encoding=encoding) as f:\n            json.dump(\n                json_dict,\n                f,\n                indent=indent,\n                ensure_ascii=ensure_ascii,\n                default=default,\n                **kwargs,\n            )\n\n    @staticmethod\n    def load_json(f: Union[str, Path, IO[Any]], encoding=\"utf-8\", **kwargs) -&gt; dict:\n        \"\"\"\n        Load a JSON file into a dictionary.\n\n        Args:\n            f (Union[str, Path, IO[Any]]): The path to the file or a file-like object.\n            encoding (str, optional): The encoding to use. Defaults to \"utf-8\".\n            **kwargs: Additional arguments to pass to json.load().\n\n        Returns:\n            dict: The dictionary loaded from the JSON file.\n        \"\"\"\n        f = str(f)\n        with open(f, \"r\", encoding=encoding) as f:\n            return json.load(f, **kwargs)\n\n    @staticmethod\n    def update(_dict: Mapping[str, Any], _overrides: Mapping[str, Any]) -&gt; Mapping:\n        \"\"\"\n        Update a dictionary with overrides.\n\n        Args:\n            _dict (Mapping[str, Any]): The dictionary to update.\n            _overrides (Mapping[str, Any]): The dictionary with overrides.\n\n        Returns:\n            Mapping: The updated dictionary.\n        \"\"\"\n        for k, v in _overrides.items():\n            if isinstance(v, collections.abc.Mapping):\n                _dict[k] = CONFs.update((_dict.get(k) or {}), v)  # type: ignore\n            else:\n                _dict[k] = v  # type: ignore\n        return _dict\n\n    @staticmethod\n    def replace_keys(_dict: Mapping[str, Any], old_key: str, new_key: str) -&gt; Mapping:\n        \"\"\"\n        Replace a key in a dictionary.\n\n        Args:\n            _dict (Mapping[str, Any]): The dictionary to update.\n            old_key (str): The old key to replace.\n            new_key (str): The new key to use.\n\n        Returns:\n            Mapping: The updated dictionary.\n        \"\"\"\n        _new_dict = {}\n        for k, v in _dict.items():\n            key = new_key if k == old_key else k\n            if isinstance(v, collections.abc.Mapping):\n                _new_dict[key] = CONFs.replace_keys(v, old_key, new_key)\n            else:\n                _new_dict[key] = v\n        return _new_dict\n\n    @staticmethod\n    def merge(\n        *configs: Union[\n            DictConfig,\n            ListConfig,\n            Dict[DictKeyType, Any],\n            List[Any],\n            Tuple[Any, ...],\n            Any,\n        ],\n    ) -&gt; Union[ListConfig, DictConfig]:\n        \"\"\"\n        Merge a list of previously created configs into a single one.\n\n        Args:\n            *configs: Input configs.\n\n        Returns:\n            Union[ListConfig, DictConfig]: The merged config object.\n        \"\"\"\n        return OmegaConf.merge(*configs)\n\n    @staticmethod\n    def merge_as_dict(\n        *configs: Union[\n            DictConfig,\n            ListConfig,\n            Dict[DictKeyType, Any],\n            List[Any],\n            Tuple[Any, ...],\n            Any,\n        ],\n    ) -&gt; Union[ListConfig, DictConfig]:\n        \"\"\"\n        Merge a list of previously created configs into a single dictionary.\n\n        Args:\n            *configs: Input configs.\n\n        Returns:\n            Union[ListConfig, DictConfig]: The merged config object as a dictionary.\n        \"\"\"\n        return CONFs.to_dict(OmegaConf.merge(*configs))\n\n    @staticmethod\n    def to_yaml(cfg: Any, resolve: bool = False, sort_keys: bool = False) -&gt; str:\n        \"\"\"\n        Convert the input config object to a YAML string.\n\n        Args:\n            cfg (Any): The input config object.\n            resolve (bool, optional): Whether to resolve the config object before converting it to YAML. Defaults to False.\n            sort_keys (bool, optional): Whether to sort the keys in the resulting YAML string. Defaults to False.\n\n        Returns:\n            str: The YAML string representation of the input config object.\n        \"\"\"\n        if resolve:\n            cfg = CONFs.to_dict(cfg)\n        return OmegaConf.to_yaml(cfg, resolve=resolve, sort_keys=sort_keys)\n\n    @staticmethod\n    def to_container(\n        cfg: Any,\n        resolve: bool = False,\n        throw_on_missing: bool = False,\n        enum_to_str: bool = False,\n        structured_config_mode: SCMode = SCMode.DICT,\n    ):\n        \"\"\"\n        Convert the input config object to a nested container (e.g. dictionary).\n\n        Args:\n            cfg (Any): The input config object.\n            resolve (bool, optional): Whether to resolve the config object before converting it to a container. Defaults to False.\n            throw_on_missing (bool, optional): Whether to throw an exception if a missing key is encountered. Defaults to False.\n            enum_to_str (bool, optional): Whether to convert enum values to strings. Defaults to False.\n            structured_config_mode (SCMode, optional): The structured config mode to use. Defaults to SCMode.DICT.\n\n        Returns:\n            The nested container (e.g. dictionary) representation of the input config object.\n        \"\"\"\n        return OmegaConf.to_container(\n            cfg,\n            resolve=resolve,\n            throw_on_missing=throw_on_missing,\n            enum_to_str=enum_to_str,\n            structured_config_mode=structured_config_mode,\n        )\n\n    @staticmethod\n    def ensure_list(value):\n        \"\"\"\n        Ensure that the given value is a list. If the value is None or an empty string, an empty list is returned.\n        If the value is already a list, it is returned as is. If the value is a string, it is returned as a list\n        containing only that string. Otherwise, the value is converted to a dictionary using the CONF.to_dict method\n        and the resulting dictionary is returned as a list.\n\n        Args:\n            value (Any): The value to ensure as a list.\n\n        Returns:\n            List: The value as a list.\n        \"\"\"\n        if not value:\n            return []\n        elif isinstance(value, str):\n            return [value]\n        return CONFs.to_dict(value)\n\n    @staticmethod\n    def ensure_kwargs(_kwargs, _fn):\n        \"\"\"\n        Ensure that the given keyword arguments are valid for the given function.\n\n        Args:\n            _kwargs (dict): The keyword arguments to validate.\n            _fn (callable): The function to validate the keyword arguments against.\n\n        Returns:\n            dict: The valid keyword arguments for the given function.\n        \"\"\"\n        from inspect import getfullargspec as getargspec\n\n        if callable(_fn):\n            args = getargspec(_fn).args\n            logger.info(f\"args of {_fn}: {args}\")\n            return {k: v for k, v in _kwargs.items() if k in args}\n        return _kwargs\n\n    @staticmethod\n    def pprint(cfg: Any, resolve: bool = True, **kwargs):\n        CONFs.print(cfg, resolve=resolve, **kwargs)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.ensure_kwargs","title":"<code>ensure_kwargs(_kwargs, _fn)</code>  <code>staticmethod</code>","text":"<p>Ensure that the given keyword arguments are valid for the given function.</p> <p>Parameters:</p> Name Type Description Default <code>_kwargs</code> <code>dict</code> <p>The keyword arguments to validate.</p> required <code>_fn</code> <code>callable</code> <p>The function to validate the keyword arguments against.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The valid keyword arguments for the given function.</p> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef ensure_kwargs(_kwargs, _fn):\n    \"\"\"\n    Ensure that the given keyword arguments are valid for the given function.\n\n    Args:\n        _kwargs (dict): The keyword arguments to validate.\n        _fn (callable): The function to validate the keyword arguments against.\n\n    Returns:\n        dict: The valid keyword arguments for the given function.\n    \"\"\"\n    from inspect import getfullargspec as getargspec\n\n    if callable(_fn):\n        args = getargspec(_fn).args\n        logger.info(f\"args of {_fn}: {args}\")\n        return {k: v for k, v in _kwargs.items() if k in args}\n    return _kwargs\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.ensure_list","title":"<code>ensure_list(value)</code>  <code>staticmethod</code>","text":"<p>Ensure that the given value is a list. If the value is None or an empty string, an empty list is returned. If the value is already a list, it is returned as is. If the value is a string, it is returned as a list containing only that string. Otherwise, the value is converted to a dictionary using the CONF.to_dict method and the resulting dictionary is returned as a list.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to ensure as a list.</p> required <p>Returns:</p> Name Type Description <code>List</code> <p>The value as a list.</p> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef ensure_list(value):\n    \"\"\"\n    Ensure that the given value is a list. If the value is None or an empty string, an empty list is returned.\n    If the value is already a list, it is returned as is. If the value is a string, it is returned as a list\n    containing only that string. Otherwise, the value is converted to a dictionary using the CONF.to_dict method\n    and the resulting dictionary is returned as a list.\n\n    Args:\n        value (Any): The value to ensure as a list.\n\n    Returns:\n        List: The value as a list.\n    \"\"\"\n    if not value:\n        return []\n    elif isinstance(value, str):\n        return [value]\n    return CONFs.to_dict(value)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.is_config","title":"<code>is_config(cfg)</code>  <code>staticmethod</code>","text":"<p>Determines whether the input object is a valid configuration object.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>Any</code> <p>The object to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the object is a valid configuration object, False otherwise.</p> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef is_config(cfg: Any):\n    \"\"\"\n    Determines whether the input object is a valid configuration object.\n\n    Args:\n        cfg (Any): The object to check.\n\n    Returns:\n        bool: True if the object is a valid configuration object, False otherwise.\n    \"\"\"\n    return isinstance(cfg, (DictConfig, dict))\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.is_dictlike","title":"<code>is_dictlike(cfg)</code>  <code>staticmethod</code>","text":"<p>Determines whether the input object is a valid dictionary configuration object.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>Any</code> <p>The object to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the object is a valid dictionary configuration object, False otherwise.</p> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef is_dictlike(cfg: Any):\n    \"\"\"\n    Determines whether the input object is a valid dictionary configuration object.\n\n    Args:\n        cfg (Any): The object to check.\n\n    Returns:\n        bool: True if the object is a valid dictionary configuration object, False otherwise.\n    \"\"\"\n    return isinstance(cfg, DictLike)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.is_list","title":"<code>is_list(cfg)</code>  <code>staticmethod</code>","text":"<p>Determines whether the input object is a valid list configuration object.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>Any</code> <p>The object to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the object is a valid list configuration object, False otherwise.</p> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef is_list(cfg: Any):\n    \"\"\"\n    Determines whether the input object is a valid list configuration object.\n\n    Args:\n        cfg (Any): The object to check.\n\n    Returns:\n        bool: True if the object is a valid list configuration object, False otherwise.\n    \"\"\"\n    return isinstance(cfg, (ListConfig, list))\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.is_listlike","title":"<code>is_listlike(cfg)</code>  <code>staticmethod</code>","text":"<p>Determines whether the input object is a valid list configuration object.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>Any</code> <p>The object to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the object is a valid list configuration object, False otherwise.</p> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef is_listlike(cfg: Any):\n    \"\"\"\n    Determines whether the input object is a valid list configuration object.\n\n    Args:\n        cfg (Any): The object to check.\n\n    Returns:\n        bool: True if the object is a valid list configuration object, False otherwise.\n    \"\"\"\n    return isinstance(cfg, ListLike)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.load","title":"<code>load(file_)</code>  <code>staticmethod</code>","text":"<p>Load a configuration file and return a configuration object.</p> <p>Parameters:</p> Name Type Description Default <code>file_</code> <code>Union[str, Path, IO[Any]]</code> <p>The path to the configuration file or a file-like object.</p> required <p>Returns:</p> Type Description <code>Union[DictConfig, ListConfig]</code> <p>Union[DictConfig, ListConfig]: The configuration object.</p> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef load(file_: Union[str, Path, IO[Any]]) -&gt; Union[DictConfig, ListConfig]:\n    \"\"\"\n    Load a configuration file and return a configuration object.\n\n    Args:\n        file_ (Union[str, Path, IO[Any]]): The path to the configuration file or a file-like object.\n\n    Returns:\n        Union[DictConfig, ListConfig]: The configuration object.\n    \"\"\"\n    return OmegaConf.load(file_)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.load_json","title":"<code>load_json(f, encoding='utf-8', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Load a JSON file into a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Union[str, Path, IO[Any]]</code> <p>The path to the file or a file-like object.</p> required <code>encoding</code> <code>str</code> <p>The encoding to use. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <code>**kwargs</code> <p>Additional arguments to pass to json.load().</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary loaded from the JSON file.</p> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef load_json(f: Union[str, Path, IO[Any]], encoding=\"utf-8\", **kwargs) -&gt; dict:\n    \"\"\"\n    Load a JSON file into a dictionary.\n\n    Args:\n        f (Union[str, Path, IO[Any]]): The path to the file or a file-like object.\n        encoding (str, optional): The encoding to use. Defaults to \"utf-8\".\n        **kwargs: Additional arguments to pass to json.load().\n\n    Returns:\n        dict: The dictionary loaded from the JSON file.\n    \"\"\"\n    f = str(f)\n    with open(f, \"r\", encoding=encoding) as f:\n        return json.load(f, **kwargs)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.merge","title":"<code>merge(*configs)</code>  <code>staticmethod</code>","text":"<p>Merge a list of previously created configs into a single one.</p> <p>Parameters:</p> Name Type Description Default <code>*configs</code> <code>Union[DictConfig, ListConfig, Dict[DictKeyType, Any], List[Any], Tuple[Any, ...], Any]</code> <p>Input configs.</p> <code>()</code> <p>Returns:</p> Type Description <code>Union[ListConfig, DictConfig]</code> <p>Union[ListConfig, DictConfig]: The merged config object.</p> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef merge(\n    *configs: Union[\n        DictConfig,\n        ListConfig,\n        Dict[DictKeyType, Any],\n        List[Any],\n        Tuple[Any, ...],\n        Any,\n    ],\n) -&gt; Union[ListConfig, DictConfig]:\n    \"\"\"\n    Merge a list of previously created configs into a single one.\n\n    Args:\n        *configs: Input configs.\n\n    Returns:\n        Union[ListConfig, DictConfig]: The merged config object.\n    \"\"\"\n    return OmegaConf.merge(*configs)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.merge_as_dict","title":"<code>merge_as_dict(*configs)</code>  <code>staticmethod</code>","text":"<p>Merge a list of previously created configs into a single dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>*configs</code> <code>Union[DictConfig, ListConfig, Dict[DictKeyType, Any], List[Any], Tuple[Any, ...], Any]</code> <p>Input configs.</p> <code>()</code> <p>Returns:</p> Type Description <code>Union[ListConfig, DictConfig]</code> <p>Union[ListConfig, DictConfig]: The merged config object as a dictionary.</p> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef merge_as_dict(\n    *configs: Union[\n        DictConfig,\n        ListConfig,\n        Dict[DictKeyType, Any],\n        List[Any],\n        Tuple[Any, ...],\n        Any,\n    ],\n) -&gt; Union[ListConfig, DictConfig]:\n    \"\"\"\n    Merge a list of previously created configs into a single dictionary.\n\n    Args:\n        *configs: Input configs.\n\n    Returns:\n        Union[ListConfig, DictConfig]: The merged config object as a dictionary.\n    \"\"\"\n    return CONFs.to_dict(OmegaConf.merge(*configs))\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.print","title":"<code>print(cfg, resolve=True, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Prints the configuration object in a human-readable format.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>Any</code> <p>The configuration object to print.</p> required <code>resolve</code> <code>bool</code> <p>Whether to resolve the configuration object before printing. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the pprint.pprint function.</p> <code>{}</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef print(cfg: Any, resolve: bool = True, **kwargs):\n    \"\"\"\n    Prints the configuration object in a human-readable format.\n\n    Args:\n        cfg (Any): The configuration object to print.\n        resolve (bool, optional): Whether to resolve the configuration object before printing. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to the pprint.pprint function.\n\n    Returns:\n        None\n    \"\"\"\n    import pprint\n\n    if CONFs.is_config(cfg):\n        if resolve:\n            pprint.pprint(CONFs.to_dict(cfg), **kwargs)\n        else:\n            pprint.pprint(cfg, **kwargs)\n    else:\n        print(cfg)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.replace_keys","title":"<code>replace_keys(_dict, old_key, new_key)</code>  <code>staticmethod</code>","text":"<p>Replace a key in a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>_dict</code> <code>Mapping[str, Any]</code> <p>The dictionary to update.</p> required <code>old_key</code> <code>str</code> <p>The old key to replace.</p> required <code>new_key</code> <code>str</code> <p>The new key to use.</p> required <p>Returns:</p> Name Type Description <code>Mapping</code> <code>Mapping</code> <p>The updated dictionary.</p> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef replace_keys(_dict: Mapping[str, Any], old_key: str, new_key: str) -&gt; Mapping:\n    \"\"\"\n    Replace a key in a dictionary.\n\n    Args:\n        _dict (Mapping[str, Any]): The dictionary to update.\n        old_key (str): The old key to replace.\n        new_key (str): The new key to use.\n\n    Returns:\n        Mapping: The updated dictionary.\n    \"\"\"\n    _new_dict = {}\n    for k, v in _dict.items():\n        key = new_key if k == old_key else k\n        if isinstance(v, collections.abc.Mapping):\n            _new_dict[key] = CONFs.replace_keys(v, old_key, new_key)\n        else:\n            _new_dict[key] = v\n    return _new_dict\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.save","title":"<code>save(config, f, resolve=False)</code>  <code>staticmethod</code>","text":"<p>Save a configuration object to a file.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Any</code> <p>The configuration object to save.</p> required <code>f</code> <code>Union[str, Path, IO[Any]]</code> <p>The path to the file or a file-like object.</p> required <code>resolve</code> <code>bool</code> <p>Whether to resolve the configuration object before saving. Defaults to False.</p> <code>False</code> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef save(config: Any, f: Union[str, Path, IO[Any]], resolve: bool = False) -&gt; None:\n    \"\"\"\n    Save a configuration object to a file.\n\n    Args:\n        config (Any): The configuration object to save.\n        f (Union[str, Path, IO[Any]]): The path to the file or a file-like object.\n        resolve (bool, optional): Whether to resolve the configuration object before saving. Defaults to False.\n    \"\"\"\n    os.makedirs(os.path.dirname(str(f)), exist_ok=True)\n    OmegaConf.save(config, f, resolve=resolve)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.save_json","title":"<code>save_json(json_dict, f, indent=4, ensure_ascii=False, default=None, encoding='utf-8', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Save a dictionary to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>json_dict</code> <code>dict</code> <p>The dictionary to save.</p> required <code>f</code> <code>Union[str, Path, IO[Any]]</code> <p>The path to the file or a file-like object.</p> required <code>indent</code> <code>int</code> <p>The number of spaces to use for indentation. Defaults to 4.</p> <code>4</code> <code>ensure_ascii</code> <code>bool</code> <p>Whether to escape non-ASCII characters. Defaults to False.</p> <code>False</code> <code>default</code> <code>Any</code> <p>A function to convert non-serializable objects. Defaults to None.</p> <code>None</code> <code>encoding</code> <code>str</code> <p>The encoding to use. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <code>**kwargs</code> <p>Additional arguments to pass to json.dump().</p> <code>{}</code> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef save_json(\n    json_dict: dict,\n    f: Union[str, Path, IO[Any]],\n    indent=4,\n    ensure_ascii=False,\n    default=None,\n    encoding=\"utf-8\",\n    **kwargs,\n):\n    \"\"\"\n    Save a dictionary to a JSON file.\n\n    Args:\n        json_dict (dict): The dictionary to save.\n        f (Union[str, Path, IO[Any]]): The path to the file or a file-like object.\n        indent (int, optional): The number of spaces to use for indentation. Defaults to 4.\n        ensure_ascii (bool, optional): Whether to escape non-ASCII characters. Defaults to False.\n        default (Any, optional): A function to convert non-serializable objects. Defaults to None.\n        encoding (str, optional): The encoding to use. Defaults to \"utf-8\".\n        **kwargs: Additional arguments to pass to json.dump().\n    \"\"\"\n    f = str(f)\n    os.makedirs(os.path.dirname(f), exist_ok=True)\n    with open(f, \"w\", encoding=encoding) as f:\n        json.dump(\n            json_dict,\n            f,\n            indent=indent,\n            ensure_ascii=ensure_ascii,\n            default=default,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.select","title":"<code>select(cfg, key, default=None, throw_on_resolution_failure=True, throw_on_missing=False)</code>  <code>staticmethod</code>","text":"<p>Wrapper for OmegaConf. select value from a config object using a key.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>Any</code> <p>Config node to select from</p> required <code>key</code> <code>str</code> <p>Key to select</p> required <code>default</code> <code>Any</code> <p>Default value to return if key is not found</p> <code>None</code> <code>throw_on_resolution_failure</code> <code>bool</code> <p>Raise an exception if an interpolation resolution error occurs, otherwise return None</p> <code>True</code> <code>throw_on_missing</code> <code>bool</code> <p>Raise an exception if an attempt to select a missing key (with the value '???') is made, otherwise return None</p> <code>False</code> <p>Returns:</p> Type Description <p>selected value or None if not found.</p> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef select(\n    cfg: Any,\n    key: str,\n    default: Any = None,\n    throw_on_resolution_failure: bool = True,\n    throw_on_missing: bool = False,\n):\n    \"\"\"\n    Wrapper for OmegaConf. select value from a config object using a key.\n\n    Args:\n        cfg: Config node to select from\n        key: Key to select\n        default: Default value to return if key is not found\n        throw_on_resolution_failure: Raise an exception if an interpolation\n            resolution error occurs, otherwise return None\n        throw_on_missing: Raise an exception if an attempt to select a missing key (with the value '???')\n            is made, otherwise return None\n\n    Returns:\n        selected value or None if not found.\n    \"\"\"\n    key = key.replace(\"/\", \".\")\n    return OmegaConf.select(\n        cfg,\n        key=key,\n        default=default,\n        throw_on_resolution_failure=throw_on_resolution_failure,\n        throw_on_missing=throw_on_missing,\n    )\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.to_config","title":"<code>to_config(cfg)</code>  <code>staticmethod</code>","text":"<p>Convert a config object to OmegaConf</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>Any</code> <p>The config to convert.</p> required <p>Returns:</p> Type Description <code>Union[DictConfig, ListConfig]</code> <p>A Config object that corresponds to the given config.</p> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef to_config(cfg: Any) -&gt; Union[DictConfig, ListConfig]:\n    \"\"\"\n    Convert a config object to OmegaConf\n\n    Args:\n        cfg: The config to convert.\n\n    Returns:\n        A Config object that corresponds to the given config.\n    \"\"\"\n    return OmegaConf.create(cfg)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.to_container","title":"<code>to_container(cfg, resolve=False, throw_on_missing=False, enum_to_str=False, structured_config_mode=SCMode.DICT)</code>  <code>staticmethod</code>","text":"<p>Convert the input config object to a nested container (e.g. dictionary).</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>Any</code> <p>The input config object.</p> required <code>resolve</code> <code>bool</code> <p>Whether to resolve the config object before converting it to a container. Defaults to False.</p> <code>False</code> <code>throw_on_missing</code> <code>bool</code> <p>Whether to throw an exception if a missing key is encountered. Defaults to False.</p> <code>False</code> <code>enum_to_str</code> <code>bool</code> <p>Whether to convert enum values to strings. Defaults to False.</p> <code>False</code> <code>structured_config_mode</code> <code>SCMode</code> <p>The structured config mode to use. Defaults to SCMode.DICT.</p> <code>DICT</code> <p>Returns:</p> Type Description <p>The nested container (e.g. dictionary) representation of the input config object.</p> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef to_container(\n    cfg: Any,\n    resolve: bool = False,\n    throw_on_missing: bool = False,\n    enum_to_str: bool = False,\n    structured_config_mode: SCMode = SCMode.DICT,\n):\n    \"\"\"\n    Convert the input config object to a nested container (e.g. dictionary).\n\n    Args:\n        cfg (Any): The input config object.\n        resolve (bool, optional): Whether to resolve the config object before converting it to a container. Defaults to False.\n        throw_on_missing (bool, optional): Whether to throw an exception if a missing key is encountered. Defaults to False.\n        enum_to_str (bool, optional): Whether to convert enum values to strings. Defaults to False.\n        structured_config_mode (SCMode, optional): The structured config mode to use. Defaults to SCMode.DICT.\n\n    Returns:\n        The nested container (e.g. dictionary) representation of the input config object.\n    \"\"\"\n    return OmegaConf.to_container(\n        cfg,\n        resolve=resolve,\n        throw_on_missing=throw_on_missing,\n        enum_to_str=enum_to_str,\n        structured_config_mode=structured_config_mode,\n    )\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.to_dict","title":"<code>to_dict(cfg)</code>  <code>staticmethod</code>","text":"<p>Convert a config to a dict</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>Any</code> <p>The config to convert.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The dict representation of the config.</p> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef to_dict(cfg: Any) -&gt; Any:\n    \"\"\"\n    Convert a config to a dict\n\n    Args:\n        cfg: The config to convert.\n\n    Returns:\n        The dict representation of the config.\n    \"\"\"\n    # Convert a config object to a config object.\n    if isinstance(cfg, dict):\n        cfg = CONFs.to_config(cfg)\n    # Returns a container for the given config.\n    if isinstance(cfg, (DictConfig, ListConfig)):\n        return OmegaConf.to_container(\n            cfg,\n            resolve=True,\n            throw_on_missing=False,\n            structured_config_mode=SCMode.DICT,\n        )\n    return cfg\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.to_yaml","title":"<code>to_yaml(cfg, resolve=False, sort_keys=False)</code>  <code>staticmethod</code>","text":"<p>Convert the input config object to a YAML string.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>Any</code> <p>The input config object.</p> required <code>resolve</code> <code>bool</code> <p>Whether to resolve the config object before converting it to YAML. Defaults to False.</p> <code>False</code> <code>sort_keys</code> <code>bool</code> <p>Whether to sort the keys in the resulting YAML string. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The YAML string representation of the input config object.</p> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef to_yaml(cfg: Any, resolve: bool = False, sort_keys: bool = False) -&gt; str:\n    \"\"\"\n    Convert the input config object to a YAML string.\n\n    Args:\n        cfg (Any): The input config object.\n        resolve (bool, optional): Whether to resolve the config object before converting it to YAML. Defaults to False.\n        sort_keys (bool, optional): Whether to sort the keys in the resulting YAML string. Defaults to False.\n\n    Returns:\n        str: The YAML string representation of the input config object.\n    \"\"\"\n    if resolve:\n        cfg = CONFs.to_dict(cfg)\n    return OmegaConf.to_yaml(cfg, resolve=resolve, sort_keys=sort_keys)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.CONFs.update","title":"<code>update(_dict, _overrides)</code>  <code>staticmethod</code>","text":"<p>Update a dictionary with overrides.</p> <p>Parameters:</p> Name Type Description Default <code>_dict</code> <code>Mapping[str, Any]</code> <p>The dictionary to update.</p> required <code>_overrides</code> <code>Mapping[str, Any]</code> <p>The dictionary with overrides.</p> required <p>Returns:</p> Name Type Description <code>Mapping</code> <code>Mapping</code> <p>The updated dictionary.</p> Source code in <code>hyfi/utils/conf.py</code> <pre><code>@staticmethod\ndef update(_dict: Mapping[str, Any], _overrides: Mapping[str, Any]) -&gt; Mapping:\n    \"\"\"\n    Update a dictionary with overrides.\n\n    Args:\n        _dict (Mapping[str, Any]): The dictionary to update.\n        _overrides (Mapping[str, Any]): The dictionary with overrides.\n\n    Returns:\n        Mapping: The updated dictionary.\n    \"\"\"\n    for k, v in _overrides.items():\n        if isinstance(v, collections.abc.Mapping):\n            _dict[k] = CONFs.update((_dict.get(k) or {}), v)  # type: ignore\n        else:\n            _dict[k] = v  # type: ignore\n    return _dict\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.DATASETs","title":"<code>DATASETs</code>","text":"<p>               Bases: <code>DSAggregate</code>, <code>DSBasic</code>, <code>DSCombine</code>, <code>DSLoad</code>, <code>DSPlot</code>, <code>DSReshape</code>, <code>DSSave</code>, <code>DSSlice</code>, <code>DSUtils</code></p> <p>A class representing a collection of datasets.</p> <p>This class inherits from various dataset utility classes and provides a convenient way to access and manipulate datasets.</p> Source code in <code>hyfi/utils/datasets/__init__.py</code> <pre><code>class DATASETs(\n    DSAggregate,\n    DSBasic,\n    DSCombine,\n    DSLoad,\n    DSPlot,\n    DSReshape,\n    DSSave,\n    DSSlice,\n    DSUtils,\n):\n    \"\"\"\n    A class representing a collection of datasets.\n\n    This class inherits from various dataset utility classes and provides a convenient way to access and manipulate datasets.\n\n    Attributes:\n        None\n\n    Methods:\n        None\n    \"\"\"\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.ENVs","title":"<code>ENVs</code>","text":"Source code in <code>hyfi/utils/envs.py</code> <pre><code>class ENVs:\n    @staticmethod\n    def getcwd():\n        \"\"\"Get the original working directory before Hydra changed it.\n\n        This function tries to call the `get_original_cwd` function from the `hydra.utils` module,\n        which returns the original working directory if it exists. If the `get_original_cwd` function\n        raises a `ValueError` exception, it means that Hydra did not change the working directory,\n        so the function falls back to calling the `os.getcwd` function, which returns the current\n        working directory.\n\n        Returns:\n            str: The original working directory before Hydra changed it.\n        \"\"\"\n        try:\n            return hydra.utils.get_original_cwd()\n        except ValueError:\n            return os.getcwd()\n\n    @staticmethod\n    def expand_posix_vars(posix_expr: str, context: dict = None) -&gt; str:  # type: ignore\n        # sourcery skip: dict-assign-update-to-union\n        \"\"\"\n        Expand POSIX variables in a string.\n\n        Args:\n            posix_expr (str): The string containing POSIX variables to be expanded.\n            context (dict, optional): A dictionary containing additional variables to be used in the expansion.\n                Defaults to None.\n\n        Returns:\n            str: The expanded string.\n\n        Examples:\n            &gt;&gt;&gt; expand_posix_vars(\"$HOME\")\n            '/home/user'\n            &gt;&gt;&gt; expand_posix_vars(\"$HOME/$USER\", {\"USER\": \"testuser\"})\n            '/home/user/testuser'\n\n        \"\"\"\n        # Set the context to the default context.\n        if context is None:\n            context = {}\n        env = defaultdict(str, os.environ.copy())\n        env.update(context)\n        return Template(posix_expr).substitute(env)\n\n    @staticmethod\n    def dotenv_values(dotenv_path: str = \"\", **kwargs):\n        \"\"\"\n        Load dotenv file and return a dict of key / value pairs. This is a wrapper around : py : func : ` dotenv. dotenv_values `\n\n        Args:\n            dotenv_path: path to. env file\n\n        Returns:\n            dict of key / value pairs ( key = value )\n        \"\"\"\n        config = dotenv.dotenv_values(dotenv_path=dotenv_path, **kwargs)\n        return dict(config)\n\n    @staticmethod\n    def load_dotenv(\n        override: bool = False,\n        dotenv_file: str = \".env\",\n        raise_error_if_not_found: bool = False,\n        usecwd: bool = False,\n        verbose: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Load. env file from given directory or from current directory. This is a convenience function for use in tests that want to run dotenv in a non - interactive environment\n\n        Args:\n            override: If True override existing. env file\n            dotenv_file: Name of. env file to look for in given directory or current directory\n            verbose: Print debug information to console\n\n        Returns:\n            None or a Path object for the. env file\n        \"\"\"\n        dotenv_path = Path(dotenv_file)\n        if not dotenv_path.is_absolute():\n            dotenv_path = Path(ENVs.getcwd()) / dotenv_path\n        dotenv_filename = dotenv_path.name\n        dotenv_dir = str(dotenv_path.parent)\n        # Load. env files and directories.\n        if dotenv_path.is_file():\n            dotenv.load_dotenv(\n                dotenv_path=str(dotenv_path),\n                verbose=verbose,\n                override=override,\n                **kwargs,\n            )\n            os.environ[\"DOTENV_FILENAME\"] = dotenv_filename\n            os.environ[\"DOTENV_FILE\"] = str(dotenv_path)\n            os.environ[\"DOTENV_DIR\"] = dotenv_dir\n            # Load. env from dotenv_path.\n            logger.info(\"Loaded .env from [%s]\", dotenv_path)\n        else:\n            # If verbose is true print out the. env file.\n            logger.info(\"[%s] not found, finding .env in parent dirs\", dotenv_path)\n            # Find. env file in parent directories.\n            if dotenv_path := ENVs.find_dotenv(\n                filename=dotenv_filename,\n                raise_error_if_not_found=raise_error_if_not_found,\n                usecwd=usecwd,\n            ):\n                dotenv.load_dotenv(\n                    dotenv_path=dotenv_path,\n                    verbose=verbose,\n                    override=override,\n                    **kwargs,\n                )\n                dotenv_path = Path(dotenv_path)\n                dotenv_filename = dotenv_path.name\n                dotenv_dir = str(dotenv_path.parent)\n                os.environ[\"DOTENV_FILENAME\"] = dotenv_filename\n                os.environ[\"DOTENV_FILE\"] = str(dotenv_path)\n                os.environ[\"DOTENV_DIR\"] = dotenv_dir\n                # Load. env from dotenv_path.\n                logger.info(\"Loaded .env from [%s]\", dotenv_path)\n            else:\n                os.environ[\"DOTENV_FILE\"] = \"\"\n                os.environ[\"DOTENV_DIR\"] = \"\"\n                # Print out the. env file if verbose is true.\n                logger.info(\"No .env file found in the parent dirs of [%s]\", dotenv_dir)\n\n    @staticmethod\n    def is_interactive():\n        \"\"\"Decide whether this is running in a REPL or IPython notebook\"\"\"\n        main = __import__(\"__main__\", None, None, fromlist=[\"__file__\"])\n        return not hasattr(main, \"__file__\")\n\n    @staticmethod\n    def find_dotenv(\n        filename: str = \".env\",\n        raise_error_if_not_found: bool = False,\n        usecwd: bool = False,\n    ) -&gt; str:\n        \"\"\"\n        Search in increasingly higher folders for the given file\n\n        Returns path to the file if found, or an empty string otherwise\n        \"\"\"\n\n        if usecwd or ENVs.is_interactive() or getattr(sys, \"frozen\", False):\n            # Should work without __file__, e.g. in REPL or IPython notebook.\n            path = os.getcwd()\n        else:\n            # will work for .py files\n            frame = sys._getframe()\n            current_file = __file__\n\n            while frame.f_code.co_filename == current_file:\n                assert frame.f_back is not None\n                frame = frame.f_back\n            frame_filename = frame.f_code.co_filename\n            path = os.path.dirname(os.path.abspath(frame_filename))\n\n        logger.debug(\"Trying to find %s in %s\", filename, path)\n        for dirname in IOLIBs.walk_to_root(path):\n            check_path = os.path.join(dirname, filename)\n            if os.path.isfile(check_path):\n                return check_path\n\n        if raise_error_if_not_found:\n            raise IOError(\"File not found\")\n\n        return \"\"\n\n    @staticmethod\n    def find_dotenv_dir(\n        filename: str = \".env\",\n        raise_error_if_not_found: bool = False,\n        usecwd: bool = False,\n    ) -&gt; str:\n        \"\"\"\n        Search in increasingly higher folders for the given file\n\n        Returns path to the file if found, or an empty string otherwise\n        \"\"\"\n        if dotenv_path := ENVs.find_dotenv(\n            filename=filename,\n            raise_error_if_not_found=raise_error_if_not_found,\n            usecwd=usecwd,\n        ):\n            return os.path.dirname(dotenv_path)\n        return \"\"\n\n    @staticmethod\n    def get_osenv(key: str = \"\", default: Optional[str] = None) -&gt; Any:\n        \"\"\"Get the value of an environment variable or return the default value\"\"\"\n        ENVs.load_dotenv()\n        return os.environ.get(key, default) if key else os.environ\n\n    @staticmethod\n    def set_osenv(key: str, value: Any) -&gt; None:\n        \"\"\"Set the value of an environment variable\"\"\"\n        if value and IOLIBs.is_dir(value):\n            value = os.path.abspath(value)\n        if pre_val := os.environ.get(key):\n            logger.info(\"Overwriting %s=%s with %s\", key, pre_val, value)\n        else:\n            logger.info(\"Setting %s=%s\", key, value)\n        os.setdefault(key, value)\n\n    @staticmethod\n    def check_and_set_osenv_var(key: str, value: Any) -&gt; Any:\n        \"\"\"Check and set value to environment variable\"\"\"\n        env_key = key.upper()\n        if value is not None:\n            old_value = os.getenv(env_key, \"\")\n            if str(old_value).lower() != str(value).lower():\n                os.environ[env_key] = str(value)\n                logger.debug(\"Set environment variable %s=%s\", env_key, str(value))\n        elif env_key in os.environ and os.environ[env_key]:\n            del os.environ[env_key]\n            logger.debug(\"Deleted environment variable %s\", env_key)\n        return value\n\n    @staticmethod\n    def check_and_set_osenv_vars(values: Dict[str, Any]) -&gt; Dict[str, Any]:\n        for k, v in values.items():\n            ENVs.check_and_set_osenv_var(k, v)\n        return values\n\n    @staticmethod\n    def osenv():\n        \"\"\"\n        Return the os environment variables as a dictionary.\n\n        Returns:\n            dict: A dictionary containing the os environment variables.\n        \"\"\"\n        return os.environ\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.ENVs.check_and_set_osenv_var","title":"<code>check_and_set_osenv_var(key, value)</code>  <code>staticmethod</code>","text":"<p>Check and set value to environment variable</p> Source code in <code>hyfi/utils/envs.py</code> <pre><code>@staticmethod\ndef check_and_set_osenv_var(key: str, value: Any) -&gt; Any:\n    \"\"\"Check and set value to environment variable\"\"\"\n    env_key = key.upper()\n    if value is not None:\n        old_value = os.getenv(env_key, \"\")\n        if str(old_value).lower() != str(value).lower():\n            os.environ[env_key] = str(value)\n            logger.debug(\"Set environment variable %s=%s\", env_key, str(value))\n    elif env_key in os.environ and os.environ[env_key]:\n        del os.environ[env_key]\n        logger.debug(\"Deleted environment variable %s\", env_key)\n    return value\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.ENVs.dotenv_values","title":"<code>dotenv_values(dotenv_path='', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Load dotenv file and return a dict of key / value pairs. This is a wrapper around : py : func : <code>dotenv. dotenv_values</code></p> <p>Parameters:</p> Name Type Description Default <code>dotenv_path</code> <code>str</code> <p>path to. env file</p> <code>''</code> <p>Returns:</p> Type Description <p>dict of key / value pairs ( key = value )</p> Source code in <code>hyfi/utils/envs.py</code> <pre><code>@staticmethod\ndef dotenv_values(dotenv_path: str = \"\", **kwargs):\n    \"\"\"\n    Load dotenv file and return a dict of key / value pairs. This is a wrapper around : py : func : ` dotenv. dotenv_values `\n\n    Args:\n        dotenv_path: path to. env file\n\n    Returns:\n        dict of key / value pairs ( key = value )\n    \"\"\"\n    config = dotenv.dotenv_values(dotenv_path=dotenv_path, **kwargs)\n    return dict(config)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.ENVs.expand_posix_vars","title":"<code>expand_posix_vars(posix_expr, context=None)</code>  <code>staticmethod</code>","text":"<p>Expand POSIX variables in a string.</p> <p>Parameters:</p> Name Type Description Default <code>posix_expr</code> <code>str</code> <p>The string containing POSIX variables to be expanded.</p> required <code>context</code> <code>dict</code> <p>A dictionary containing additional variables to be used in the expansion. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The expanded string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; expand_posix_vars(\"$HOME\")\n'/home/user'\n&gt;&gt;&gt; expand_posix_vars(\"$HOME/$USER\", {\"USER\": \"testuser\"})\n'/home/user/testuser'\n</code></pre> Source code in <code>hyfi/utils/envs.py</code> <pre><code>@staticmethod\ndef expand_posix_vars(posix_expr: str, context: dict = None) -&gt; str:  # type: ignore\n    # sourcery skip: dict-assign-update-to-union\n    \"\"\"\n    Expand POSIX variables in a string.\n\n    Args:\n        posix_expr (str): The string containing POSIX variables to be expanded.\n        context (dict, optional): A dictionary containing additional variables to be used in the expansion.\n            Defaults to None.\n\n    Returns:\n        str: The expanded string.\n\n    Examples:\n        &gt;&gt;&gt; expand_posix_vars(\"$HOME\")\n        '/home/user'\n        &gt;&gt;&gt; expand_posix_vars(\"$HOME/$USER\", {\"USER\": \"testuser\"})\n        '/home/user/testuser'\n\n    \"\"\"\n    # Set the context to the default context.\n    if context is None:\n        context = {}\n    env = defaultdict(str, os.environ.copy())\n    env.update(context)\n    return Template(posix_expr).substitute(env)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.ENVs.find_dotenv","title":"<code>find_dotenv(filename='.env', raise_error_if_not_found=False, usecwd=False)</code>  <code>staticmethod</code>","text":"<p>Search in increasingly higher folders for the given file</p> <p>Returns path to the file if found, or an empty string otherwise</p> Source code in <code>hyfi/utils/envs.py</code> <pre><code>@staticmethod\ndef find_dotenv(\n    filename: str = \".env\",\n    raise_error_if_not_found: bool = False,\n    usecwd: bool = False,\n) -&gt; str:\n    \"\"\"\n    Search in increasingly higher folders for the given file\n\n    Returns path to the file if found, or an empty string otherwise\n    \"\"\"\n\n    if usecwd or ENVs.is_interactive() or getattr(sys, \"frozen\", False):\n        # Should work without __file__, e.g. in REPL or IPython notebook.\n        path = os.getcwd()\n    else:\n        # will work for .py files\n        frame = sys._getframe()\n        current_file = __file__\n\n        while frame.f_code.co_filename == current_file:\n            assert frame.f_back is not None\n            frame = frame.f_back\n        frame_filename = frame.f_code.co_filename\n        path = os.path.dirname(os.path.abspath(frame_filename))\n\n    logger.debug(\"Trying to find %s in %s\", filename, path)\n    for dirname in IOLIBs.walk_to_root(path):\n        check_path = os.path.join(dirname, filename)\n        if os.path.isfile(check_path):\n            return check_path\n\n    if raise_error_if_not_found:\n        raise IOError(\"File not found\")\n\n    return \"\"\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.ENVs.find_dotenv_dir","title":"<code>find_dotenv_dir(filename='.env', raise_error_if_not_found=False, usecwd=False)</code>  <code>staticmethod</code>","text":"<p>Search in increasingly higher folders for the given file</p> <p>Returns path to the file if found, or an empty string otherwise</p> Source code in <code>hyfi/utils/envs.py</code> <pre><code>@staticmethod\ndef find_dotenv_dir(\n    filename: str = \".env\",\n    raise_error_if_not_found: bool = False,\n    usecwd: bool = False,\n) -&gt; str:\n    \"\"\"\n    Search in increasingly higher folders for the given file\n\n    Returns path to the file if found, or an empty string otherwise\n    \"\"\"\n    if dotenv_path := ENVs.find_dotenv(\n        filename=filename,\n        raise_error_if_not_found=raise_error_if_not_found,\n        usecwd=usecwd,\n    ):\n        return os.path.dirname(dotenv_path)\n    return \"\"\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.ENVs.get_osenv","title":"<code>get_osenv(key='', default=None)</code>  <code>staticmethod</code>","text":"<p>Get the value of an environment variable or return the default value</p> Source code in <code>hyfi/utils/envs.py</code> <pre><code>@staticmethod\ndef get_osenv(key: str = \"\", default: Optional[str] = None) -&gt; Any:\n    \"\"\"Get the value of an environment variable or return the default value\"\"\"\n    ENVs.load_dotenv()\n    return os.environ.get(key, default) if key else os.environ\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.ENVs.getcwd","title":"<code>getcwd()</code>  <code>staticmethod</code>","text":"<p>Get the original working directory before Hydra changed it.</p> <p>This function tries to call the <code>get_original_cwd</code> function from the <code>hydra.utils</code> module, which returns the original working directory if it exists. If the <code>get_original_cwd</code> function raises a <code>ValueError</code> exception, it means that Hydra did not change the working directory, so the function falls back to calling the <code>os.getcwd</code> function, which returns the current working directory.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The original working directory before Hydra changed it.</p> Source code in <code>hyfi/utils/envs.py</code> <pre><code>@staticmethod\ndef getcwd():\n    \"\"\"Get the original working directory before Hydra changed it.\n\n    This function tries to call the `get_original_cwd` function from the `hydra.utils` module,\n    which returns the original working directory if it exists. If the `get_original_cwd` function\n    raises a `ValueError` exception, it means that Hydra did not change the working directory,\n    so the function falls back to calling the `os.getcwd` function, which returns the current\n    working directory.\n\n    Returns:\n        str: The original working directory before Hydra changed it.\n    \"\"\"\n    try:\n        return hydra.utils.get_original_cwd()\n    except ValueError:\n        return os.getcwd()\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.ENVs.is_interactive","title":"<code>is_interactive()</code>  <code>staticmethod</code>","text":"<p>Decide whether this is running in a REPL or IPython notebook</p> Source code in <code>hyfi/utils/envs.py</code> <pre><code>@staticmethod\ndef is_interactive():\n    \"\"\"Decide whether this is running in a REPL or IPython notebook\"\"\"\n    main = __import__(\"__main__\", None, None, fromlist=[\"__file__\"])\n    return not hasattr(main, \"__file__\")\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.ENVs.load_dotenv","title":"<code>load_dotenv(override=False, dotenv_file='.env', raise_error_if_not_found=False, usecwd=False, verbose=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Load. env file from given directory or from current directory. This is a convenience function for use in tests that want to run dotenv in a non - interactive environment</p> <p>Parameters:</p> Name Type Description Default <code>override</code> <code>bool</code> <p>If True override existing. env file</p> <code>False</code> <code>dotenv_file</code> <code>str</code> <p>Name of. env file to look for in given directory or current directory</p> <code>'.env'</code> <code>verbose</code> <code>bool</code> <p>Print debug information to console</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None or a Path object for the. env file</p> Source code in <code>hyfi/utils/envs.py</code> <pre><code>@staticmethod\ndef load_dotenv(\n    override: bool = False,\n    dotenv_file: str = \".env\",\n    raise_error_if_not_found: bool = False,\n    usecwd: bool = False,\n    verbose: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Load. env file from given directory or from current directory. This is a convenience function for use in tests that want to run dotenv in a non - interactive environment\n\n    Args:\n        override: If True override existing. env file\n        dotenv_file: Name of. env file to look for in given directory or current directory\n        verbose: Print debug information to console\n\n    Returns:\n        None or a Path object for the. env file\n    \"\"\"\n    dotenv_path = Path(dotenv_file)\n    if not dotenv_path.is_absolute():\n        dotenv_path = Path(ENVs.getcwd()) / dotenv_path\n    dotenv_filename = dotenv_path.name\n    dotenv_dir = str(dotenv_path.parent)\n    # Load. env files and directories.\n    if dotenv_path.is_file():\n        dotenv.load_dotenv(\n            dotenv_path=str(dotenv_path),\n            verbose=verbose,\n            override=override,\n            **kwargs,\n        )\n        os.environ[\"DOTENV_FILENAME\"] = dotenv_filename\n        os.environ[\"DOTENV_FILE\"] = str(dotenv_path)\n        os.environ[\"DOTENV_DIR\"] = dotenv_dir\n        # Load. env from dotenv_path.\n        logger.info(\"Loaded .env from [%s]\", dotenv_path)\n    else:\n        # If verbose is true print out the. env file.\n        logger.info(\"[%s] not found, finding .env in parent dirs\", dotenv_path)\n        # Find. env file in parent directories.\n        if dotenv_path := ENVs.find_dotenv(\n            filename=dotenv_filename,\n            raise_error_if_not_found=raise_error_if_not_found,\n            usecwd=usecwd,\n        ):\n            dotenv.load_dotenv(\n                dotenv_path=dotenv_path,\n                verbose=verbose,\n                override=override,\n                **kwargs,\n            )\n            dotenv_path = Path(dotenv_path)\n            dotenv_filename = dotenv_path.name\n            dotenv_dir = str(dotenv_path.parent)\n            os.environ[\"DOTENV_FILENAME\"] = dotenv_filename\n            os.environ[\"DOTENV_FILE\"] = str(dotenv_path)\n            os.environ[\"DOTENV_DIR\"] = dotenv_dir\n            # Load. env from dotenv_path.\n            logger.info(\"Loaded .env from [%s]\", dotenv_path)\n        else:\n            os.environ[\"DOTENV_FILE\"] = \"\"\n            os.environ[\"DOTENV_DIR\"] = \"\"\n            # Print out the. env file if verbose is true.\n            logger.info(\"No .env file found in the parent dirs of [%s]\", dotenv_dir)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.ENVs.osenv","title":"<code>osenv()</code>  <code>staticmethod</code>","text":"<p>Return the os environment variables as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the os environment variables.</p> Source code in <code>hyfi/utils/envs.py</code> <pre><code>@staticmethod\ndef osenv():\n    \"\"\"\n    Return the os environment variables as a dictionary.\n\n    Returns:\n        dict: A dictionary containing the os environment variables.\n    \"\"\"\n    return os.environ\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.ENVs.set_osenv","title":"<code>set_osenv(key, value)</code>  <code>staticmethod</code>","text":"<p>Set the value of an environment variable</p> Source code in <code>hyfi/utils/envs.py</code> <pre><code>@staticmethod\ndef set_osenv(key: str, value: Any) -&gt; None:\n    \"\"\"Set the value of an environment variable\"\"\"\n    if value and IOLIBs.is_dir(value):\n        value = os.path.abspath(value)\n    if pre_val := os.environ.get(key):\n        logger.info(\"Overwriting %s=%s with %s\", key, pre_val, value)\n    else:\n        logger.info(\"Setting %s=%s\", key, value)\n    os.setdefault(key, value)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs","title":"<code>FUNCs</code>","text":"Source code in <code>hyfi/utils/funcs.py</code> <pre><code>class FUNCs:\n    @staticmethod\n    def unescape_dict(d):\n        \"\"\"Unescape a dictionary\"\"\"\n        return ast.literal_eval(repr(d).encode(\"utf-8\").decode(\"unicode-escape\"))\n\n    @staticmethod\n    def lower_case_with_underscores(string):\n        \"\"\"Converts 'CamelCased' to 'camel_cased'.\"\"\"\n        return (\n            re.sub(r\"\\s+\", \"_\", re.sub(r\"(?&lt;!^)(?=[A-Z])\", \"_\", string).lower())\n            .replace(\"-\", \"_\")\n            .replace(\"__\", \"_\")\n        )\n\n    @staticmethod\n    def ordinal(num):\n        \"\"\"Return the ordinal of a number as a string.\"\"\"\n        return \"%d%s\" % (\n            num,\n            \"tsnrhtdd\"[(num // 10 % 10 != 1) * (num % 10 &lt; 4) * num % 10 :: 4],\n        )\n\n    @staticmethod\n    def get_offset_ranges(count, num_workers):\n        \"\"\"Get offset ranges for parallel processing\"\"\"\n        assert count &gt; num_workers\n        step_sz = int(count / num_workers)\n        offset_ranges = [0]\n        pv_cnt = 1\n        for i in range(num_workers):\n            pv_cnt = count + 1 if i == num_workers - 1 else pv_cnt + step_sz\n            offset_ranges.append(pv_cnt)\n        return offset_ranges\n\n    @staticmethod\n    def fancy_print(*args, color=None, bold=False, **kwargs):\n        \"\"\"Print with color and bold\"\"\"\n        if bold:\n            print(\"\\033[1m\", end=\"\")\n\n        if color:\n            print(f\"\\033[{color}m\", end=\"\")\n\n        print(*args, **kwargs)\n\n        print(\"\\033[0m\", end=\"\")  # reset\n\n    # https://stackoverflow.com/questions/12523586/python-format-size-application-converting-b-to-kb-mb-gb-tb/37423778\n    @staticmethod\n    def humanbytes(B, units=None):\n        \"Return the given bytes as a human friendly KB, MB, GB, or TB string\"\n        B = float(B)\n        KB = float(1024)\n        MB = float(KB**2)  # 1,048,576\n        GB = float(KB**3)  # 1,073,741,824\n        TB = float(KB**4)  # 1,099,511,627,776\n\n        if (B &lt; KB and units is None) or units == \"B\":\n            return \"{0} {1}\".format(B, \"Bytes\" if 0 == B &gt; 1 else \"Byte\")\n        elif (KB &lt;= B &lt; MB and units is None) or units == \"KiB\":\n            return \"{0:.2f} KiB\".format(B / KB)\n        elif (MB &lt;= B &lt; GB and units is None) or units == \"MiB\":\n            return \"{0:.2f} MiB\".format(B / MB)\n        elif (GB &lt;= B &lt; TB and units is None) or units == \"GiB\":\n            return \"{0:.2f} GiB\".format(B / GB)\n        elif (TB &lt;= B and units is None) or units == \"TiB\":\n            return \"{0:.2f} TiB\".format(B / TB)\n\n    @staticmethod\n    def parse_size(sizestr):\n        \"\"\"\n        Parse a size string into a number of bytes. For example, \"16K\" will\n        return 16384.  If no suffix is provided, bytes are assumed.  This\n        function is case-insensitive.\n\n        :param sizestr: A string representing a size, such as \"16K\", \"2M\", \"1G\".\n        :return: The number of bytes that the string represents.\n        \"\"\"\n        unit = sizestr[-1]\n        size = float(sizestr[:-1])\n\n        if unit.upper() == \"B\":\n            return size\n        if unit.upper() == \"K\":\n            return size * 1024\n        if unit.upper() == \"M\":\n            return size * 1024 * 1024\n        if unit.upper() == \"G\":\n            return size * 1024 * 1024 * 1024\n        if unit.upper() == \"T\":\n            return size * 1024 * 1024 * 1024 * 1024\n\n    @staticmethod\n    def check_min_len(s, len_func, min_len):\n        \"\"\"Check if the length of a string is greater than or equal to a minimum length\"\"\"\n        return len_func(s) &gt;= min_len\n\n    @staticmethod\n    def check_max_len(s, len_func, max_len):\n        \"\"\"Check if the length of a string is less than or equal to a maximum length\"\"\"\n        return len_func(s) &lt;= max_len\n\n    @staticmethod\n    def utf8len(s):\n        \"\"\"Return the length of a string in bytes\"\"\"\n        return len(str(s).encode(\"utf-8\"))\n\n    @staticmethod\n    def len_wospc(x):\n        \"\"\"Return the length of a string in bytes without spaces\"\"\"\n        return FUNCs.utf8len(re.sub(r\"\\s\", \"\", str(x)))\n\n    @staticmethod\n    def len_bytes(x):\n        \"\"\"Return the length of a string in bytes\"\"\"\n        return FUNCs.utf8len(x)\n\n    @staticmethod\n    def len_words(x):\n        \"\"\"Return the number of words in a string\"\"\"\n        return len(x.split()) if isinstance(x, str) else 0\n\n    @staticmethod\n    def len_sents(x, sep):\n        \"\"\"Return the number of sentences in a string\"\"\"\n        sep = str(sep).encode(\"utf-8\").decode(\"unicode-escape\")\n        return len(re.sub(r\"(\\r?\\n|\\r){1,}\", sep, x).split(sep))\n\n    @staticmethod\n    def len_segments(x, sep):\n        \"\"\"Return the number of segments in a string\"\"\"\n        sep = str(sep).encode(\"utf-8\").decode(\"unicode-escape\")\n        return len(re.sub(r\"(\\r?\\n|\\r){2,}\", sep, x).split(sep))\n\n    @staticmethod\n    def any_to_utf8(b):\n        \"\"\"Convert any string to utf-8\"\"\"\n        try:\n            return b.decode(\"utf-8\")\n        except UnicodeDecodeError:\n            # try to figure out encoding if not utf-8\n\n            guess = chardet.detect(b)[\"encoding\"]\n\n            if not guess or guess == \"UTF-8\":\n                return\n\n            try:\n                return b.decode(guess)\n            except (UnicodeDecodeError, LookupError):\n                # still cant figure out encoding, give up\n                return\n\n    @staticmethod\n    def today(_format=\"%Y-%m-%d\"):\n        \"\"\"Return today's date\"\"\"\n        from datetime import datetime\n\n        if _format is None:\n            return datetime.today().date()\n        else:\n            return datetime.today().strftime(_format)\n\n    @staticmethod\n    def now(_format=\"%Y-%m-%d %H:%M:%S\"):\n        \"\"\"Return current date and time\"\"\"\n        from datetime import datetime\n\n        return datetime.now() if _format is None else datetime.now().strftime(_format)\n\n    @staticmethod\n    def strptime(\n        _date_str: str,\n        _format: str = \"%Y-%m-%d\",\n    ):\n        \"\"\"Return a datetime object from a string\"\"\"\n        from datetime import datetime\n\n        return datetime.strptime(_date_str, _format)\n\n    @staticmethod\n    def to_dateparm(_date, _format=\"%Y-%m-%d\"):\n        \"\"\"Return a date parameter string\"\"\"\n        from datetime import datetime\n\n        _dtstr = datetime.strftime(_date, _format)\n        _dtstr = \"${to_datetime:\" + _dtstr + \",\" + _format + \"}\"\n        return _dtstr\n\n    @staticmethod\n    def human_readable_type_name(t: Type) -&gt; str:\n        \"\"\"\n        Generates a useful-for-humans label for a type.\n        For builtin types, it's just the class name (eg \"str\" or \"int\").\n        For other types, it includes the module (eg \"pathlib.Path\").\n        \"\"\"\n        module = t.__module__\n        if module == \"builtins\":\n            return t.__qualname__\n        elif module.split(\".\")[0] == \"hyfi\":\n            module = \"hyfi\"\n\n        try:\n            return f\"{module}.{t.__qualname__}\"\n        except AttributeError:\n            return str(t)\n\n    @staticmethod\n    def readable_types_list(type_list: List[Type]) -&gt; str:\n        \"\"\"Generates a useful-for-humans label for a list of types.\"\"\"\n        return \", \".join(FUNCs.human_readable_type_name(t) for t in type_list)\n\n    @staticmethod\n    def dict_product(dicts) -&gt; List[Dict]:\n        \"\"\"\n        &gt;&gt;&gt; list(dict_product(dict(number=[1,2], character='ab')))\n        [{'character': 'a', 'number': 1},\n        {'character': 'a', 'number': 2},\n        {'character': 'b', 'number': 1},\n        {'character': 'b', 'number': 2}]\n        \"\"\"\n        return [dict(zip(dicts, x)) for x in itertools.product(*dicts.values())]\n\n    @staticmethod\n    def printf(\n        action: str,\n        msg: Any = \"\",\n        style: Optional[IntSeq] = None,\n        indent: int = 10,\n        verbose: Union[bool, StrictBool] = True,\n        file_: TextIO = sys.stdout,\n    ) -&gt; Optional[str]:\n        \"\"\"Print string with common format.\"\"\"\n        if not verbose:\n            return None  # HACK: Satisfy MyPy\n        _msg = str(msg)\n        action = action.rjust(indent, \" \")\n        if not style:\n            return action + _msg\n\n        out = style + [action] + Style.RESET + [INDENT, _msg]  # type: ignore\n        print(*out, sep=\"\", file=file_)\n        return None  # HACK: Satisfy MyPy\n\n    @staticmethod\n    def printf_exception(\n        e: Exception, action: str, msg: str = \"\", indent: int = 0, quiet: bool = False\n    ) -&gt; None:\n        \"\"\"Print exception with common format.\"\"\"\n        if not quiet:\n            print(\"\", file=sys.stderr)\n            FUNCs.printf(\n                action, msg=msg, style=Style.DANGER, indent=indent, file_=sys.stderr\n            )\n            print(HLINE, file=sys.stderr)\n            print(e, file=sys.stderr)\n            print(HLINE, file=sys.stderr)\n\n    @staticmethod\n    def cast_str_to_bool(value: Any) -&gt; bool:\n        \"\"\"Parse anything to bool.\n\n        Params:\n            value:\n                Anything to be casted to a bool. Tries to be as smart as possible.\n\n                1.  Cast to number. Then: 0 = False; anything else = True.\n                1.  Find [YAML booleans](https://yaml.org/type/bool.html),\n                    [YAML nulls](https://yaml.org/type/null.html) or `none` in it\n                    and use it appropriately.\n                1.  Cast to boolean using standard python `bool(value)`.\n        \"\"\"\n        # Assume it's a number\n        with suppress(TypeError, ValueError):\n            return bool(float(value))\n        # Assume it's a string\n        with suppress(AttributeError):\n            lower = value.lower()\n            if lower in {\"y\", \"yes\", \"t\", \"true\", \"on\"}:\n                return True\n            elif lower in {\"n\", \"no\", \"f\", \"false\", \"off\", \"~\", \"null\", \"none\"}:\n                return False\n        # Assume nothing\n        return bool(value)\n\n    @staticmethod\n    def force_str_end(original_str: str, end: str = \"\\n\") -&gt; str:\n        \"\"\"Make sure a `original_str` ends with `end`.\n\n        Params:\n            original_str: String that you want to ensure ending.\n            end: String that must exist at the end of `original_str`\n        \"\"\"\n        return original_str if original_str.endswith(end) else original_str + end\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.any_to_utf8","title":"<code>any_to_utf8(b)</code>  <code>staticmethod</code>","text":"<p>Convert any string to utf-8</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef any_to_utf8(b):\n    \"\"\"Convert any string to utf-8\"\"\"\n    try:\n        return b.decode(\"utf-8\")\n    except UnicodeDecodeError:\n        # try to figure out encoding if not utf-8\n\n        guess = chardet.detect(b)[\"encoding\"]\n\n        if not guess or guess == \"UTF-8\":\n            return\n\n        try:\n            return b.decode(guess)\n        except (UnicodeDecodeError, LookupError):\n            # still cant figure out encoding, give up\n            return\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.cast_str_to_bool","title":"<code>cast_str_to_bool(value)</code>  <code>staticmethod</code>","text":"<p>Parse anything to bool.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Anything to be casted to a bool. Tries to be as smart as possible.</p> <ol> <li>Cast to number. Then: 0 = False; anything else = True.</li> <li>Find YAML booleans,     YAML nulls or <code>none</code> in it     and use it appropriately.</li> <li>Cast to boolean using standard python <code>bool(value)</code>.</li> </ol> required Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef cast_str_to_bool(value: Any) -&gt; bool:\n    \"\"\"Parse anything to bool.\n\n    Params:\n        value:\n            Anything to be casted to a bool. Tries to be as smart as possible.\n\n            1.  Cast to number. Then: 0 = False; anything else = True.\n            1.  Find [YAML booleans](https://yaml.org/type/bool.html),\n                [YAML nulls](https://yaml.org/type/null.html) or `none` in it\n                and use it appropriately.\n            1.  Cast to boolean using standard python `bool(value)`.\n    \"\"\"\n    # Assume it's a number\n    with suppress(TypeError, ValueError):\n        return bool(float(value))\n    # Assume it's a string\n    with suppress(AttributeError):\n        lower = value.lower()\n        if lower in {\"y\", \"yes\", \"t\", \"true\", \"on\"}:\n            return True\n        elif lower in {\"n\", \"no\", \"f\", \"false\", \"off\", \"~\", \"null\", \"none\"}:\n            return False\n    # Assume nothing\n    return bool(value)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.check_max_len","title":"<code>check_max_len(s, len_func, max_len)</code>  <code>staticmethod</code>","text":"<p>Check if the length of a string is less than or equal to a maximum length</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef check_max_len(s, len_func, max_len):\n    \"\"\"Check if the length of a string is less than or equal to a maximum length\"\"\"\n    return len_func(s) &lt;= max_len\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.check_min_len","title":"<code>check_min_len(s, len_func, min_len)</code>  <code>staticmethod</code>","text":"<p>Check if the length of a string is greater than or equal to a minimum length</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef check_min_len(s, len_func, min_len):\n    \"\"\"Check if the length of a string is greater than or equal to a minimum length\"\"\"\n    return len_func(s) &gt;= min_len\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.dict_product","title":"<code>dict_product(dicts)</code>  <code>staticmethod</code>","text":"<p>list(dict_product(dict(number=[1,2], character='ab'))) [{'character': 'a', 'number': 1}, {'character': 'a', 'number': 2}, {'character': 'b', 'number': 1}, {'character': 'b', 'number': 2}]</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef dict_product(dicts) -&gt; List[Dict]:\n    \"\"\"\n    &gt;&gt;&gt; list(dict_product(dict(number=[1,2], character='ab')))\n    [{'character': 'a', 'number': 1},\n    {'character': 'a', 'number': 2},\n    {'character': 'b', 'number': 1},\n    {'character': 'b', 'number': 2}]\n    \"\"\"\n    return [dict(zip(dicts, x)) for x in itertools.product(*dicts.values())]\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.fancy_print","title":"<code>fancy_print(*args, color=None, bold=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Print with color and bold</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef fancy_print(*args, color=None, bold=False, **kwargs):\n    \"\"\"Print with color and bold\"\"\"\n    if bold:\n        print(\"\\033[1m\", end=\"\")\n\n    if color:\n        print(f\"\\033[{color}m\", end=\"\")\n\n    print(*args, **kwargs)\n\n    print(\"\\033[0m\", end=\"\")  # reset\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.force_str_end","title":"<code>force_str_end(original_str, end='\\n')</code>  <code>staticmethod</code>","text":"<p>Make sure a <code>original_str</code> ends with <code>end</code>.</p> <p>Parameters:</p> Name Type Description Default <code>original_str</code> <code>str</code> <p>String that you want to ensure ending.</p> required <code>end</code> <code>str</code> <p>String that must exist at the end of <code>original_str</code></p> <code>'\\n'</code> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef force_str_end(original_str: str, end: str = \"\\n\") -&gt; str:\n    \"\"\"Make sure a `original_str` ends with `end`.\n\n    Params:\n        original_str: String that you want to ensure ending.\n        end: String that must exist at the end of `original_str`\n    \"\"\"\n    return original_str if original_str.endswith(end) else original_str + end\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.get_offset_ranges","title":"<code>get_offset_ranges(count, num_workers)</code>  <code>staticmethod</code>","text":"<p>Get offset ranges for parallel processing</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef get_offset_ranges(count, num_workers):\n    \"\"\"Get offset ranges for parallel processing\"\"\"\n    assert count &gt; num_workers\n    step_sz = int(count / num_workers)\n    offset_ranges = [0]\n    pv_cnt = 1\n    for i in range(num_workers):\n        pv_cnt = count + 1 if i == num_workers - 1 else pv_cnt + step_sz\n        offset_ranges.append(pv_cnt)\n    return offset_ranges\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.human_readable_type_name","title":"<code>human_readable_type_name(t)</code>  <code>staticmethod</code>","text":"<p>Generates a useful-for-humans label for a type. For builtin types, it's just the class name (eg \"str\" or \"int\"). For other types, it includes the module (eg \"pathlib.Path\").</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef human_readable_type_name(t: Type) -&gt; str:\n    \"\"\"\n    Generates a useful-for-humans label for a type.\n    For builtin types, it's just the class name (eg \"str\" or \"int\").\n    For other types, it includes the module (eg \"pathlib.Path\").\n    \"\"\"\n    module = t.__module__\n    if module == \"builtins\":\n        return t.__qualname__\n    elif module.split(\".\")[0] == \"hyfi\":\n        module = \"hyfi\"\n\n    try:\n        return f\"{module}.{t.__qualname__}\"\n    except AttributeError:\n        return str(t)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.humanbytes","title":"<code>humanbytes(B, units=None)</code>  <code>staticmethod</code>","text":"<p>Return the given bytes as a human friendly KB, MB, GB, or TB string</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef humanbytes(B, units=None):\n    \"Return the given bytes as a human friendly KB, MB, GB, or TB string\"\n    B = float(B)\n    KB = float(1024)\n    MB = float(KB**2)  # 1,048,576\n    GB = float(KB**3)  # 1,073,741,824\n    TB = float(KB**4)  # 1,099,511,627,776\n\n    if (B &lt; KB and units is None) or units == \"B\":\n        return \"{0} {1}\".format(B, \"Bytes\" if 0 == B &gt; 1 else \"Byte\")\n    elif (KB &lt;= B &lt; MB and units is None) or units == \"KiB\":\n        return \"{0:.2f} KiB\".format(B / KB)\n    elif (MB &lt;= B &lt; GB and units is None) or units == \"MiB\":\n        return \"{0:.2f} MiB\".format(B / MB)\n    elif (GB &lt;= B &lt; TB and units is None) or units == \"GiB\":\n        return \"{0:.2f} GiB\".format(B / GB)\n    elif (TB &lt;= B and units is None) or units == \"TiB\":\n        return \"{0:.2f} TiB\".format(B / TB)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.len_bytes","title":"<code>len_bytes(x)</code>  <code>staticmethod</code>","text":"<p>Return the length of a string in bytes</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef len_bytes(x):\n    \"\"\"Return the length of a string in bytes\"\"\"\n    return FUNCs.utf8len(x)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.len_segments","title":"<code>len_segments(x, sep)</code>  <code>staticmethod</code>","text":"<p>Return the number of segments in a string</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef len_segments(x, sep):\n    \"\"\"Return the number of segments in a string\"\"\"\n    sep = str(sep).encode(\"utf-8\").decode(\"unicode-escape\")\n    return len(re.sub(r\"(\\r?\\n|\\r){2,}\", sep, x).split(sep))\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.len_sents","title":"<code>len_sents(x, sep)</code>  <code>staticmethod</code>","text":"<p>Return the number of sentences in a string</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef len_sents(x, sep):\n    \"\"\"Return the number of sentences in a string\"\"\"\n    sep = str(sep).encode(\"utf-8\").decode(\"unicode-escape\")\n    return len(re.sub(r\"(\\r?\\n|\\r){1,}\", sep, x).split(sep))\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.len_words","title":"<code>len_words(x)</code>  <code>staticmethod</code>","text":"<p>Return the number of words in a string</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef len_words(x):\n    \"\"\"Return the number of words in a string\"\"\"\n    return len(x.split()) if isinstance(x, str) else 0\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.len_wospc","title":"<code>len_wospc(x)</code>  <code>staticmethod</code>","text":"<p>Return the length of a string in bytes without spaces</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef len_wospc(x):\n    \"\"\"Return the length of a string in bytes without spaces\"\"\"\n    return FUNCs.utf8len(re.sub(r\"\\s\", \"\", str(x)))\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.lower_case_with_underscores","title":"<code>lower_case_with_underscores(string)</code>  <code>staticmethod</code>","text":"<p>Converts 'CamelCased' to 'camel_cased'.</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef lower_case_with_underscores(string):\n    \"\"\"Converts 'CamelCased' to 'camel_cased'.\"\"\"\n    return (\n        re.sub(r\"\\s+\", \"_\", re.sub(r\"(?&lt;!^)(?=[A-Z])\", \"_\", string).lower())\n        .replace(\"-\", \"_\")\n        .replace(\"__\", \"_\")\n    )\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.now","title":"<code>now(_format='%Y-%m-%d %H:%M:%S')</code>  <code>staticmethod</code>","text":"<p>Return current date and time</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef now(_format=\"%Y-%m-%d %H:%M:%S\"):\n    \"\"\"Return current date and time\"\"\"\n    from datetime import datetime\n\n    return datetime.now() if _format is None else datetime.now().strftime(_format)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.ordinal","title":"<code>ordinal(num)</code>  <code>staticmethod</code>","text":"<p>Return the ordinal of a number as a string.</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef ordinal(num):\n    \"\"\"Return the ordinal of a number as a string.\"\"\"\n    return \"%d%s\" % (\n        num,\n        \"tsnrhtdd\"[(num // 10 % 10 != 1) * (num % 10 &lt; 4) * num % 10 :: 4],\n    )\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.parse_size","title":"<code>parse_size(sizestr)</code>  <code>staticmethod</code>","text":"<p>Parse a size string into a number of bytes. For example, \"16K\" will return 16384.  If no suffix is provided, bytes are assumed.  This function is case-insensitive.</p> <p>:param sizestr: A string representing a size, such as \"16K\", \"2M\", \"1G\". :return: The number of bytes that the string represents.</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef parse_size(sizestr):\n    \"\"\"\n    Parse a size string into a number of bytes. For example, \"16K\" will\n    return 16384.  If no suffix is provided, bytes are assumed.  This\n    function is case-insensitive.\n\n    :param sizestr: A string representing a size, such as \"16K\", \"2M\", \"1G\".\n    :return: The number of bytes that the string represents.\n    \"\"\"\n    unit = sizestr[-1]\n    size = float(sizestr[:-1])\n\n    if unit.upper() == \"B\":\n        return size\n    if unit.upper() == \"K\":\n        return size * 1024\n    if unit.upper() == \"M\":\n        return size * 1024 * 1024\n    if unit.upper() == \"G\":\n        return size * 1024 * 1024 * 1024\n    if unit.upper() == \"T\":\n        return size * 1024 * 1024 * 1024 * 1024\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.printf","title":"<code>printf(action, msg='', style=None, indent=10, verbose=True, file_=sys.stdout)</code>  <code>staticmethod</code>","text":"<p>Print string with common format.</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef printf(\n    action: str,\n    msg: Any = \"\",\n    style: Optional[IntSeq] = None,\n    indent: int = 10,\n    verbose: Union[bool, StrictBool] = True,\n    file_: TextIO = sys.stdout,\n) -&gt; Optional[str]:\n    \"\"\"Print string with common format.\"\"\"\n    if not verbose:\n        return None  # HACK: Satisfy MyPy\n    _msg = str(msg)\n    action = action.rjust(indent, \" \")\n    if not style:\n        return action + _msg\n\n    out = style + [action] + Style.RESET + [INDENT, _msg]  # type: ignore\n    print(*out, sep=\"\", file=file_)\n    return None  # HACK: Satisfy MyPy\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.printf_exception","title":"<code>printf_exception(e, action, msg='', indent=0, quiet=False)</code>  <code>staticmethod</code>","text":"<p>Print exception with common format.</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef printf_exception(\n    e: Exception, action: str, msg: str = \"\", indent: int = 0, quiet: bool = False\n) -&gt; None:\n    \"\"\"Print exception with common format.\"\"\"\n    if not quiet:\n        print(\"\", file=sys.stderr)\n        FUNCs.printf(\n            action, msg=msg, style=Style.DANGER, indent=indent, file_=sys.stderr\n        )\n        print(HLINE, file=sys.stderr)\n        print(e, file=sys.stderr)\n        print(HLINE, file=sys.stderr)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.readable_types_list","title":"<code>readable_types_list(type_list)</code>  <code>staticmethod</code>","text":"<p>Generates a useful-for-humans label for a list of types.</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef readable_types_list(type_list: List[Type]) -&gt; str:\n    \"\"\"Generates a useful-for-humans label for a list of types.\"\"\"\n    return \", \".join(FUNCs.human_readable_type_name(t) for t in type_list)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.strptime","title":"<code>strptime(_date_str, _format='%Y-%m-%d')</code>  <code>staticmethod</code>","text":"<p>Return a datetime object from a string</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef strptime(\n    _date_str: str,\n    _format: str = \"%Y-%m-%d\",\n):\n    \"\"\"Return a datetime object from a string\"\"\"\n    from datetime import datetime\n\n    return datetime.strptime(_date_str, _format)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.to_dateparm","title":"<code>to_dateparm(_date, _format='%Y-%m-%d')</code>  <code>staticmethod</code>","text":"<p>Return a date parameter string</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef to_dateparm(_date, _format=\"%Y-%m-%d\"):\n    \"\"\"Return a date parameter string\"\"\"\n    from datetime import datetime\n\n    _dtstr = datetime.strftime(_date, _format)\n    _dtstr = \"${to_datetime:\" + _dtstr + \",\" + _format + \"}\"\n    return _dtstr\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.today","title":"<code>today(_format='%Y-%m-%d')</code>  <code>staticmethod</code>","text":"<p>Return today's date</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef today(_format=\"%Y-%m-%d\"):\n    \"\"\"Return today's date\"\"\"\n    from datetime import datetime\n\n    if _format is None:\n        return datetime.today().date()\n    else:\n        return datetime.today().strftime(_format)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.unescape_dict","title":"<code>unescape_dict(d)</code>  <code>staticmethod</code>","text":"<p>Unescape a dictionary</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef unescape_dict(d):\n    \"\"\"Unescape a dictionary\"\"\"\n    return ast.literal_eval(repr(d).encode(\"utf-8\").decode(\"unicode-escape\"))\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.FUNCs.utf8len","title":"<code>utf8len(s)</code>  <code>staticmethod</code>","text":"<p>Return the length of a string in bytes</p> Source code in <code>hyfi/utils/funcs.py</code> <pre><code>@staticmethod\ndef utf8len(s):\n    \"\"\"Return the length of a string in bytes\"\"\"\n    return len(str(s).encode(\"utf-8\"))\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.GPUs","title":"<code>GPUs</code>","text":"Source code in <code>hyfi/utils/gpumon.py</code> <pre><code>class GPUs:\n    ###############################\n    # GPU Utility functions\n    ###############################\n    @staticmethod\n    def nvidia_smi():\n        return nvidia_smi()\n\n    @staticmethod\n    def set_cuda(device=0):\n        return set_cuda(device)\n\n    @staticmethod\n    def gpu_usage(all=False, attrList=None, useOldCode=False):\n        \"\"\"\n        Show GPU utilization in human readable format. This is a wrapper around the GPUtil library.\n\n        Args:\n                all: If True show all available GPUs ( default : False )\n                attrList: List of attributes to show ( default : None )\n                useOldCode: If True use old code instead of new code ( default : False )\n\n        Returns:\n                A string with the\n        \"\"\"\n        try:\n            from GPUtil import showUtilization  # type: ignore\n        except ImportError:\n            logger.error(\"GPUtil is not installed. To install, run: pip install GPUtil\")\n            return\n\n        return showUtilization(all, attrList, useOldCode)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.GPUs.gpu_usage","title":"<code>gpu_usage(all=False, attrList=None, useOldCode=False)</code>  <code>staticmethod</code>","text":"<p>Show GPU utilization in human readable format. This is a wrapper around the GPUtil library.</p> <p>Parameters:</p> Name Type Description Default <code>all</code> <p>If True show all available GPUs ( default : False )</p> <code>False</code> <code>attrList</code> <p>List of attributes to show ( default : None )</p> <code>None</code> <code>useOldCode</code> <p>If True use old code instead of new code ( default : False )</p> <code>False</code> <p>Returns:</p> Type Description <p>A string with the</p> Source code in <code>hyfi/utils/gpumon.py</code> <pre><code>@staticmethod\ndef gpu_usage(all=False, attrList=None, useOldCode=False):\n    \"\"\"\n    Show GPU utilization in human readable format. This is a wrapper around the GPUtil library.\n\n    Args:\n            all: If True show all available GPUs ( default : False )\n            attrList: List of attributes to show ( default : None )\n            useOldCode: If True use old code instead of new code ( default : False )\n\n    Returns:\n            A string with the\n    \"\"\"\n    try:\n        from GPUtil import showUtilization  # type: ignore\n    except ImportError:\n        logger.error(\"GPUtil is not installed. To install, run: pip install GPUtil\")\n        return\n\n    return showUtilization(all, attrList, useOldCode)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs","title":"<code>IOLIBs</code>","text":"Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>class IOLIBs:\n    @staticmethod\n    def is_valid_regex(expr: str) -&gt; bool:\n        \"\"\"Check if a string is a valid regular expression\"\"\"\n        try:\n            if expr.startswith(\"r:\"):\n                expr = expr[2:]\n            else:\n                return False\n            re.compile(expr)\n            return True\n        except re.error:\n            return False\n\n    @staticmethod\n    def glob_re(\n        pattern: str,\n        base_dir: str,\n        recursive: bool = False,\n    ) -&gt; list:\n        \"\"\"Glob files matching a regular expression\"\"\"\n        if IOLIBs.is_valid_regex(pattern):\n            pattern = pattern[2:]\n            rpattern = re.compile(pattern)  # type: ignore\n            files = []\n            if recursive:\n                for dirpath, _, filenames in os.walk(base_dir):\n                    files += [\n                        os.path.join(dirpath, file)\n                        for file in filenames\n                        if rpattern.search(file)\n                    ]\n            else:\n                files = [\n                    os.path.join(base_dir, file)\n                    for file in os.listdir(base_dir)\n                    if rpattern.search(file)\n                ]\n        else:\n            file = os.path.join(base_dir, pattern)\n            files = glob(file, recursive=recursive)\n        return files\n\n    @staticmethod\n    def get_filepaths(\n        filename_patterns: Union[List[PathLikeType], PathLikeType],\n        base_dir: Optional[Union[str, PosixPath, WindowsPath]] = None,\n        recursive: bool = True,\n        use_cached: bool = False,\n        verbose: bool = False,\n        **kwargs,\n    ) -&gt; List[str]:\n        \"\"\"Get a list of filepaths from a list of filename patterns\"\"\"\n        if filename_patterns is None:\n            raise ValueError(\"filename_patterns must be specified\")\n        if isinstance(filename_patterns, (PosixPath, WindowsPath)):\n            filename_patterns = str(filename_patterns)\n        if isinstance(filename_patterns, str):\n            filename_patterns = [filename_patterns]\n        filepaths = []\n        base_dir = str(base_dir) if base_dir else \"\"\n        for f_pattern in filename_patterns:\n            f_pattern = str(f_pattern)\n            if f_pattern.startswith(\"http\") and not use_cached:\n                filepaths.append(f_pattern)\n            else:\n                if f_pattern.startswith(\"http\"):\n                    filepath = IOLIBs.cached_path(f_pattern, **kwargs)\n                else:\n                    filepath = os.path.join(base_dir, f_pattern)\n                if isinstance(filepath, str) and os.path.exists(filepath):\n                    if Path(filepath).is_file():\n                        filepaths.append(filepath)\n                else:\n                    if os.path.dirname(f_pattern) != \"\":\n                        _dir = os.path.dirname(f_pattern)\n                        f_pattern = os.path.basename(f_pattern)\n                        base_dir = os.path.join(base_dir, _dir)\n                    filepaths += IOLIBs.glob_re(\n                        f_pattern, base_dir, recursive=recursive\n                    )\n        filepaths = [\n            fp for fp in filepaths if Path(fp).is_file() or fp.startswith(\"http\")\n        ]\n        if verbose:\n            logger.info(f\"Processing [{len(filepaths)}] files from {filename_patterns}\")\n\n        return filepaths\n\n    @staticmethod\n    def get_files_from_archive(archive_path: str, filetype: str = \"\"):\n        \"\"\"Get a list of files from an archive\"\"\"\n        import tarfile\n        from zipfile import ZipFile\n\n        if \".tar.gz\" in archive_path:\n            logger.info(f\"::Extracting files from {archive_path} with tar.gz\")\n            archive_handle = tarfile.open(archive_path, \"r:gz\")\n            files = [\n                (file, file.name)\n                for file in archive_handle.getmembers()\n                if file.isfile()\n            ]\n            open_func = archive_handle.extractfile\n        elif \".tar.bz2\" in archive_path:\n            logger.info(f\"::Extracting files from {archive_path} with tar.bz2\")\n            archive_handle = tarfile.open(archive_path, \"r:bz2\")\n            files = [\n                (file, file.name)\n                for file in archive_handle.getmembers()\n                if file.isfile()\n            ]\n            open_func = archive_handle.extractfile\n        elif \".zip\" in archive_path:\n            logger.info(f\"::Extracting files from {archive_path} with zip\")\n            archive_handle = ZipFile(archive_path)\n            files = [\n                (file, file.encode(\"cp437\").decode(\"euc-kr\"))\n                for file in archive_handle.namelist()\n            ]\n            open_func = archive_handle.open\n        else:\n            # print(f'::{archive_path} is not archive, use generic method')\n            files = [(archive_path, os.path.basename(archive_path))]\n            archive_handle = None\n            open_func = None\n        if filetype:\n            files = [file for file in files if filetype in file[1]]\n\n        return files, archive_handle, open_func\n\n    @staticmethod\n    def read(uri, mode=\"rb\", encoding=None, head=None, **kwargs) -&gt; bytes:\n        \"\"\"Read data from a file or url\"\"\"\n        uri = str(uri)\n        if uri.startswith(\"http\"):\n            import requests\n\n            if mode == \"r\" and head is not None and isinstance(head, int):\n                r = requests.get(uri, stream=True)\n                r.raw.decode_content = True\n                return r.raw.read(head)\n            return requests.get(uri, **kwargs).content\n        # elif uri.startswith(\"s3://\"):\n        #     import boto3\n\n        #     s3 = boto3.resource(\"s3\")\n        #     bucket, key = uri.replace(\"s3://\", \"\").split(\"/\", 1)\n        #     obj = s3.Object(bucket, key)\n        #     return obj.get()[\"Body\"].read()\n        else:\n            with open(uri, mode=mode, encoding=encoding) as f:\n                if mode == \"r\" and head is not None and isinstance(head, int):\n                    return f.read(head)\n                return f.read()\n\n    @staticmethod\n    def walk_to_root(path: str) -&gt; Iterator[str]:\n        \"\"\"\n        Yield directories starting from the given directory up to the root\n        \"\"\"\n        if not os.path.exists(path):\n            raise IOError(\"Starting path not found\")\n\n        if os.path.isfile(path):\n            path = os.path.dirname(path)\n\n        last_dir = None\n        current_dir = os.path.abspath(path)\n        while last_dir != current_dir:\n            yield current_dir\n            parent_dir = os.path.abspath(os.path.join(current_dir, os.path.pardir))\n            last_dir, current_dir = current_dir, parent_dir\n\n    @staticmethod\n    def is_file(a, *p) -&gt; bool:\n        \"\"\"Check if path is a file\"\"\"\n        _path = os.path.join(a, *p)\n        return Path(_path).is_file()\n\n    @staticmethod\n    def is_dir(a, *p) -&gt; bool:\n        \"\"\"Check if path is a directory\"\"\"\n        _path = os.path.join(a, *p)\n        return Path(_path).is_dir()\n\n    @staticmethod\n    def check_path(_path: str, alt_path: str = \"\") -&gt; str:\n        \"\"\"Check if path exists, return alt_path if not\"\"\"\n        return _path if os.path.exists(_path) else alt_path\n\n    @staticmethod\n    def mkdir(_path: str) -&gt; str:\n        \"\"\"Create directory if it does not exist\"\"\"\n        if _path is None:\n            return \"\"\n        Path(_path).mkdir(parents=True, exist_ok=True)\n        return _path\n\n    @staticmethod\n    def exists(a, *p) -&gt; bool:\n        \"\"\"Check if path exists\"\"\"\n        if a is None:\n            return False\n        _path = os.path.join(a, *p)\n        return os.path.exists(_path)\n\n    @staticmethod\n    def join_path(a, *p) -&gt; str:\n        \"\"\"Join path components intelligently.\"\"\"\n        if not p or p[0] is None:\n            return a\n        p = [str(_p) for _p in p]\n        return os.path.join(*p) if a is None else os.path.join(a, *p)\n\n    @staticmethod\n    def copy(\n        src: PathLikeType,\n        dst: PathLikeType,\n        follow_symlinks: bool = True,\n    ):\n        \"\"\"\n        Copy a file or directory. This is a wrapper around shutil.copy.\n        If you need to copy an entire directory (including all of its contents), or if you need to overwrite existing files in the destination directory, shutil.copy() would be a better choice.\n\n        Args:\n                src: Path to the file or directory to be copied.\n                dst: Path to the destination directory. If the destination directory does not exist it will be created.\n                follow_symlinks: Whether or not symlinks should be followed\n        \"\"\"\n        src = str(src)\n        dst = str(dst)\n        IOLIBs.mkdir(dst)\n        shutil.copy(src, dst, follow_symlinks=follow_symlinks)\n        logger.info(f\"copied {src} to {dst}\")\n\n    @staticmethod\n    def copyfile(\n        src: PathLikeType,\n        dst: PathLikeType,\n        follow_symlinks: bool = True,\n    ):\n        \"\"\"\n        Copy a file or directory. This is a wrapper around shutil.copyfile.\n        If you want to copy a single file from one location to another, shutil.copyfile() is the appropriate function to use.\n\n        Args:\n                src: Path to the file or directory to copy.\n                dst: Path to the destination file or directory. If the destination file already exists it will be overwritten.\n                follow_symlinks: Whether to follow symbolic links or not\n        \"\"\"\n        src = str(src)\n        dst = str(dst)\n        shutil.copyfile(src, dst, follow_symlinks=follow_symlinks)\n        logger.info(f\"copied {src} to {dst}\")\n\n    @staticmethod\n    def copy_file(\n        src: PathLikeType,\n        dst: PathLikeType,\n        follow_symlinks: bool = True,\n    ) -&gt; None:\n        \"\"\"Copy one file to another place.\"\"\"\n        src = str(src)\n        dst = str(dst)\n        shutil.copy2(src, dst, follow_symlinks=follow_symlinks)\n\n    @staticmethod\n    def get_modified_time(path):\n        \"\"\"Return the modification time of a file\"\"\"\n        if not os.path.exists(path):\n            return None\n        modTimesinceEpoc = os.path.getmtime(path)\n        return time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(modTimesinceEpoc))\n\n    @staticmethod\n    def handle_remove_readonly(\n        func: Callable, path: str, exc: Tuple[BaseException, OSError, TracebackType]\n    ) -&gt; None:\n        \"\"\"Handle errors when trying to remove read-only files through `shutil.rmtree`.\n\n        This handler makes sure the given file is writable, then re-execute the given removal function.\n\n        Arguments:\n            func: An OS-dependant function used to remove a file.\n            path: The path to the file to remove.\n            exc: A `sys.exc_info()` object.\n        \"\"\"\n        excvalue = exc[1]\n        if func in (os.rmdir, os.remove, os.unlink) and excvalue.errno == errno.EACCES:\n            os.chmod(path, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)  # 0777\n            func(path)\n        else:\n            raise\n\n    @staticmethod\n    def readlink(link: Path) -&gt; Path:\n        \"\"\"A custom version of os.readlink/pathlib.Path.readlink.\n\n        pathlib.Path.readlink is what we ideally would want to use, but it is only available on python&gt;=3.9.\n        os.readlink doesn't support Path and bytes on Windows for python&lt;3.8\n        \"\"\"\n        if sys.version_info &gt;= (3, 9):\n            return link.readlink()\n        elif sys.version_info &gt;= (3, 8) or os.name != \"nt\":\n            return Path(os.readlink(link))\n        else:\n            return Path(os.readlink(str(link)))\n\n    @staticmethod\n    def extractall(\n        path: str,\n        dest: str = \"\",\n        force_extract: bool = False,\n    ):\n        \"\"\"Extract archive file.\n\n        Parameters\n        ----------\n        path: str\n            Path of archive file to be extracted.\n        dest: str, optional\n            Directory to which the archive file will be extracted.\n            If None, it will be set to the parent directory of the archive file.\n        \"\"\"\n        import tarfile\n        from zipfile import ZipFile\n\n        if dest is None:\n            dest = os.path.dirname(path)\n\n        if path.endswith(\".zip\"):\n            opener, mode = ZipFile, \"r\"\n        elif path.endswith(\".tar\"):\n            opener, mode = tarfile.open, \"r\"\n        elif path.endswith(\".tar.gz\") or path.endswith(\".tgz\"):\n            opener, mode = tarfile.open, \"r:gz\"\n        elif path.endswith(\".tar.bz2\") or path.endswith(\".tbz\"):\n            opener, mode = tarfile.open, \"r:bz2\"\n        else:\n            logger.warning(\n                f\"Could not extract '{path}' as no appropriate extractor is found\"\n            )\n            return path, None\n\n        def namelist(f):\n            return (\n                f.namelist() if isinstance(f, ZipFile) else [m.path for m in f.members]\n            )\n\n        def filelist(f):\n            files = []\n            for fname in namelist(f):\n                fname = os.path.join(dest, fname)\n                files.append(fname)\n            return files\n\n        extraction_name = Path(path).stem\n        extraction_path = f\"{dest}/{extraction_name}\"\n        if extraction_path and (\n            os.path.isdir(extraction_path)\n            and os.listdir(extraction_path)\n            and not force_extract\n        ):\n            files = [\n                os.path.join(dirpath, filename)\n                for dirpath, _, filenames in os.walk(extraction_path)\n                for filename in filenames\n            ]\n\n            return dest, files\n\n        with opener(path, mode) as f:  # type: ignore\n            f.extractall(path=dest)\n\n        return dest, filelist(f)\n\n    @staticmethod\n    def save_wordlist(\n        words: List[str],\n        filepath: Union[str, PosixPath, WindowsPath, Path],\n        sort: bool = True,\n        encoding: str = \"utf-8\",\n        verbose: bool = True,\n    ):\n        \"\"\"Save the word list to the file.\"\"\"\n        if sort:\n            words = sorted(words)\n        if verbose:\n            logger.info(\n                \"Save the list to the file: %s, no. of words: %s\", filepath, len(words)\n            )\n        with open(filepath, \"w\", encoding=encoding) as fo_:\n            for word in words:\n                fo_.write(word + \"\\n\")\n\n    @staticmethod\n    def load_wordlist(\n        filepath: Union[str, PosixPath, WindowsPath, Path],\n        sort: bool = True,\n        lowercase: bool = False,\n        unique: bool = True,\n        remove_tag: bool = False,\n        max_ngram_to_include: Optional[int] = None,\n        ngram_delimiter: str = \";\",\n        remove_delimiter: bool = False,\n        encoding: str = \"utf-8\",\n        verbose: bool = True,\n    ) -&gt; List[str]:\n        \"\"\"Load the word list from the file.\"\"\"\n        filepath = Path(filepath)\n        if not filepath.is_file():\n            logger.warning(\"File not found: %s\", filepath)\n            return []\n\n        with open(filepath, encoding=encoding) as fo_:\n            words = [word.strip().split()[0] for word in fo_ if len(word.strip()) &gt; 0]\n\n        if verbose:\n            logger.info(\"Loaded the file: %s, No. of words: %s\", filepath, len(words))\n\n        return IOLIBs.process_wordlist(\n            words,\n            sort=sort,\n            lowercase=lowercase,\n            unique=unique,\n            remove_tag=remove_tag,\n            max_ngram_to_include=max_ngram_to_include,\n            ngram_delimiter=ngram_delimiter,\n            remove_delimiter=remove_delimiter,\n            verbose=verbose,\n        )\n\n    @staticmethod\n    def process_wordlist(\n        words: List[str],\n        sort: bool = True,\n        lowercase: bool = False,\n        unique: bool = True,\n        remove_tag: bool = False,\n        max_ngram_to_include: Optional[int] = None,\n        ngram_delimiter: str = \";\",\n        remove_delimiter: bool = False,\n        verbose: bool = True,\n    ) -&gt; List[str]:\n        \"\"\"Preprocess the word list.\n\n        Args:\n            words (List[str]): List of words.\n            sort (bool, optional): Sort the words. Defaults to True.\n            lowercase (bool, optional): Convert the words to lowercase. Defaults to False.\n            unique (bool, optional): Remove duplicate words. Defaults to True.\n            remove_tag (bool, optional): Remove the tag from the words. Defaults to False.\n            max_ngram_to_include (Optional[int], optional): Maximum ngram to include. Defaults to None.\n            ngram_delimiter (str, optional): Delimiter for ngram. Defaults to \";\".\n            remove_delimiter (bool, optional): Remove the delimiter. Defaults to False.\n            verbose (bool, optional): Show the progress. Defaults to True.\n\n        Returns:\n            List[str]: List of words.\n        \"\"\"\n        if remove_delimiter:\n            words = [word.replace(ngram_delimiter, \"\") for word in words]\n        if max_ngram_to_include:\n            words = [\n                word\n                for word in words\n                if len(word.split(ngram_delimiter)) &lt;= max_ngram_to_include\n            ]\n\n        if remove_tag:\n            words = [word.split(\"/\")[0] for word in words]\n        words = [\n            word.lower() if lowercase else word\n            for word in words\n            if not word.startswith(\"#\")\n        ]\n        if unique:\n            words = list(set(words))\n            if verbose:\n                logger.info(\n                    \"Remove duplicate words, No. of words: %s\",\n                    len(words),\n                )\n        if sort:\n            words = sorted(words)\n        return words\n\n    @staticmethod\n    def append_to_jsonl(\n        data: dict,\n        filename: str,\n        encoding: str = \"utf-8\",\n    ) -&gt; None:\n        \"\"\"Append a json payload to the end of a jsonl file.\"\"\"\n        json_string = json.dumps(data, ensure_ascii=False)\n        with open(filename, \"a\", encoding=encoding) as f:\n            f.write(json_string + \"\\n\")\n\n    @staticmethod\n    def load_jsonl(\n        filename: str,\n        encoding: str = \"utf-8\",\n    ) -&gt; List[dict]:\n        \"\"\"Load a jsonl file into a list of json objects.\"\"\"\n        with open(filename, \"r\", encoding=encoding) as f:\n            return [json.loads(line) for line in f]\n\n    @staticmethod\n    def save_jsonl(\n        data: List[dict],\n        filename: str,\n        encoding: str = \"utf-8\",\n    ) -&gt; None:\n        \"\"\"\n        Save a list of json objects to a jsonl file.\n        \"\"\"\n        with open(filename, \"w\", encoding=encoding) as f:\n            for line in data:\n                f.write(json.dumps(line, ensure_ascii=False) + \"\\n\")\n\n    @staticmethod\n    def remove_duplicates_from_list_of_dicts(\n        data: List[dict],\n        key: str,\n    ) -&gt; List[dict]:\n        \"\"\"Remove duplicates from a list of dicts based on a key.\"\"\"\n        seen = set()\n        new_data = []\n        for d in data:\n            if d[key] not in seen:\n                new_data.append(d)\n                seen.add(d[key])\n        return new_data\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.append_to_jsonl","title":"<code>append_to_jsonl(data, filename, encoding='utf-8')</code>  <code>staticmethod</code>","text":"<p>Append a json payload to the end of a jsonl file.</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef append_to_jsonl(\n    data: dict,\n    filename: str,\n    encoding: str = \"utf-8\",\n) -&gt; None:\n    \"\"\"Append a json payload to the end of a jsonl file.\"\"\"\n    json_string = json.dumps(data, ensure_ascii=False)\n    with open(filename, \"a\", encoding=encoding) as f:\n        f.write(json_string + \"\\n\")\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.check_path","title":"<code>check_path(_path, alt_path='')</code>  <code>staticmethod</code>","text":"<p>Check if path exists, return alt_path if not</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef check_path(_path: str, alt_path: str = \"\") -&gt; str:\n    \"\"\"Check if path exists, return alt_path if not\"\"\"\n    return _path if os.path.exists(_path) else alt_path\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.copy","title":"<code>copy(src, dst, follow_symlinks=True)</code>  <code>staticmethod</code>","text":"<p>Copy a file or directory. This is a wrapper around shutil.copy. If you need to copy an entire directory (including all of its contents), or if you need to overwrite existing files in the destination directory, shutil.copy() would be a better choice.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>PathLikeType</code> <p>Path to the file or directory to be copied.</p> required <code>dst</code> <code>PathLikeType</code> <p>Path to the destination directory. If the destination directory does not exist it will be created.</p> required <code>follow_symlinks</code> <code>bool</code> <p>Whether or not symlinks should be followed</p> <code>True</code> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef copy(\n    src: PathLikeType,\n    dst: PathLikeType,\n    follow_symlinks: bool = True,\n):\n    \"\"\"\n    Copy a file or directory. This is a wrapper around shutil.copy.\n    If you need to copy an entire directory (including all of its contents), or if you need to overwrite existing files in the destination directory, shutil.copy() would be a better choice.\n\n    Args:\n            src: Path to the file or directory to be copied.\n            dst: Path to the destination directory. If the destination directory does not exist it will be created.\n            follow_symlinks: Whether or not symlinks should be followed\n    \"\"\"\n    src = str(src)\n    dst = str(dst)\n    IOLIBs.mkdir(dst)\n    shutil.copy(src, dst, follow_symlinks=follow_symlinks)\n    logger.info(f\"copied {src} to {dst}\")\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.copy_file","title":"<code>copy_file(src, dst, follow_symlinks=True)</code>  <code>staticmethod</code>","text":"<p>Copy one file to another place.</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef copy_file(\n    src: PathLikeType,\n    dst: PathLikeType,\n    follow_symlinks: bool = True,\n) -&gt; None:\n    \"\"\"Copy one file to another place.\"\"\"\n    src = str(src)\n    dst = str(dst)\n    shutil.copy2(src, dst, follow_symlinks=follow_symlinks)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.copyfile","title":"<code>copyfile(src, dst, follow_symlinks=True)</code>  <code>staticmethod</code>","text":"<p>Copy a file or directory. This is a wrapper around shutil.copyfile. If you want to copy a single file from one location to another, shutil.copyfile() is the appropriate function to use.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>PathLikeType</code> <p>Path to the file or directory to copy.</p> required <code>dst</code> <code>PathLikeType</code> <p>Path to the destination file or directory. If the destination file already exists it will be overwritten.</p> required <code>follow_symlinks</code> <code>bool</code> <p>Whether to follow symbolic links or not</p> <code>True</code> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef copyfile(\n    src: PathLikeType,\n    dst: PathLikeType,\n    follow_symlinks: bool = True,\n):\n    \"\"\"\n    Copy a file or directory. This is a wrapper around shutil.copyfile.\n    If you want to copy a single file from one location to another, shutil.copyfile() is the appropriate function to use.\n\n    Args:\n            src: Path to the file or directory to copy.\n            dst: Path to the destination file or directory. If the destination file already exists it will be overwritten.\n            follow_symlinks: Whether to follow symbolic links or not\n    \"\"\"\n    src = str(src)\n    dst = str(dst)\n    shutil.copyfile(src, dst, follow_symlinks=follow_symlinks)\n    logger.info(f\"copied {src} to {dst}\")\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.exists","title":"<code>exists(a, *p)</code>  <code>staticmethod</code>","text":"<p>Check if path exists</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef exists(a, *p) -&gt; bool:\n    \"\"\"Check if path exists\"\"\"\n    if a is None:\n        return False\n    _path = os.path.join(a, *p)\n    return os.path.exists(_path)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.extractall","title":"<code>extractall(path, dest='', force_extract=False)</code>  <code>staticmethod</code>","text":"<p>Extract archive file.</p>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.extractall--parameters","title":"Parameters","text":"<p>path: str     Path of archive file to be extracted. dest: str, optional     Directory to which the archive file will be extracted.     If None, it will be set to the parent directory of the archive file.</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef extractall(\n    path: str,\n    dest: str = \"\",\n    force_extract: bool = False,\n):\n    \"\"\"Extract archive file.\n\n    Parameters\n    ----------\n    path: str\n        Path of archive file to be extracted.\n    dest: str, optional\n        Directory to which the archive file will be extracted.\n        If None, it will be set to the parent directory of the archive file.\n    \"\"\"\n    import tarfile\n    from zipfile import ZipFile\n\n    if dest is None:\n        dest = os.path.dirname(path)\n\n    if path.endswith(\".zip\"):\n        opener, mode = ZipFile, \"r\"\n    elif path.endswith(\".tar\"):\n        opener, mode = tarfile.open, \"r\"\n    elif path.endswith(\".tar.gz\") or path.endswith(\".tgz\"):\n        opener, mode = tarfile.open, \"r:gz\"\n    elif path.endswith(\".tar.bz2\") or path.endswith(\".tbz\"):\n        opener, mode = tarfile.open, \"r:bz2\"\n    else:\n        logger.warning(\n            f\"Could not extract '{path}' as no appropriate extractor is found\"\n        )\n        return path, None\n\n    def namelist(f):\n        return (\n            f.namelist() if isinstance(f, ZipFile) else [m.path for m in f.members]\n        )\n\n    def filelist(f):\n        files = []\n        for fname in namelist(f):\n            fname = os.path.join(dest, fname)\n            files.append(fname)\n        return files\n\n    extraction_name = Path(path).stem\n    extraction_path = f\"{dest}/{extraction_name}\"\n    if extraction_path and (\n        os.path.isdir(extraction_path)\n        and os.listdir(extraction_path)\n        and not force_extract\n    ):\n        files = [\n            os.path.join(dirpath, filename)\n            for dirpath, _, filenames in os.walk(extraction_path)\n            for filename in filenames\n        ]\n\n        return dest, files\n\n    with opener(path, mode) as f:  # type: ignore\n        f.extractall(path=dest)\n\n    return dest, filelist(f)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.get_filepaths","title":"<code>get_filepaths(filename_patterns, base_dir=None, recursive=True, use_cached=False, verbose=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Get a list of filepaths from a list of filename patterns</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef get_filepaths(\n    filename_patterns: Union[List[PathLikeType], PathLikeType],\n    base_dir: Optional[Union[str, PosixPath, WindowsPath]] = None,\n    recursive: bool = True,\n    use_cached: bool = False,\n    verbose: bool = False,\n    **kwargs,\n) -&gt; List[str]:\n    \"\"\"Get a list of filepaths from a list of filename patterns\"\"\"\n    if filename_patterns is None:\n        raise ValueError(\"filename_patterns must be specified\")\n    if isinstance(filename_patterns, (PosixPath, WindowsPath)):\n        filename_patterns = str(filename_patterns)\n    if isinstance(filename_patterns, str):\n        filename_patterns = [filename_patterns]\n    filepaths = []\n    base_dir = str(base_dir) if base_dir else \"\"\n    for f_pattern in filename_patterns:\n        f_pattern = str(f_pattern)\n        if f_pattern.startswith(\"http\") and not use_cached:\n            filepaths.append(f_pattern)\n        else:\n            if f_pattern.startswith(\"http\"):\n                filepath = IOLIBs.cached_path(f_pattern, **kwargs)\n            else:\n                filepath = os.path.join(base_dir, f_pattern)\n            if isinstance(filepath, str) and os.path.exists(filepath):\n                if Path(filepath).is_file():\n                    filepaths.append(filepath)\n            else:\n                if os.path.dirname(f_pattern) != \"\":\n                    _dir = os.path.dirname(f_pattern)\n                    f_pattern = os.path.basename(f_pattern)\n                    base_dir = os.path.join(base_dir, _dir)\n                filepaths += IOLIBs.glob_re(\n                    f_pattern, base_dir, recursive=recursive\n                )\n    filepaths = [\n        fp for fp in filepaths if Path(fp).is_file() or fp.startswith(\"http\")\n    ]\n    if verbose:\n        logger.info(f\"Processing [{len(filepaths)}] files from {filename_patterns}\")\n\n    return filepaths\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.get_files_from_archive","title":"<code>get_files_from_archive(archive_path, filetype='')</code>  <code>staticmethod</code>","text":"<p>Get a list of files from an archive</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef get_files_from_archive(archive_path: str, filetype: str = \"\"):\n    \"\"\"Get a list of files from an archive\"\"\"\n    import tarfile\n    from zipfile import ZipFile\n\n    if \".tar.gz\" in archive_path:\n        logger.info(f\"::Extracting files from {archive_path} with tar.gz\")\n        archive_handle = tarfile.open(archive_path, \"r:gz\")\n        files = [\n            (file, file.name)\n            for file in archive_handle.getmembers()\n            if file.isfile()\n        ]\n        open_func = archive_handle.extractfile\n    elif \".tar.bz2\" in archive_path:\n        logger.info(f\"::Extracting files from {archive_path} with tar.bz2\")\n        archive_handle = tarfile.open(archive_path, \"r:bz2\")\n        files = [\n            (file, file.name)\n            for file in archive_handle.getmembers()\n            if file.isfile()\n        ]\n        open_func = archive_handle.extractfile\n    elif \".zip\" in archive_path:\n        logger.info(f\"::Extracting files from {archive_path} with zip\")\n        archive_handle = ZipFile(archive_path)\n        files = [\n            (file, file.encode(\"cp437\").decode(\"euc-kr\"))\n            for file in archive_handle.namelist()\n        ]\n        open_func = archive_handle.open\n    else:\n        # print(f'::{archive_path} is not archive, use generic method')\n        files = [(archive_path, os.path.basename(archive_path))]\n        archive_handle = None\n        open_func = None\n    if filetype:\n        files = [file for file in files if filetype in file[1]]\n\n    return files, archive_handle, open_func\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.get_modified_time","title":"<code>get_modified_time(path)</code>  <code>staticmethod</code>","text":"<p>Return the modification time of a file</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef get_modified_time(path):\n    \"\"\"Return the modification time of a file\"\"\"\n    if not os.path.exists(path):\n        return None\n    modTimesinceEpoc = os.path.getmtime(path)\n    return time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(modTimesinceEpoc))\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.glob_re","title":"<code>glob_re(pattern, base_dir, recursive=False)</code>  <code>staticmethod</code>","text":"<p>Glob files matching a regular expression</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef glob_re(\n    pattern: str,\n    base_dir: str,\n    recursive: bool = False,\n) -&gt; list:\n    \"\"\"Glob files matching a regular expression\"\"\"\n    if IOLIBs.is_valid_regex(pattern):\n        pattern = pattern[2:]\n        rpattern = re.compile(pattern)  # type: ignore\n        files = []\n        if recursive:\n            for dirpath, _, filenames in os.walk(base_dir):\n                files += [\n                    os.path.join(dirpath, file)\n                    for file in filenames\n                    if rpattern.search(file)\n                ]\n        else:\n            files = [\n                os.path.join(base_dir, file)\n                for file in os.listdir(base_dir)\n                if rpattern.search(file)\n            ]\n    else:\n        file = os.path.join(base_dir, pattern)\n        files = glob(file, recursive=recursive)\n    return files\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.handle_remove_readonly","title":"<code>handle_remove_readonly(func, path, exc)</code>  <code>staticmethod</code>","text":"<p>Handle errors when trying to remove read-only files through <code>shutil.rmtree</code>.</p> <p>This handler makes sure the given file is writable, then re-execute the given removal function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>An OS-dependant function used to remove a file.</p> required <code>path</code> <code>str</code> <p>The path to the file to remove.</p> required <code>exc</code> <code>Tuple[BaseException, OSError, TracebackType]</code> <p>A <code>sys.exc_info()</code> object.</p> required Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef handle_remove_readonly(\n    func: Callable, path: str, exc: Tuple[BaseException, OSError, TracebackType]\n) -&gt; None:\n    \"\"\"Handle errors when trying to remove read-only files through `shutil.rmtree`.\n\n    This handler makes sure the given file is writable, then re-execute the given removal function.\n\n    Arguments:\n        func: An OS-dependant function used to remove a file.\n        path: The path to the file to remove.\n        exc: A `sys.exc_info()` object.\n    \"\"\"\n    excvalue = exc[1]\n    if func in (os.rmdir, os.remove, os.unlink) and excvalue.errno == errno.EACCES:\n        os.chmod(path, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)  # 0777\n        func(path)\n    else:\n        raise\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.is_dir","title":"<code>is_dir(a, *p)</code>  <code>staticmethod</code>","text":"<p>Check if path is a directory</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef is_dir(a, *p) -&gt; bool:\n    \"\"\"Check if path is a directory\"\"\"\n    _path = os.path.join(a, *p)\n    return Path(_path).is_dir()\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.is_file","title":"<code>is_file(a, *p)</code>  <code>staticmethod</code>","text":"<p>Check if path is a file</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef is_file(a, *p) -&gt; bool:\n    \"\"\"Check if path is a file\"\"\"\n    _path = os.path.join(a, *p)\n    return Path(_path).is_file()\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.is_valid_regex","title":"<code>is_valid_regex(expr)</code>  <code>staticmethod</code>","text":"<p>Check if a string is a valid regular expression</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef is_valid_regex(expr: str) -&gt; bool:\n    \"\"\"Check if a string is a valid regular expression\"\"\"\n    try:\n        if expr.startswith(\"r:\"):\n            expr = expr[2:]\n        else:\n            return False\n        re.compile(expr)\n        return True\n    except re.error:\n        return False\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.join_path","title":"<code>join_path(a, *p)</code>  <code>staticmethod</code>","text":"<p>Join path components intelligently.</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef join_path(a, *p) -&gt; str:\n    \"\"\"Join path components intelligently.\"\"\"\n    if not p or p[0] is None:\n        return a\n    p = [str(_p) for _p in p]\n    return os.path.join(*p) if a is None else os.path.join(a, *p)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.load_jsonl","title":"<code>load_jsonl(filename, encoding='utf-8')</code>  <code>staticmethod</code>","text":"<p>Load a jsonl file into a list of json objects.</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef load_jsonl(\n    filename: str,\n    encoding: str = \"utf-8\",\n) -&gt; List[dict]:\n    \"\"\"Load a jsonl file into a list of json objects.\"\"\"\n    with open(filename, \"r\", encoding=encoding) as f:\n        return [json.loads(line) for line in f]\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.load_wordlist","title":"<code>load_wordlist(filepath, sort=True, lowercase=False, unique=True, remove_tag=False, max_ngram_to_include=None, ngram_delimiter=';', remove_delimiter=False, encoding='utf-8', verbose=True)</code>  <code>staticmethod</code>","text":"<p>Load the word list from the file.</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef load_wordlist(\n    filepath: Union[str, PosixPath, WindowsPath, Path],\n    sort: bool = True,\n    lowercase: bool = False,\n    unique: bool = True,\n    remove_tag: bool = False,\n    max_ngram_to_include: Optional[int] = None,\n    ngram_delimiter: str = \";\",\n    remove_delimiter: bool = False,\n    encoding: str = \"utf-8\",\n    verbose: bool = True,\n) -&gt; List[str]:\n    \"\"\"Load the word list from the file.\"\"\"\n    filepath = Path(filepath)\n    if not filepath.is_file():\n        logger.warning(\"File not found: %s\", filepath)\n        return []\n\n    with open(filepath, encoding=encoding) as fo_:\n        words = [word.strip().split()[0] for word in fo_ if len(word.strip()) &gt; 0]\n\n    if verbose:\n        logger.info(\"Loaded the file: %s, No. of words: %s\", filepath, len(words))\n\n    return IOLIBs.process_wordlist(\n        words,\n        sort=sort,\n        lowercase=lowercase,\n        unique=unique,\n        remove_tag=remove_tag,\n        max_ngram_to_include=max_ngram_to_include,\n        ngram_delimiter=ngram_delimiter,\n        remove_delimiter=remove_delimiter,\n        verbose=verbose,\n    )\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.mkdir","title":"<code>mkdir(_path)</code>  <code>staticmethod</code>","text":"<p>Create directory if it does not exist</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef mkdir(_path: str) -&gt; str:\n    \"\"\"Create directory if it does not exist\"\"\"\n    if _path is None:\n        return \"\"\n    Path(_path).mkdir(parents=True, exist_ok=True)\n    return _path\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.process_wordlist","title":"<code>process_wordlist(words, sort=True, lowercase=False, unique=True, remove_tag=False, max_ngram_to_include=None, ngram_delimiter=';', remove_delimiter=False, verbose=True)</code>  <code>staticmethod</code>","text":"<p>Preprocess the word list.</p> <p>Parameters:</p> Name Type Description Default <code>words</code> <code>List[str]</code> <p>List of words.</p> required <code>sort</code> <code>bool</code> <p>Sort the words. Defaults to True.</p> <code>True</code> <code>lowercase</code> <code>bool</code> <p>Convert the words to lowercase. Defaults to False.</p> <code>False</code> <code>unique</code> <code>bool</code> <p>Remove duplicate words. Defaults to True.</p> <code>True</code> <code>remove_tag</code> <code>bool</code> <p>Remove the tag from the words. Defaults to False.</p> <code>False</code> <code>max_ngram_to_include</code> <code>Optional[int]</code> <p>Maximum ngram to include. Defaults to None.</p> <code>None</code> <code>ngram_delimiter</code> <code>str</code> <p>Delimiter for ngram. Defaults to \";\".</p> <code>';'</code> <code>remove_delimiter</code> <code>bool</code> <p>Remove the delimiter. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Show the progress. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of words.</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef process_wordlist(\n    words: List[str],\n    sort: bool = True,\n    lowercase: bool = False,\n    unique: bool = True,\n    remove_tag: bool = False,\n    max_ngram_to_include: Optional[int] = None,\n    ngram_delimiter: str = \";\",\n    remove_delimiter: bool = False,\n    verbose: bool = True,\n) -&gt; List[str]:\n    \"\"\"Preprocess the word list.\n\n    Args:\n        words (List[str]): List of words.\n        sort (bool, optional): Sort the words. Defaults to True.\n        lowercase (bool, optional): Convert the words to lowercase. Defaults to False.\n        unique (bool, optional): Remove duplicate words. Defaults to True.\n        remove_tag (bool, optional): Remove the tag from the words. Defaults to False.\n        max_ngram_to_include (Optional[int], optional): Maximum ngram to include. Defaults to None.\n        ngram_delimiter (str, optional): Delimiter for ngram. Defaults to \";\".\n        remove_delimiter (bool, optional): Remove the delimiter. Defaults to False.\n        verbose (bool, optional): Show the progress. Defaults to True.\n\n    Returns:\n        List[str]: List of words.\n    \"\"\"\n    if remove_delimiter:\n        words = [word.replace(ngram_delimiter, \"\") for word in words]\n    if max_ngram_to_include:\n        words = [\n            word\n            for word in words\n            if len(word.split(ngram_delimiter)) &lt;= max_ngram_to_include\n        ]\n\n    if remove_tag:\n        words = [word.split(\"/\")[0] for word in words]\n    words = [\n        word.lower() if lowercase else word\n        for word in words\n        if not word.startswith(\"#\")\n    ]\n    if unique:\n        words = list(set(words))\n        if verbose:\n            logger.info(\n                \"Remove duplicate words, No. of words: %s\",\n                len(words),\n            )\n    if sort:\n        words = sorted(words)\n    return words\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.read","title":"<code>read(uri, mode='rb', encoding=None, head=None, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Read data from a file or url</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef read(uri, mode=\"rb\", encoding=None, head=None, **kwargs) -&gt; bytes:\n    \"\"\"Read data from a file or url\"\"\"\n    uri = str(uri)\n    if uri.startswith(\"http\"):\n        import requests\n\n        if mode == \"r\" and head is not None and isinstance(head, int):\n            r = requests.get(uri, stream=True)\n            r.raw.decode_content = True\n            return r.raw.read(head)\n        return requests.get(uri, **kwargs).content\n    # elif uri.startswith(\"s3://\"):\n    #     import boto3\n\n    #     s3 = boto3.resource(\"s3\")\n    #     bucket, key = uri.replace(\"s3://\", \"\").split(\"/\", 1)\n    #     obj = s3.Object(bucket, key)\n    #     return obj.get()[\"Body\"].read()\n    else:\n        with open(uri, mode=mode, encoding=encoding) as f:\n            if mode == \"r\" and head is not None and isinstance(head, int):\n                return f.read(head)\n            return f.read()\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.readlink","title":"<code>readlink(link)</code>  <code>staticmethod</code>","text":"<p>A custom version of os.readlink/pathlib.Path.readlink.</p> <p>pathlib.Path.readlink is what we ideally would want to use, but it is only available on python&gt;=3.9. os.readlink doesn't support Path and bytes on Windows for python&lt;3.8</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef readlink(link: Path) -&gt; Path:\n    \"\"\"A custom version of os.readlink/pathlib.Path.readlink.\n\n    pathlib.Path.readlink is what we ideally would want to use, but it is only available on python&gt;=3.9.\n    os.readlink doesn't support Path and bytes on Windows for python&lt;3.8\n    \"\"\"\n    if sys.version_info &gt;= (3, 9):\n        return link.readlink()\n    elif sys.version_info &gt;= (3, 8) or os.name != \"nt\":\n        return Path(os.readlink(link))\n    else:\n        return Path(os.readlink(str(link)))\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.remove_duplicates_from_list_of_dicts","title":"<code>remove_duplicates_from_list_of_dicts(data, key)</code>  <code>staticmethod</code>","text":"<p>Remove duplicates from a list of dicts based on a key.</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef remove_duplicates_from_list_of_dicts(\n    data: List[dict],\n    key: str,\n) -&gt; List[dict]:\n    \"\"\"Remove duplicates from a list of dicts based on a key.\"\"\"\n    seen = set()\n    new_data = []\n    for d in data:\n        if d[key] not in seen:\n            new_data.append(d)\n            seen.add(d[key])\n    return new_data\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.save_jsonl","title":"<code>save_jsonl(data, filename, encoding='utf-8')</code>  <code>staticmethod</code>","text":"<p>Save a list of json objects to a jsonl file.</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef save_jsonl(\n    data: List[dict],\n    filename: str,\n    encoding: str = \"utf-8\",\n) -&gt; None:\n    \"\"\"\n    Save a list of json objects to a jsonl file.\n    \"\"\"\n    with open(filename, \"w\", encoding=encoding) as f:\n        for line in data:\n            f.write(json.dumps(line, ensure_ascii=False) + \"\\n\")\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.save_wordlist","title":"<code>save_wordlist(words, filepath, sort=True, encoding='utf-8', verbose=True)</code>  <code>staticmethod</code>","text":"<p>Save the word list to the file.</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef save_wordlist(\n    words: List[str],\n    filepath: Union[str, PosixPath, WindowsPath, Path],\n    sort: bool = True,\n    encoding: str = \"utf-8\",\n    verbose: bool = True,\n):\n    \"\"\"Save the word list to the file.\"\"\"\n    if sort:\n        words = sorted(words)\n    if verbose:\n        logger.info(\n            \"Save the list to the file: %s, no. of words: %s\", filepath, len(words)\n        )\n    with open(filepath, \"w\", encoding=encoding) as fo_:\n        for word in words:\n            fo_.write(word + \"\\n\")\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.IOLIBs.walk_to_root","title":"<code>walk_to_root(path)</code>  <code>staticmethod</code>","text":"<p>Yield directories starting from the given directory up to the root</p> Source code in <code>hyfi/utils/iolibs.py</code> <pre><code>@staticmethod\ndef walk_to_root(path: str) -&gt; Iterator[str]:\n    \"\"\"\n    Yield directories starting from the given directory up to the root\n    \"\"\"\n    if not os.path.exists(path):\n        raise IOError(\"Starting path not found\")\n\n    if os.path.isfile(path):\n        path = os.path.dirname(path)\n\n    last_dir = None\n    current_dir = os.path.abspath(path)\n    while last_dir != current_dir:\n        yield current_dir\n        parent_dir = os.path.abspath(os.path.join(current_dir, os.path.pardir))\n        last_dir, current_dir = current_dir, parent_dir\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.LOGGING","title":"<code>LOGGING</code>","text":"Source code in <code>hyfi/utils/logging.py</code> <pre><code>class LOGGING:\n    @staticmethod\n    def setLogger(\n        level=None,\n        force=True,\n        filterwarnings_action=\"ignore\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Set the logging level and format. This is a wrapper around logging. basicConfig to allow the user to specify a different logging level for each test and to filter warnings that are not caught by the filterwarnings_action\n\n        Args:\n            level: The logging level to use\n            force: If True ( default ) all warnings will be logged even if there are no warnings\n            filterwarnings_action: The action to call when a warning is logged\n\n        Returns:\n            The logger that was\n        \"\"\"\n        level = level or os.environ.get(\"HYFI_LOG_LEVEL\") or \"INFO\"\n        level = level.upper()\n        os.environ[\"HYFI_LOG_LEVEL\"] = level\n        # Filter warnings by applying filterwarnings_action to the warnings.\n        if filterwarnings_action is not None:\n            warnings.filterwarnings(filterwarnings_action)  # type: ignore\n        # Return the logging level.\n        if isinstance(level, str):\n            level = getattr(logging, level.upper(), logging.INFO)\n        # Configure logging level level and force logging.\n        if sys.version_info &gt;= (3, 8):\n            logging.basicConfig(level=level, force=force, **kwargs)\n        else:\n            logging.basicConfig(level=level, **kwargs)\n\n    @staticmethod\n    def getLogger(\n        _name=None,\n        _log_level=None,\n        **kwargs,\n    ) -&gt; logging.Logger:\n        \"\"\"\n        Get a logger with a given name and log level. It is possible to pass a logger name and log level to this function.\n\n        Args:\n            _name: The name of the logger to get. If not specified the name of the module is used.\n            _log_level: The log level to set.\n\n        Returns:\n            The logger with the given name and log level set to the value specified in HYFI_LOG_LEVEL\n        \"\"\"\n        _name = _name or __name__\n        logger = logging.getLogger(_name)\n        _log_level = _log_level or os.environ.get(\"HYFI_LOG_LEVEL\") or \"INFO\"\n        logger.setLevel(_log_level)\n        return logger\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.LOGGING.getLogger","title":"<code>getLogger(_name=None, _log_level=None, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Get a logger with a given name and log level. It is possible to pass a logger name and log level to this function.</p> <p>Parameters:</p> Name Type Description Default <code>_name</code> <p>The name of the logger to get. If not specified the name of the module is used.</p> <code>None</code> <code>_log_level</code> <p>The log level to set.</p> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>The logger with the given name and log level set to the value specified in HYFI_LOG_LEVEL</p> Source code in <code>hyfi/utils/logging.py</code> <pre><code>@staticmethod\ndef getLogger(\n    _name=None,\n    _log_level=None,\n    **kwargs,\n) -&gt; logging.Logger:\n    \"\"\"\n    Get a logger with a given name and log level. It is possible to pass a logger name and log level to this function.\n\n    Args:\n        _name: The name of the logger to get. If not specified the name of the module is used.\n        _log_level: The log level to set.\n\n    Returns:\n        The logger with the given name and log level set to the value specified in HYFI_LOG_LEVEL\n    \"\"\"\n    _name = _name or __name__\n    logger = logging.getLogger(_name)\n    _log_level = _log_level or os.environ.get(\"HYFI_LOG_LEVEL\") or \"INFO\"\n    logger.setLevel(_log_level)\n    return logger\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.LOGGING.setLogger","title":"<code>setLogger(level=None, force=True, filterwarnings_action='ignore', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Set the logging level and format. This is a wrapper around logging. basicConfig to allow the user to specify a different logging level for each test and to filter warnings that are not caught by the filterwarnings_action</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <p>The logging level to use</p> <code>None</code> <code>force</code> <p>If True ( default ) all warnings will be logged even if there are no warnings</p> <code>True</code> <code>filterwarnings_action</code> <p>The action to call when a warning is logged</p> <code>'ignore'</code> <p>Returns:</p> Type Description <code>None</code> <p>The logger that was</p> Source code in <code>hyfi/utils/logging.py</code> <pre><code>@staticmethod\ndef setLogger(\n    level=None,\n    force=True,\n    filterwarnings_action=\"ignore\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Set the logging level and format. This is a wrapper around logging. basicConfig to allow the user to specify a different logging level for each test and to filter warnings that are not caught by the filterwarnings_action\n\n    Args:\n        level: The logging level to use\n        force: If True ( default ) all warnings will be logged even if there are no warnings\n        filterwarnings_action: The action to call when a warning is logged\n\n    Returns:\n        The logger that was\n    \"\"\"\n    level = level or os.environ.get(\"HYFI_LOG_LEVEL\") or \"INFO\"\n    level = level.upper()\n    os.environ[\"HYFI_LOG_LEVEL\"] = level\n    # Filter warnings by applying filterwarnings_action to the warnings.\n    if filterwarnings_action is not None:\n        warnings.filterwarnings(filterwarnings_action)  # type: ignore\n    # Return the logging level.\n    if isinstance(level, str):\n        level = getattr(logging, level.upper(), logging.INFO)\n    # Configure logging level level and force logging.\n    if sys.version_info &gt;= (3, 8):\n        logging.basicConfig(level=level, force=force, **kwargs)\n    else:\n        logging.basicConfig(level=level, **kwargs)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.NBs","title":"<code>NBs</code>","text":"Source code in <code>hyfi/utils/notebooks.py</code> <pre><code>class NBs:\n    @staticmethod\n    def is_notebook():\n        \"\"\"Check if the code is running in a notebook.\"\"\"\n        try:\n            get_ipython  # type: ignore\n        except NameError:\n            return False\n        # pylint: disable=undefined-variable\n        shell_type = get_ipython().__class__.__name__  # type: ignore # noqa\n        # logger.info(f\"shell type: {shell_type}\")\n        return shell_type in [\"ZMQInteractiveShell\", \"Shell\"]\n\n    @staticmethod\n    def is_colab():\n        \"\"\"Check if the code is running in Google Colab.\"\"\"\n        is_colab = \"google.colab\" in sys.modules\n        if is_colab:\n            logger.info(\"Google Colab detected.\")\n        else:\n            logger.info(\"Google Colab not detected.\")\n        return is_colab\n\n    @staticmethod\n    def get_display():\n        \"\"\"Get the display object for the current environment.\"\"\"\n        try:\n            from ipywidgets import Output\n        except ImportError:\n            logger.info(\"ipywidgets not installed.\")\n            return None\n\n        return Output() if NBs.is_notebook() else None\n\n    @staticmethod\n    def clear_output(wait=False):\n        \"\"\"Clear the output of the current notebook.\"\"\"\n        from IPython import display\n\n        if NBs.is_notebook():\n            display.clear_output(wait=wait)\n\n    @staticmethod\n    def display(\n        *objs,\n        include=None,\n        exclude=None,\n        metadata=None,\n        transient=None,\n        display_id=None,\n        **kwargs,\n    ):\n        \"\"\"Display an object in the current notebook.\"\"\"\n        from IPython import display\n\n        if NBs.is_notebook() and objs is not None:\n            return display.display(\n                *objs,\n                include=include,\n                exclude=exclude,\n                metadata=metadata,\n                transient=transient,\n                display_id=display_id,\n                **kwargs,\n            )\n\n    @staticmethod\n    def display_image(\n        data=None,\n        url=None,\n        filename=None,\n        format=None,\n        embed=None,\n        width=None,\n        height=None,\n        retina=False,\n        unconfined=False,\n        metadata=None,\n        **kwargs,\n    ):\n        \"\"\"\n        Display an image, which can be given as raw data or a URL.\n\n        Parameters\n        ----------\n        data : unicode, str or bytes\n            The raw image data or a URL or filename to load the data from.\n            This always results in embedded image data.\n        url : unicode\n            A URL to download the data from. If you specify `url=`,\n            the image data will not be embedded unless you also specify `embed=True`.\n        filename : unicode\n            Path to a local file to load the data from.\n            Images from a file are always embedded.\n        format : unicode\n            The format of the image data (png/jpeg/jpg/gif). If a filename or URL is given\n            for format will be inferred from the filename extension.\n        embed : bool\n            Should the image data be embedded using a data URI (True) or be\n            loaded using an &lt;img&gt; tag. Set this to True if you want the image\n            to be viewable later with no internet connection in the notebook.\n\n            Default is `True`, unless the keyword argument `url` is set, then\n            default value is `False`.\n\n            Note that QtConsole is not able to display images if `embed` is set to `False`\n        width : int\n            Width in pixels to which to constrain the image in html\n        height : int\n            Height in pixels to which to constrain the image in html\n        retina : bool\n            Automatically set the width and height to half of the measured\n            width and height.\n            This only works for embedded images because it reads the width/height\n            from image data.\n            For non-embedded images, you can just set the desired display width\n            and height directly.\n        unconfined: bool\n            Set unconfined=True to disable max-width confinement of the image.\n        metadata: dict\n            Specify extra metadata to attach to the image.\n\n        \"\"\"\n        from IPython import display\n\n        if NBs.is_notebook():\n            img = display.Image(\n                data=data,\n                url=url,\n                filename=filename,\n                format=format,\n                embed=embed,\n                width=width,\n                height=height,\n                retina=retina,\n                unconfined=unconfined,\n                metadata=metadata,\n                **kwargs,\n            )\n            return display.display(img)\n\n    @staticmethod\n    def hide_code_in_slideshow():\n        \"\"\"Hide code in slideshow.\"\"\"\n        import binascii\n\n        from IPython import display\n\n        uid = binascii.hexlify(os.urandom(8)).decode()\n        html = \"\"\"&lt;div id=\"%s\"&gt;&lt;/div&gt;\n        &lt;script type=\"text/javascript\"&gt;\n            $(function(){\n                var p = $(\"#%s\");\n                if (p.length==0) return;\n                while (!p.hasClass(\"cell\")) {\n                    p=p.parent();\n                    if (p.prop(\"tagName\") ==\"body\") return;\n                }\n                var cell = p;\n                cell.find(\".input\").addClass(\"hide-in-slideshow\")\n            });\n        &lt;/script&gt;\"\"\" % (\n            uid,\n            uid,\n        )\n        display.display_html(html, raw=True)\n\n    @staticmethod\n    def colored_str(s, color=\"black\"):\n        \"\"\"Colored string.\"\"\"\n        # return \"&lt;text style=color:{}&gt;{}&lt;/text&gt;\".format(color, s)\n        return \"&lt;text style=color:{}&gt;{}&lt;/text&gt;\".format(color, s.replace(\"\\n\", \"&lt;br&gt;\"))\n\n    @staticmethod\n    def cprint(str_tuples):\n        from IPython.core.display import HTML as html_print\n        from IPython.display import display\n\n        display(\n            html_print(\n                \" \".join([NBs.colored_str(ti, color=ci) for ti, ci in str_tuples])\n            )\n        )\n\n    @staticmethod\n    def create_dropdown(\n        options, value, description, disabled=False, style=None, layout=None, **kwargs\n    ):\n        \"\"\"Create a dropdown widget.\"\"\"\n        import ipywidgets as widgets\n\n        if style is None:\n            style = {\"description_width\": \"initial\"}\n\n        layout = (\n            widgets.Layout(width=\"auto\") if layout is None else widgets.Layout(**layout)\n        )\n        return widgets.Dropdown(\n            options=options,\n            value=value,\n            description=description,\n            disabled=disabled,\n            style=style,\n            layout=layout,\n            **kwargs,\n        )\n\n    @staticmethod\n    def create_textarea(\n        value,\n        description,\n        placeholder=\"\",\n        disabled=False,\n        style=None,\n        layout=None,\n        **kwargs,\n    ):\n        \"\"\"Create a textarea widget.\"\"\"\n        import ipywidgets as widgets\n\n        if style is None:\n            style = {\"description_width\": \"initial\"}\n\n        layout = (\n            widgets.Layout(width=\"auto\") if layout is None else widgets.Layout(**layout)\n        )\n        return widgets.Textarea(\n            value=value,\n            placeholder=placeholder,\n            description=description,\n            disabled=disabled,\n            style=style,\n            layout=layout,\n            **kwargs,\n        )\n\n    @staticmethod\n    def create_button(\n        description, button_style=\"\", icon=\"check\", layout=None, **kwargs\n    ):\n        \"\"\"Create a button widget.\"\"\"\n        import ipywidgets as widgets\n\n        layout = (\n            widgets.Layout(width=\"auto\") if layout is None else widgets.Layout(**layout)\n        )\n        return widgets.Button(\n            description=description,\n            button_style=button_style,\n            icon=icon,\n            layout=layout,\n            **kwargs,\n        )\n\n    @staticmethod\n    def create_radiobutton(\n        options,\n        description,\n        value=None,\n        disabled=False,\n        style=None,\n        layout=None,\n        **kwargs,\n    ):\n        \"\"\"Create a radiobutton widget.\"\"\"\n        import ipywidgets as widgets\n\n        if style is None:\n            style = {\"description_width\": \"initial\"}\n\n        layout = (\n            widgets.Layout(width=\"auto\") if layout is None else widgets.Layout(**layout)\n        )\n        return widgets.RadioButtons(\n            options=options,\n            value=value,\n            description=description,\n            disabled=disabled,\n            style=style,\n            layout=layout,\n            **kwargs,\n        )\n\n    @staticmethod\n    def create_image(\n        filename=None,\n        format=None,\n        width=None,\n        height=None,\n        **kwargs,\n    ):\n        \"\"\"Create an image widget.\"\"\"\n        import ipywidgets as widgets\n\n        # from urllib.request import urlopen\n\n        if filename is None:\n            url = \"https://assets.entelecheia.cc/img/placeholder.png\"\n            # img = urlopen(url).read()\n            img = IOLIBs.read(url)\n            _format = \"png\"\n        else:\n            img = IOLIBs.read(filename)\n            _format = format or filename.split(\".\")[-1]\n        return widgets.Image(\n            value=img,\n            format=_format,\n            width=width,\n            height=height,\n            **kwargs,\n        )\n\n    @staticmethod\n    def create_floatslider(\n        min=0.0,\n        max=1.0,\n        step=0.1,\n        value=None,\n        description=\"\",\n        disabled=False,\n        continuous_update=False,\n        orientation=\"horizontal\",\n        readout=True,\n        readout_format=\".1f\",\n        style=None,\n        layout=None,\n        **kwargs,\n    ):\n        \"\"\"Create a float slider widget.\"\"\"\n        if style is None:\n            style = {\"description_width\": \"initial\"}\n        import ipywidgets as widgets\n\n        layout = (\n            widgets.Layout(width=\"auto\") if layout is None else widgets.Layout(**layout)\n        )\n        return widgets.FloatSlider(\n            min=min,\n            max=max,\n            step=step,\n            value=value,\n            description=description,\n            disabled=disabled,\n            continuous_update=continuous_update,\n            orientation=orientation,\n            readout=readout,\n            readout_format=readout_format,\n            style=style,\n            layout=layout,\n            **kwargs,\n        )\n\n    @staticmethod\n    def load_extentions(exts=None):\n        \"\"\"Load extentions.\"\"\"\n        if exts is None:\n            exts = [\"autotime\"]\n        if not NBs.is_notebook():\n            return\n        with contextlib.suppress(ImportError):\n            from IPython.core.getipython import get_ipython\n\n            ip = get_ipython()\n            if ip is None:\n                return\n            try:\n                loaded = ip.extension_manager.loaded\n                for ext in exts:\n                    if ext not in loaded:\n                        ip.extentension_manager.load_extension(ext)\n            except AttributeError:\n                for ext in exts:\n                    try:\n                        ip.magic(f\"load_ext {ext}\")\n                    except ModuleNotFoundError:\n                        logger.info(\"Extension %s not found. Install it first.\", ext)\n\n    @staticmethod\n    def set_matplotlib_formats(*formats, **kwargs):\n        \"\"\"Set matplotlib formats.\"\"\"\n        if NBs.is_notebook():\n            from IPython.core.display import set_matplotlib_formats\n\n            set_matplotlib_formats(*formats, **kwargs)\n\n    @staticmethod\n    def mount_google_drive(\n        project_root: str = \"\",\n        project_name: str = \"\",\n        mountpoint: str = \"/content/drive\",\n        force_remount: bool = False,\n        timeout_ms: int = 120000,\n    ) -&gt; None:\n        \"\"\"Mount Google Drive to Colab.\"\"\"\n        try:\n            from google.colab import drive  # type: ignore\n\n            drive.mount(mountpoint, force_remount=force_remount, timeout_ms=timeout_ms)\n\n            if project_root:\n                if not project_root.startswith(\n                    os.path.sep\n                ) and not project_root.startswith(\"..\"):\n                    project_root = os.path.join(mountpoint, project_root)\n                ENVs.set_osenv(\"HYFI_PROJECT_ROOT\", project_root)\n                logger.info(f\"Setting HYFI_PROJECT_ROOT to {project_root}\")\n            if project_name:\n                ENVs.set_osenv(\"HYFI_PROJECT_NAME\", project_name)\n                logger.info(f\"Setting HYFI_PROJECT_NAME to {project_name}\")\n        except ImportError:\n            logger.warning(\"Google Colab not detected.\")\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.NBs.clear_output","title":"<code>clear_output(wait=False)</code>  <code>staticmethod</code>","text":"<p>Clear the output of the current notebook.</p> Source code in <code>hyfi/utils/notebooks.py</code> <pre><code>@staticmethod\ndef clear_output(wait=False):\n    \"\"\"Clear the output of the current notebook.\"\"\"\n    from IPython import display\n\n    if NBs.is_notebook():\n        display.clear_output(wait=wait)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.NBs.colored_str","title":"<code>colored_str(s, color='black')</code>  <code>staticmethod</code>","text":"<p>Colored string.</p> Source code in <code>hyfi/utils/notebooks.py</code> <pre><code>@staticmethod\ndef colored_str(s, color=\"black\"):\n    \"\"\"Colored string.\"\"\"\n    # return \"&lt;text style=color:{}&gt;{}&lt;/text&gt;\".format(color, s)\n    return \"&lt;text style=color:{}&gt;{}&lt;/text&gt;\".format(color, s.replace(\"\\n\", \"&lt;br&gt;\"))\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.NBs.create_button","title":"<code>create_button(description, button_style='', icon='check', layout=None, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a button widget.</p> Source code in <code>hyfi/utils/notebooks.py</code> <pre><code>@staticmethod\ndef create_button(\n    description, button_style=\"\", icon=\"check\", layout=None, **kwargs\n):\n    \"\"\"Create a button widget.\"\"\"\n    import ipywidgets as widgets\n\n    layout = (\n        widgets.Layout(width=\"auto\") if layout is None else widgets.Layout(**layout)\n    )\n    return widgets.Button(\n        description=description,\n        button_style=button_style,\n        icon=icon,\n        layout=layout,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.NBs.create_dropdown","title":"<code>create_dropdown(options, value, description, disabled=False, style=None, layout=None, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a dropdown widget.</p> Source code in <code>hyfi/utils/notebooks.py</code> <pre><code>@staticmethod\ndef create_dropdown(\n    options, value, description, disabled=False, style=None, layout=None, **kwargs\n):\n    \"\"\"Create a dropdown widget.\"\"\"\n    import ipywidgets as widgets\n\n    if style is None:\n        style = {\"description_width\": \"initial\"}\n\n    layout = (\n        widgets.Layout(width=\"auto\") if layout is None else widgets.Layout(**layout)\n    )\n    return widgets.Dropdown(\n        options=options,\n        value=value,\n        description=description,\n        disabled=disabled,\n        style=style,\n        layout=layout,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.NBs.create_floatslider","title":"<code>create_floatslider(min=0.0, max=1.0, step=0.1, value=None, description='', disabled=False, continuous_update=False, orientation='horizontal', readout=True, readout_format='.1f', style=None, layout=None, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a float slider widget.</p> Source code in <code>hyfi/utils/notebooks.py</code> <pre><code>@staticmethod\ndef create_floatslider(\n    min=0.0,\n    max=1.0,\n    step=0.1,\n    value=None,\n    description=\"\",\n    disabled=False,\n    continuous_update=False,\n    orientation=\"horizontal\",\n    readout=True,\n    readout_format=\".1f\",\n    style=None,\n    layout=None,\n    **kwargs,\n):\n    \"\"\"Create a float slider widget.\"\"\"\n    if style is None:\n        style = {\"description_width\": \"initial\"}\n    import ipywidgets as widgets\n\n    layout = (\n        widgets.Layout(width=\"auto\") if layout is None else widgets.Layout(**layout)\n    )\n    return widgets.FloatSlider(\n        min=min,\n        max=max,\n        step=step,\n        value=value,\n        description=description,\n        disabled=disabled,\n        continuous_update=continuous_update,\n        orientation=orientation,\n        readout=readout,\n        readout_format=readout_format,\n        style=style,\n        layout=layout,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.NBs.create_image","title":"<code>create_image(filename=None, format=None, width=None, height=None, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create an image widget.</p> Source code in <code>hyfi/utils/notebooks.py</code> <pre><code>@staticmethod\ndef create_image(\n    filename=None,\n    format=None,\n    width=None,\n    height=None,\n    **kwargs,\n):\n    \"\"\"Create an image widget.\"\"\"\n    import ipywidgets as widgets\n\n    # from urllib.request import urlopen\n\n    if filename is None:\n        url = \"https://assets.entelecheia.cc/img/placeholder.png\"\n        # img = urlopen(url).read()\n        img = IOLIBs.read(url)\n        _format = \"png\"\n    else:\n        img = IOLIBs.read(filename)\n        _format = format or filename.split(\".\")[-1]\n    return widgets.Image(\n        value=img,\n        format=_format,\n        width=width,\n        height=height,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.NBs.create_radiobutton","title":"<code>create_radiobutton(options, description, value=None, disabled=False, style=None, layout=None, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a radiobutton widget.</p> Source code in <code>hyfi/utils/notebooks.py</code> <pre><code>@staticmethod\ndef create_radiobutton(\n    options,\n    description,\n    value=None,\n    disabled=False,\n    style=None,\n    layout=None,\n    **kwargs,\n):\n    \"\"\"Create a radiobutton widget.\"\"\"\n    import ipywidgets as widgets\n\n    if style is None:\n        style = {\"description_width\": \"initial\"}\n\n    layout = (\n        widgets.Layout(width=\"auto\") if layout is None else widgets.Layout(**layout)\n    )\n    return widgets.RadioButtons(\n        options=options,\n        value=value,\n        description=description,\n        disabled=disabled,\n        style=style,\n        layout=layout,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.NBs.create_textarea","title":"<code>create_textarea(value, description, placeholder='', disabled=False, style=None, layout=None, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a textarea widget.</p> Source code in <code>hyfi/utils/notebooks.py</code> <pre><code>@staticmethod\ndef create_textarea(\n    value,\n    description,\n    placeholder=\"\",\n    disabled=False,\n    style=None,\n    layout=None,\n    **kwargs,\n):\n    \"\"\"Create a textarea widget.\"\"\"\n    import ipywidgets as widgets\n\n    if style is None:\n        style = {\"description_width\": \"initial\"}\n\n    layout = (\n        widgets.Layout(width=\"auto\") if layout is None else widgets.Layout(**layout)\n    )\n    return widgets.Textarea(\n        value=value,\n        placeholder=placeholder,\n        description=description,\n        disabled=disabled,\n        style=style,\n        layout=layout,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.NBs.display","title":"<code>display(*objs, include=None, exclude=None, metadata=None, transient=None, display_id=None, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Display an object in the current notebook.</p> Source code in <code>hyfi/utils/notebooks.py</code> <pre><code>@staticmethod\ndef display(\n    *objs,\n    include=None,\n    exclude=None,\n    metadata=None,\n    transient=None,\n    display_id=None,\n    **kwargs,\n):\n    \"\"\"Display an object in the current notebook.\"\"\"\n    from IPython import display\n\n    if NBs.is_notebook() and objs is not None:\n        return display.display(\n            *objs,\n            include=include,\n            exclude=exclude,\n            metadata=metadata,\n            transient=transient,\n            display_id=display_id,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.NBs.display_image","title":"<code>display_image(data=None, url=None, filename=None, format=None, embed=None, width=None, height=None, retina=False, unconfined=False, metadata=None, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Display an image, which can be given as raw data or a URL.</p>"},{"location":"reference/utils/#hyfi.utils.NBs.display_image--parameters","title":"Parameters","text":"<p>data : unicode, str or bytes     The raw image data or a URL or filename to load the data from.     This always results in embedded image data. url : unicode     A URL to download the data from. If you specify <code>url=</code>,     the image data will not be embedded unless you also specify <code>embed=True</code>. filename : unicode     Path to a local file to load the data from.     Images from a file are always embedded. format : unicode     The format of the image data (png/jpeg/jpg/gif). If a filename or URL is given     for format will be inferred from the filename extension. embed : bool     Should the image data be embedded using a data URI (True) or be     loaded using an  tag. Set this to True if you want the image     to be viewable later with no internet connection in the notebook.</p> <pre><code>Default is `True`, unless the keyword argument `url` is set, then\ndefault value is `False`.\n\nNote that QtConsole is not able to display images if `embed` is set to `False`\n</code></pre> <p>width : int     Width in pixels to which to constrain the image in html height : int     Height in pixels to which to constrain the image in html retina : bool     Automatically set the width and height to half of the measured     width and height.     This only works for embedded images because it reads the width/height     from image data.     For non-embedded images, you can just set the desired display width     and height directly. unconfined: bool     Set unconfined=True to disable max-width confinement of the image. metadata: dict     Specify extra metadata to attach to the image.</p> Source code in <code>hyfi/utils/notebooks.py</code> <pre><code>@staticmethod\ndef display_image(\n    data=None,\n    url=None,\n    filename=None,\n    format=None,\n    embed=None,\n    width=None,\n    height=None,\n    retina=False,\n    unconfined=False,\n    metadata=None,\n    **kwargs,\n):\n    \"\"\"\n    Display an image, which can be given as raw data or a URL.\n\n    Parameters\n    ----------\n    data : unicode, str or bytes\n        The raw image data or a URL or filename to load the data from.\n        This always results in embedded image data.\n    url : unicode\n        A URL to download the data from. If you specify `url=`,\n        the image data will not be embedded unless you also specify `embed=True`.\n    filename : unicode\n        Path to a local file to load the data from.\n        Images from a file are always embedded.\n    format : unicode\n        The format of the image data (png/jpeg/jpg/gif). If a filename or URL is given\n        for format will be inferred from the filename extension.\n    embed : bool\n        Should the image data be embedded using a data URI (True) or be\n        loaded using an &lt;img&gt; tag. Set this to True if you want the image\n        to be viewable later with no internet connection in the notebook.\n\n        Default is `True`, unless the keyword argument `url` is set, then\n        default value is `False`.\n\n        Note that QtConsole is not able to display images if `embed` is set to `False`\n    width : int\n        Width in pixels to which to constrain the image in html\n    height : int\n        Height in pixels to which to constrain the image in html\n    retina : bool\n        Automatically set the width and height to half of the measured\n        width and height.\n        This only works for embedded images because it reads the width/height\n        from image data.\n        For non-embedded images, you can just set the desired display width\n        and height directly.\n    unconfined: bool\n        Set unconfined=True to disable max-width confinement of the image.\n    metadata: dict\n        Specify extra metadata to attach to the image.\n\n    \"\"\"\n    from IPython import display\n\n    if NBs.is_notebook():\n        img = display.Image(\n            data=data,\n            url=url,\n            filename=filename,\n            format=format,\n            embed=embed,\n            width=width,\n            height=height,\n            retina=retina,\n            unconfined=unconfined,\n            metadata=metadata,\n            **kwargs,\n        )\n        return display.display(img)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.NBs.get_display","title":"<code>get_display()</code>  <code>staticmethod</code>","text":"<p>Get the display object for the current environment.</p> Source code in <code>hyfi/utils/notebooks.py</code> <pre><code>@staticmethod\ndef get_display():\n    \"\"\"Get the display object for the current environment.\"\"\"\n    try:\n        from ipywidgets import Output\n    except ImportError:\n        logger.info(\"ipywidgets not installed.\")\n        return None\n\n    return Output() if NBs.is_notebook() else None\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.NBs.hide_code_in_slideshow","title":"<code>hide_code_in_slideshow()</code>  <code>staticmethod</code>","text":"<p>Hide code in slideshow.</p> Source code in <code>hyfi/utils/notebooks.py</code> <pre><code>@staticmethod\ndef hide_code_in_slideshow():\n    \"\"\"Hide code in slideshow.\"\"\"\n    import binascii\n\n    from IPython import display\n\n    uid = binascii.hexlify(os.urandom(8)).decode()\n    html = \"\"\"&lt;div id=\"%s\"&gt;&lt;/div&gt;\n    &lt;script type=\"text/javascript\"&gt;\n        $(function(){\n            var p = $(\"#%s\");\n            if (p.length==0) return;\n            while (!p.hasClass(\"cell\")) {\n                p=p.parent();\n                if (p.prop(\"tagName\") ==\"body\") return;\n            }\n            var cell = p;\n            cell.find(\".input\").addClass(\"hide-in-slideshow\")\n        });\n    &lt;/script&gt;\"\"\" % (\n        uid,\n        uid,\n    )\n    display.display_html(html, raw=True)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.NBs.is_colab","title":"<code>is_colab()</code>  <code>staticmethod</code>","text":"<p>Check if the code is running in Google Colab.</p> Source code in <code>hyfi/utils/notebooks.py</code> <pre><code>@staticmethod\ndef is_colab():\n    \"\"\"Check if the code is running in Google Colab.\"\"\"\n    is_colab = \"google.colab\" in sys.modules\n    if is_colab:\n        logger.info(\"Google Colab detected.\")\n    else:\n        logger.info(\"Google Colab not detected.\")\n    return is_colab\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.NBs.is_notebook","title":"<code>is_notebook()</code>  <code>staticmethod</code>","text":"<p>Check if the code is running in a notebook.</p> Source code in <code>hyfi/utils/notebooks.py</code> <pre><code>@staticmethod\ndef is_notebook():\n    \"\"\"Check if the code is running in a notebook.\"\"\"\n    try:\n        get_ipython  # type: ignore\n    except NameError:\n        return False\n    # pylint: disable=undefined-variable\n    shell_type = get_ipython().__class__.__name__  # type: ignore # noqa\n    # logger.info(f\"shell type: {shell_type}\")\n    return shell_type in [\"ZMQInteractiveShell\", \"Shell\"]\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.NBs.load_extentions","title":"<code>load_extentions(exts=None)</code>  <code>staticmethod</code>","text":"<p>Load extentions.</p> Source code in <code>hyfi/utils/notebooks.py</code> <pre><code>@staticmethod\ndef load_extentions(exts=None):\n    \"\"\"Load extentions.\"\"\"\n    if exts is None:\n        exts = [\"autotime\"]\n    if not NBs.is_notebook():\n        return\n    with contextlib.suppress(ImportError):\n        from IPython.core.getipython import get_ipython\n\n        ip = get_ipython()\n        if ip is None:\n            return\n        try:\n            loaded = ip.extension_manager.loaded\n            for ext in exts:\n                if ext not in loaded:\n                    ip.extentension_manager.load_extension(ext)\n        except AttributeError:\n            for ext in exts:\n                try:\n                    ip.magic(f\"load_ext {ext}\")\n                except ModuleNotFoundError:\n                    logger.info(\"Extension %s not found. Install it first.\", ext)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.NBs.mount_google_drive","title":"<code>mount_google_drive(project_root='', project_name='', mountpoint='/content/drive', force_remount=False, timeout_ms=120000)</code>  <code>staticmethod</code>","text":"<p>Mount Google Drive to Colab.</p> Source code in <code>hyfi/utils/notebooks.py</code> <pre><code>@staticmethod\ndef mount_google_drive(\n    project_root: str = \"\",\n    project_name: str = \"\",\n    mountpoint: str = \"/content/drive\",\n    force_remount: bool = False,\n    timeout_ms: int = 120000,\n) -&gt; None:\n    \"\"\"Mount Google Drive to Colab.\"\"\"\n    try:\n        from google.colab import drive  # type: ignore\n\n        drive.mount(mountpoint, force_remount=force_remount, timeout_ms=timeout_ms)\n\n        if project_root:\n            if not project_root.startswith(\n                os.path.sep\n            ) and not project_root.startswith(\"..\"):\n                project_root = os.path.join(mountpoint, project_root)\n            ENVs.set_osenv(\"HYFI_PROJECT_ROOT\", project_root)\n            logger.info(f\"Setting HYFI_PROJECT_ROOT to {project_root}\")\n        if project_name:\n            ENVs.set_osenv(\"HYFI_PROJECT_NAME\", project_name)\n            logger.info(f\"Setting HYFI_PROJECT_NAME to {project_name}\")\n    except ImportError:\n        logger.warning(\"Google Colab not detected.\")\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.NBs.set_matplotlib_formats","title":"<code>set_matplotlib_formats(*formats, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Set matplotlib formats.</p> Source code in <code>hyfi/utils/notebooks.py</code> <pre><code>@staticmethod\ndef set_matplotlib_formats(*formats, **kwargs):\n    \"\"\"Set matplotlib formats.\"\"\"\n    if NBs.is_notebook():\n        from IPython.core.display import set_matplotlib_formats\n\n        set_matplotlib_formats(*formats, **kwargs)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.PKGs","title":"<code>PKGs</code>","text":"Source code in <code>hyfi/utils/packages.py</code> <pre><code>class PKGs:\n    @staticmethod\n    def gitclone(\n        url: str,\n        targetdir: str = \"\",\n        verbose: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Clone a git repository from the specified URL.\n\n        Args:\n            url (str): The URL of the git repository to clone.\n            targetdir (str, optional): The directory to clone the repository into. Defaults to \"\".\n            verbose (bool, optional): Whether to print the output of the git command. Defaults to False.\n        \"\"\"\n        if targetdir:\n            res = subprocess.run(\n                [\"git\", \"clone\", url, targetdir], stdout=subprocess.PIPE\n            ).stdout.decode(\"utf-8\")\n        else:\n            res = subprocess.run(\n                [\"git\", \"clone\", url], stdout=subprocess.PIPE\n            ).stdout.decode(\"utf-8\")\n        if verbose:\n            print(res)\n        else:\n            logger.info(res)\n\n    @staticmethod\n    def pip(\n        name: str,\n        upgrade: bool = False,\n        prelease: bool = False,\n        editable: bool = False,\n        quiet: bool = True,\n        find_links: str = \"\",\n        requirement: bool = False,\n        force_reinstall: bool = False,\n        verbose: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Install a package using pip.\n\n        Args:\n            name (str): The name of the package to install.\n            upgrade (bool, optional): Whether to upgrade the package if it is already installed. Defaults to False.\n            prelease (bool, optional): Whether to include pre-release versions. Defaults to False.\n            editable (bool, optional): Whether to install the package in editable mode. Defaults to False.\n            quiet (bool, optional): Whether to suppress output. Defaults to True.\n            find_links (str, optional): URL to look for packages at. Defaults to \"\".\n            requirement (bool, optional): Whether to install from the given requirements file. Defaults to False.\n            force_reinstall (bool, optional): Whether to force a reinstall of the package. Defaults to False.\n            verbose (bool, optional): Whether to print the output of the pip command. Defaults to False.\n            **kwargs: Additional keyword arguments to pass to pip.\n\n        Returns:\n            None\n        \"\"\"\n        _cmd = [\"pip\", \"install\"]\n        if upgrade:\n            _cmd.append(\"--upgrade\")\n        if prelease:\n            _cmd.append(\"--pre\")\n        if editable:\n            _cmd.append(\"--editable\")\n        if quiet:\n            _cmd.append(\"--quiet\")\n        if find_links:\n            _cmd += [\"--find-links\", find_links]\n        if requirement:\n            _cmd.append(\"--requirement\")\n        if force_reinstall:\n            _cmd.append(\"--force-reinstall\")\n        for k in kwargs:\n            k = k.replace(\"_\", \"-\")\n            _cmd.append(f\"--{k}\")\n        _cmd.append(name)\n        if verbose:\n            logger.info(f\"Installing: {' '.join(_cmd)}\")\n        res = subprocess.run(_cmd, stdout=subprocess.PIPE).stdout.decode(\"utf-8\")\n        if verbose:\n            print(res)\n        else:\n            logger.info(res)\n\n    @staticmethod\n    def pipi(name: str, verbose: bool = False) -&gt; None:\n        \"\"\"Install a package using pip.\"\"\"\n        res = subprocess.run(\n            [\"pip\", \"install\", name], stdout=subprocess.PIPE\n        ).stdout.decode(\"utf-8\")\n        if verbose:\n            print(res)\n        else:\n            logger.info(res)\n\n    @staticmethod\n    def pipie(name: str, verbose: bool = False) -&gt; None:\n        \"\"\"Install a editable package using pip.\"\"\"\n        res = subprocess.run(\n            [\"git\", \"install\", \"-e\", name], stdout=subprocess.PIPE\n        ).stdout.decode(\"utf-8\")\n        if verbose:\n            print(res)\n        else:\n            logger.info(res)\n\n    @staticmethod\n    def apti(name: str, verbose: bool = False) -&gt; None:\n        \"\"\"Install a package using apt.\"\"\"\n        res = subprocess.run(\n            [\"apt\", \"install\", name], stdout=subprocess.PIPE\n        ).stdout.decode(\"utf-8\")\n        if verbose:\n            print(res)\n        else:\n            logger.info(res)\n\n    @staticmethod\n    def load_module_from_file(name: str, libpath: str, specname: str = \"\") -&gt; None:\n        \"\"\"Load a module from a file\"\"\"\n        module_path = os.path.join(libpath, name.replace(\".\", os.path.sep))\n        if IOLIBs.is_file(f\"{module_path}.py\"):\n            module_path = f\"{module_path}.py\"\n        elif IOLIBs.is_dir(module_path):\n            module_path = os.path.join(module_path, \"__init__.py\")\n        else:\n            module_path = str(Path(module_path).parent / \"__init__.py\")\n\n        spec = importlib.util.spec_from_file_location(name, module_path)  # type: ignore\n        module = importlib.util.module_from_spec(spec)  # type: ignore\n        if not specname:\n            specname = spec.name\n        sys.modules[specname] = module\n        spec.loader.exec_module(module)\n\n    @staticmethod\n    def ensure_import_module(\n        name: str,\n        libpath: str,\n        liburi: str,\n        specname: str = \"\",\n        syspath: str = \"\",\n    ) -&gt; None:\n        \"\"\"Ensure a module is imported, if not, clone it from a git repo and load it\"\"\"\n        try:\n            if specname:\n                importlib.import_module(specname)\n            else:\n                importlib.import_module(name)\n            logger.info(f\"{name} imported\")\n        except ImportError:\n            if not os.path.exists(libpath):\n                logger.info(f\"{libpath} not found, cloning from {liburi}\")\n                PKGs.gitclone(liburi, libpath)\n            if not syspath:\n                syspath = libpath\n            if syspath not in sys.path:\n                sys.path.append(syspath)\n            PKGs.load_module_from_file(name, syspath, specname)\n            specname = specname or name\n            logger.info(f\"{name} not imported, loading from {syspath} as {specname}\")\n\n    @staticmethod\n    def getsource(obj: str) -&gt; str:\n        \"\"\"\n        Return the source code of the object.\n\n        Args:\n            obj (str): The object to get the source code from.\n\n        Returns:\n            str: The source code of the object.\n\n        \"\"\"\n        try:\n            mod_name, object_name = obj.rsplit(\".\", 1)\n            mod = importlib.import_module(mod_name)\n            obj_ = getattr(mod, object_name)\n            return inspect.getsource(obj_)\n        except Exception as e:\n            logger.error(f\"Error getting source: {e}\")\n            return \"\"\n\n    @staticmethod\n    def viewsource(obj: str) -&gt; None:\n        \"\"\"Print the source code of the object.\"\"\"\n        print(PKGs.getsource(obj))\n\n    @staticmethod\n    def get_module_name_stack() -&gt; List[str]:\n        \"\"\"Get the name of the module that called this function.\"\"\"\n        try:\n            _stack = inspect.stack()\n            return [\n                getattr(inspect.getmodule(_stack[i][0]), \"__name__\", \"\")\n                for i in range(1, len(_stack))\n            ]\n        except Exception as e:\n            logger.error(f\"Error getting module name stack: {e}\")\n            return []\n\n    @staticmethod\n    def get_caller_module_name(caller_stack_depth: int = 2) -&gt; str:\n        \"\"\"Get the name of the module that called this function.\"\"\"\n        _stack = PKGs.get_module_name_stack()\n        if len(_stack) &lt; caller_stack_depth + 1:\n            logger.info(\"Returning top level module name (depth %d)\", len(_stack) - 1)\n            return _stack[-1]\n        return _stack[caller_stack_depth]\n\n    @staticmethod\n    def get_next_level_caller_package_name() -&gt; Optional[str]:\n        \"\"\"Get the name of the package that called this function.\"\"\"\n        _stack = PKGs.get_module_name_stack()\n        package_name = _stack[0].split(\".\")[0]\n        for name in _stack:\n            name = name.split(\".\")[0]\n            if name != package_name:\n                return name\n\n    @staticmethod\n    def is_importable(module_name: str) -&gt; bool:\n        module_spec = importlib.util.find_spec(module_name)  # type: ignore\n        return module_spec is not None\n\n    @staticmethod\n    def safe_import_module(module_name: str) -&gt; Any:\n        \"\"\"Safely imports a module.\"\"\"\n        try:\n            return importlib.import_module(module_name)\n        except ImportError:\n            logger.debug(\"Failed to import module: %s\", module_name)\n            return None\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.PKGs.apti","title":"<code>apti(name, verbose=False)</code>  <code>staticmethod</code>","text":"<p>Install a package using apt.</p> Source code in <code>hyfi/utils/packages.py</code> <pre><code>@staticmethod\ndef apti(name: str, verbose: bool = False) -&gt; None:\n    \"\"\"Install a package using apt.\"\"\"\n    res = subprocess.run(\n        [\"apt\", \"install\", name], stdout=subprocess.PIPE\n    ).stdout.decode(\"utf-8\")\n    if verbose:\n        print(res)\n    else:\n        logger.info(res)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.PKGs.ensure_import_module","title":"<code>ensure_import_module(name, libpath, liburi, specname='', syspath='')</code>  <code>staticmethod</code>","text":"<p>Ensure a module is imported, if not, clone it from a git repo and load it</p> Source code in <code>hyfi/utils/packages.py</code> <pre><code>@staticmethod\ndef ensure_import_module(\n    name: str,\n    libpath: str,\n    liburi: str,\n    specname: str = \"\",\n    syspath: str = \"\",\n) -&gt; None:\n    \"\"\"Ensure a module is imported, if not, clone it from a git repo and load it\"\"\"\n    try:\n        if specname:\n            importlib.import_module(specname)\n        else:\n            importlib.import_module(name)\n        logger.info(f\"{name} imported\")\n    except ImportError:\n        if not os.path.exists(libpath):\n            logger.info(f\"{libpath} not found, cloning from {liburi}\")\n            PKGs.gitclone(liburi, libpath)\n        if not syspath:\n            syspath = libpath\n        if syspath not in sys.path:\n            sys.path.append(syspath)\n        PKGs.load_module_from_file(name, syspath, specname)\n        specname = specname or name\n        logger.info(f\"{name} not imported, loading from {syspath} as {specname}\")\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.PKGs.get_caller_module_name","title":"<code>get_caller_module_name(caller_stack_depth=2)</code>  <code>staticmethod</code>","text":"<p>Get the name of the module that called this function.</p> Source code in <code>hyfi/utils/packages.py</code> <pre><code>@staticmethod\ndef get_caller_module_name(caller_stack_depth: int = 2) -&gt; str:\n    \"\"\"Get the name of the module that called this function.\"\"\"\n    _stack = PKGs.get_module_name_stack()\n    if len(_stack) &lt; caller_stack_depth + 1:\n        logger.info(\"Returning top level module name (depth %d)\", len(_stack) - 1)\n        return _stack[-1]\n    return _stack[caller_stack_depth]\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.PKGs.get_module_name_stack","title":"<code>get_module_name_stack()</code>  <code>staticmethod</code>","text":"<p>Get the name of the module that called this function.</p> Source code in <code>hyfi/utils/packages.py</code> <pre><code>@staticmethod\ndef get_module_name_stack() -&gt; List[str]:\n    \"\"\"Get the name of the module that called this function.\"\"\"\n    try:\n        _stack = inspect.stack()\n        return [\n            getattr(inspect.getmodule(_stack[i][0]), \"__name__\", \"\")\n            for i in range(1, len(_stack))\n        ]\n    except Exception as e:\n        logger.error(f\"Error getting module name stack: {e}\")\n        return []\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.PKGs.get_next_level_caller_package_name","title":"<code>get_next_level_caller_package_name()</code>  <code>staticmethod</code>","text":"<p>Get the name of the package that called this function.</p> Source code in <code>hyfi/utils/packages.py</code> <pre><code>@staticmethod\ndef get_next_level_caller_package_name() -&gt; Optional[str]:\n    \"\"\"Get the name of the package that called this function.\"\"\"\n    _stack = PKGs.get_module_name_stack()\n    package_name = _stack[0].split(\".\")[0]\n    for name in _stack:\n        name = name.split(\".\")[0]\n        if name != package_name:\n            return name\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.PKGs.getsource","title":"<code>getsource(obj)</code>  <code>staticmethod</code>","text":"<p>Return the source code of the object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str</code> <p>The object to get the source code from.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The source code of the object.</p> Source code in <code>hyfi/utils/packages.py</code> <pre><code>@staticmethod\ndef getsource(obj: str) -&gt; str:\n    \"\"\"\n    Return the source code of the object.\n\n    Args:\n        obj (str): The object to get the source code from.\n\n    Returns:\n        str: The source code of the object.\n\n    \"\"\"\n    try:\n        mod_name, object_name = obj.rsplit(\".\", 1)\n        mod = importlib.import_module(mod_name)\n        obj_ = getattr(mod, object_name)\n        return inspect.getsource(obj_)\n    except Exception as e:\n        logger.error(f\"Error getting source: {e}\")\n        return \"\"\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.PKGs.gitclone","title":"<code>gitclone(url, targetdir='', verbose=False)</code>  <code>staticmethod</code>","text":"<p>Clone a git repository from the specified URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the git repository to clone.</p> required <code>targetdir</code> <code>str</code> <p>The directory to clone the repository into. Defaults to \"\".</p> <code>''</code> <code>verbose</code> <code>bool</code> <p>Whether to print the output of the git command. Defaults to False.</p> <code>False</code> Source code in <code>hyfi/utils/packages.py</code> <pre><code>@staticmethod\ndef gitclone(\n    url: str,\n    targetdir: str = \"\",\n    verbose: bool = False,\n) -&gt; None:\n    \"\"\"\n    Clone a git repository from the specified URL.\n\n    Args:\n        url (str): The URL of the git repository to clone.\n        targetdir (str, optional): The directory to clone the repository into. Defaults to \"\".\n        verbose (bool, optional): Whether to print the output of the git command. Defaults to False.\n    \"\"\"\n    if targetdir:\n        res = subprocess.run(\n            [\"git\", \"clone\", url, targetdir], stdout=subprocess.PIPE\n        ).stdout.decode(\"utf-8\")\n    else:\n        res = subprocess.run(\n            [\"git\", \"clone\", url], stdout=subprocess.PIPE\n        ).stdout.decode(\"utf-8\")\n    if verbose:\n        print(res)\n    else:\n        logger.info(res)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.PKGs.load_module_from_file","title":"<code>load_module_from_file(name, libpath, specname='')</code>  <code>staticmethod</code>","text":"<p>Load a module from a file</p> Source code in <code>hyfi/utils/packages.py</code> <pre><code>@staticmethod\ndef load_module_from_file(name: str, libpath: str, specname: str = \"\") -&gt; None:\n    \"\"\"Load a module from a file\"\"\"\n    module_path = os.path.join(libpath, name.replace(\".\", os.path.sep))\n    if IOLIBs.is_file(f\"{module_path}.py\"):\n        module_path = f\"{module_path}.py\"\n    elif IOLIBs.is_dir(module_path):\n        module_path = os.path.join(module_path, \"__init__.py\")\n    else:\n        module_path = str(Path(module_path).parent / \"__init__.py\")\n\n    spec = importlib.util.spec_from_file_location(name, module_path)  # type: ignore\n    module = importlib.util.module_from_spec(spec)  # type: ignore\n    if not specname:\n        specname = spec.name\n    sys.modules[specname] = module\n    spec.loader.exec_module(module)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.PKGs.pip","title":"<code>pip(name, upgrade=False, prelease=False, editable=False, quiet=True, find_links='', requirement=False, force_reinstall=False, verbose=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Install a package using pip.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the package to install.</p> required <code>upgrade</code> <code>bool</code> <p>Whether to upgrade the package if it is already installed. Defaults to False.</p> <code>False</code> <code>prelease</code> <code>bool</code> <p>Whether to include pre-release versions. Defaults to False.</p> <code>False</code> <code>editable</code> <code>bool</code> <p>Whether to install the package in editable mode. Defaults to False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Whether to suppress output. Defaults to True.</p> <code>True</code> <code>find_links</code> <code>str</code> <p>URL to look for packages at. Defaults to \"\".</p> <code>''</code> <code>requirement</code> <code>bool</code> <p>Whether to install from the given requirements file. Defaults to False.</p> <code>False</code> <code>force_reinstall</code> <code>bool</code> <p>Whether to force a reinstall of the package. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print the output of the pip command. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to pip.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>hyfi/utils/packages.py</code> <pre><code>@staticmethod\ndef pip(\n    name: str,\n    upgrade: bool = False,\n    prelease: bool = False,\n    editable: bool = False,\n    quiet: bool = True,\n    find_links: str = \"\",\n    requirement: bool = False,\n    force_reinstall: bool = False,\n    verbose: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Install a package using pip.\n\n    Args:\n        name (str): The name of the package to install.\n        upgrade (bool, optional): Whether to upgrade the package if it is already installed. Defaults to False.\n        prelease (bool, optional): Whether to include pre-release versions. Defaults to False.\n        editable (bool, optional): Whether to install the package in editable mode. Defaults to False.\n        quiet (bool, optional): Whether to suppress output. Defaults to True.\n        find_links (str, optional): URL to look for packages at. Defaults to \"\".\n        requirement (bool, optional): Whether to install from the given requirements file. Defaults to False.\n        force_reinstall (bool, optional): Whether to force a reinstall of the package. Defaults to False.\n        verbose (bool, optional): Whether to print the output of the pip command. Defaults to False.\n        **kwargs: Additional keyword arguments to pass to pip.\n\n    Returns:\n        None\n    \"\"\"\n    _cmd = [\"pip\", \"install\"]\n    if upgrade:\n        _cmd.append(\"--upgrade\")\n    if prelease:\n        _cmd.append(\"--pre\")\n    if editable:\n        _cmd.append(\"--editable\")\n    if quiet:\n        _cmd.append(\"--quiet\")\n    if find_links:\n        _cmd += [\"--find-links\", find_links]\n    if requirement:\n        _cmd.append(\"--requirement\")\n    if force_reinstall:\n        _cmd.append(\"--force-reinstall\")\n    for k in kwargs:\n        k = k.replace(\"_\", \"-\")\n        _cmd.append(f\"--{k}\")\n    _cmd.append(name)\n    if verbose:\n        logger.info(f\"Installing: {' '.join(_cmd)}\")\n    res = subprocess.run(_cmd, stdout=subprocess.PIPE).stdout.decode(\"utf-8\")\n    if verbose:\n        print(res)\n    else:\n        logger.info(res)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.PKGs.pipi","title":"<code>pipi(name, verbose=False)</code>  <code>staticmethod</code>","text":"<p>Install a package using pip.</p> Source code in <code>hyfi/utils/packages.py</code> <pre><code>@staticmethod\ndef pipi(name: str, verbose: bool = False) -&gt; None:\n    \"\"\"Install a package using pip.\"\"\"\n    res = subprocess.run(\n        [\"pip\", \"install\", name], stdout=subprocess.PIPE\n    ).stdout.decode(\"utf-8\")\n    if verbose:\n        print(res)\n    else:\n        logger.info(res)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.PKGs.pipie","title":"<code>pipie(name, verbose=False)</code>  <code>staticmethod</code>","text":"<p>Install a editable package using pip.</p> Source code in <code>hyfi/utils/packages.py</code> <pre><code>@staticmethod\ndef pipie(name: str, verbose: bool = False) -&gt; None:\n    \"\"\"Install a editable package using pip.\"\"\"\n    res = subprocess.run(\n        [\"git\", \"install\", \"-e\", name], stdout=subprocess.PIPE\n    ).stdout.decode(\"utf-8\")\n    if verbose:\n        print(res)\n    else:\n        logger.info(res)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.PKGs.safe_import_module","title":"<code>safe_import_module(module_name)</code>  <code>staticmethod</code>","text":"<p>Safely imports a module.</p> Source code in <code>hyfi/utils/packages.py</code> <pre><code>@staticmethod\ndef safe_import_module(module_name: str) -&gt; Any:\n    \"\"\"Safely imports a module.\"\"\"\n    try:\n        return importlib.import_module(module_name)\n    except ImportError:\n        logger.debug(\"Failed to import module: %s\", module_name)\n        return None\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.PKGs.viewsource","title":"<code>viewsource(obj)</code>  <code>staticmethod</code>","text":"<p>Print the source code of the object.</p> Source code in <code>hyfi/utils/packages.py</code> <pre><code>@staticmethod\ndef viewsource(obj: str) -&gt; None:\n    \"\"\"Print the source code of the object.\"\"\"\n    print(PKGs.getsource(obj))\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.SAFEEVAL","title":"<code>SAFEEVAL</code>","text":"Source code in <code>hyfi/utils/safeeval.py</code> <pre><code>class SAFEEVAL:\n    @staticmethod\n    def safe_eval(\n        expr: str,\n        operators=None,\n        functions: Optional[Dict[str, Callable]] = None,\n        names: Optional[Dict[str, Any]] = None,\n    ):\n        \"\"\"Simply evaluate an expresssion\"\"\"\n        s = SafeEval(operators=operators, functions=functions, names=names)\n        return s.eval(expr)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.SAFEEVAL.safe_eval","title":"<code>safe_eval(expr, operators=None, functions=None, names=None)</code>  <code>staticmethod</code>","text":"<p>Simply evaluate an expresssion</p> Source code in <code>hyfi/utils/safeeval.py</code> <pre><code>@staticmethod\ndef safe_eval(\n    expr: str,\n    operators=None,\n    functions: Optional[Dict[str, Callable]] = None,\n    names: Optional[Dict[str, Any]] = None,\n):\n    \"\"\"Simply evaluate an expresssion\"\"\"\n    s = SafeEval(operators=operators, functions=functions, names=names)\n    return s.eval(expr)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.SafeEval","title":"<code>SafeEval</code>","text":"<p>               Bases: <code>object</code></p> <p>A very simple expression parser.</p> <p>s = SafeEval() s.eval(\"20 + 30 - ( 10 * 5)\") 0</p> Source code in <code>hyfi/utils/safeeval.py</code> <pre><code>class SafeEval(object):  # pylint: disable=too-few-public-methods\n    \"\"\"A very simple expression parser.\n    &gt;&gt;&gt; s = SafeEval()\n    &gt;&gt;&gt; s.eval(\"20 + 30 - ( 10 * 5)\")\n    0\n    \"\"\"\n\n    expr = \"\"\n\n    def __init__(\n        self,\n        operators: Optional[Dict[Any, Callable]] = None,\n        functions: Optional[Dict[str, Callable]] = None,\n        names: Optional[Dict[str, Any]] = None,\n    ):\n        \"\"\"\n        Create the evaluator instance.  Set up valid operators (+,-, etc)\n        functions (add, random, get_val, whatever) and names.\"\"\"\n\n        if operators is None:\n            operators = DEFAULT_OPERATORS.copy()\n        if functions is None:\n            functions = DEFAULT_FUNCTIONS.copy()\n        if names is None:\n            names = DEFAULT_NAMES.copy()\n\n        self.operators = operators\n        self.functions = functions\n        self.names = names\n\n        self.nodes = {\n            ast.Expr: self._eval_expr,\n            ast.Assign: self._eval_assign,\n            ast.AugAssign: self._eval_aug_assign,\n            ast.Import: self._eval_import,\n            ast.Num: self._eval_num,\n            ast.Str: self._eval_str,\n            ast.Name: self._eval_name,\n            ast.UnaryOp: self._eval_unaryop,\n            ast.BinOp: self._eval_binop,\n            ast.BoolOp: self._eval_boolop,\n            ast.Compare: self._eval_compare,\n            ast.IfExp: self._eval_ifexp,\n            ast.Call: self._eval_call,\n            ast.keyword: self._eval_keyword,\n            ast.Subscript: self._eval_subscript,\n            ast.Attribute: self._eval_attribute,\n            ast.Index: self._eval_index,\n            ast.Slice: self._eval_slice,\n        }\n\n        # py3k stuff:\n        if hasattr(ast, \"NameConstant\"):\n            self.nodes[ast.NameConstant] = self._eval_constant\n\n        # py3.6, f-strings\n        if hasattr(ast, \"JoinedStr\"):\n            self.nodes[ast.JoinedStr] = self._eval_joinedstr  # f-string\n            self.nodes[ast.FormattedValue] = (\n                self._eval_formattedvalue\n            )  # formatted value in f-string\n\n        # py3.8 uses ast.Constant instead of ast.Num, ast.Str, ast.NameConstant\n        if hasattr(ast, \"Constant\"):\n            self.nodes[ast.Constant] = self._eval_constant\n\n        # Defaults:\n\n        self.ATTR_INDEX_FALLBACK = ATTR_INDEX_FALLBACK\n\n        # Check for forbidden functions:\n\n        for f in self.functions.values():\n            if f in DISALLOW_FUNCTIONS:\n                raise FeatureNotAvailable(f\"This function {f} is a really bad idea.\")\n\n    def __del__(self):\n        self.nodes = None\n\n    @staticmethod\n    def parse(expr):\n        \"\"\"parse an expression into a node tree\"\"\"\n\n        parsed = ast.parse(expr.strip())\n\n        if not parsed.body:\n            raise InvalidExpression(\"Sorry, cannot evaluate empty string\")\n        if len(parsed.body) &gt; 1:\n            warnings.warn(\n                f\"'{expr}' contains multiple expressions. Only the first will be used.\",\n                MultipleExpressions,\n            )\n        return parsed.body[0]\n\n    def eval(self, expr, previously_parsed=None):\n        \"\"\"evaluate an expresssion, using the operators, functions and\n        names previously set up.\"\"\"\n\n        # set a copy of the expression aside, so we can give nice errors...\n        self.expr = expr\n\n        return self._eval(previously_parsed or self.parse(expr))\n\n    def _eval(self, node):\n        \"\"\"The internal evaluator used on each node in the parsed tree.\"\"\"\n\n        try:\n            handler = self.nodes[type(node)]\n        except KeyError as e:\n            raise FeatureNotAvailable(\n                \"Sorry, {0} is not available in this \"\n                \"evaluator\".format(type(node).__name__)\n            ) from e\n\n        return handler(node)\n\n    def _eval_expr(self, node):\n        return self._eval(node.value)\n\n    def _eval_assign(self, node):\n        warnings.warn(\n            f\"Assignment ({self.expr}) attempted, but this is ignored\",\n            AssignmentAttempted,\n        )\n        return self._eval(node.value)\n\n    def _eval_aug_assign(self, node):\n        warnings.warn(\n            f\"Assignment ({self.expr}) attempted, but this is ignored\",\n            AssignmentAttempted,\n        )\n        return self._eval(node.value)\n\n    @staticmethod\n    def _eval_import(node):\n        raise FeatureNotAvailable(\"Sorry, 'import' is not allowed.\")\n\n    @staticmethod\n    def _eval_num(node):\n        return node.n\n\n    @staticmethod\n    def _eval_str(node):\n        if len(node.s) &gt; MAX_STRING_LENGTH:\n            raise IterableTooLong(\n                \"String Literal in statement is too long!\"\n                \" ({0}, when {1} is max)\".format(len(node.s), MAX_STRING_LENGTH)\n            )\n        return node.s\n\n    @staticmethod\n    def _eval_constant(node):\n        if hasattr(node.value, \"__len__\") and len(node.value) &gt; MAX_STRING_LENGTH:\n            raise IterableTooLong(\n                \"Literal in statement is too long!\"\n                \" ({0}, when {1} is max)\".format(len(node.value), MAX_STRING_LENGTH)\n            )\n        return node.value\n\n    def _eval_unaryop(self, node):\n        try:\n            operator = self.operators[type(node.op)]\n        except KeyError as e:\n            raise OperatorNotDefined(node.op, self.expr) from e\n        return operator(self._eval(node.operand))\n\n    def _eval_binop(self, node):\n        try:\n            operator = self.operators[type(node.op)]\n        except KeyError as e:\n            raise OperatorNotDefined(node.op, self.expr) from e\n        return operator(self._eval(node.left), self._eval(node.right))\n\n    def _eval_boolop(self, node):\n        to_return = False\n        for value in node.values:\n            if isinstance(node.op, ast.And):\n                to_return = self._eval(value)\n                if not to_return:\n                    break\n            elif isinstance(node.op, ast.Or):\n                to_return = self._eval(value)\n                if to_return:\n                    break\n        return to_return\n\n    def _eval_compare(self, node):\n        right = self._eval(node.left)\n        to_return = True\n        for operation, comp in zip(node.ops, node.comparators):\n            if not to_return:\n                break\n            left = right\n            right = self._eval(comp)\n            to_return = self.operators[type(operation)](left, right)\n        return to_return\n\n    def _eval_ifexp(self, node):\n        return (\n            self._eval(node.body) if self._eval(node.test) else self._eval(node.orelse)\n        )\n\n    def _eval_call(self, node):\n        if isinstance(node.func, ast.Attribute):\n            func = self._eval(node.func)\n        else:\n            try:\n                func = self.functions[node.func.id]\n            except KeyError as e:\n                raise FunctionNotDefined(node.func.id, self.expr) from e\n            except AttributeError as e:\n                raise FeatureNotAvailable(\"Lambda Functions not implemented\") from e\n\n            if func in DISALLOW_FUNCTIONS:\n                raise FeatureNotAvailable(\"This function is forbidden\")\n\n        return func(\n            *(self._eval(a) for a in node.args),\n            **dict(self._eval(k) for k in node.keywords),\n        )\n\n    def _eval_keyword(self, node):\n        return node.arg, self._eval(node.value)\n\n    def _eval_name(self, node):\n        try:\n            # This happens at least for slicing\n            # This is a safe thing to do because it is impossible\n            # that there is a true exression assigning to none\n            # (the compiler rejects it, so you can't even\n            # pass that to ast.parse)\n            if hasattr(self.names, \"__getitem__\"):\n                return self.names[node.id]\n            if callable(self.names):\n                return self.names(node)\n            raise InvalidExpression(\n                'Trying to use name (variable) \"{0}\"'\n                ' when no \"names\" defined for'\n                \" evaluator\".format(node.id)\n            )\n\n        except KeyError as e:\n            if node.id in self.functions:\n                return self.functions[node.id]\n\n            raise NameNotDefined(node.id, self.expr) from e\n\n    def _eval_subscript(self, node):\n        container = self._eval(node.value)\n        key = self._eval(node.slice)\n        try:\n            return container[key]\n        except KeyError as e:\n            raise InvalidExpression(f\"Invalid key: {key}\") from e\n\n    def _eval_attribute(self, node):\n        attr = node.attr\n        if any(attr.startswith(prefix) for prefix in DISALLOW_PREFIXES):\n            raise FeatureNotAvailable(\n                f\"Sorry, access to __attributes or func_ attributes is not available. ({attr})\"\n            )\n        if attr in DISALLOW_METHODS:\n            raise FeatureNotAvailable(f\"Sorry, this method is not available. ({attr})\")\n\n        node_evaluated = self._eval(node.value)\n\n        try:\n            return getattr(node_evaluated, attr)\n        except (AttributeError, TypeError) as e:\n            if self.ATTR_INDEX_FALLBACK:\n                with contextlib.suppress(KeyError, TypeError):\n                    return node_evaluated[attr]\n            raise AttributeDoesNotExist(attr, self.expr) from e\n\n    def _eval_index(self, node):\n        return self._eval(node.value)\n\n    def _eval_slice(self, node):\n        lower = upper = step = None\n        if node.lower is not None:\n            lower = self._eval(node.lower)\n        if node.upper is not None:\n            upper = self._eval(node.upper)\n        if node.step is not None:\n            step = self._eval(node.step)\n        return slice(lower, upper, step)\n\n    def _eval_joinedstr(self, node):\n        length = 0\n        evaluated_values = []\n        for n in node.values:\n            val = str(self._eval(n))\n            if len(val) + length &gt; MAX_STRING_LENGTH:\n                raise IterableTooLong(\"Sorry, I will not evaluate something this long.\")\n            evaluated_values.append(val)\n        return \"\".join(evaluated_values)\n\n    def _eval_formattedvalue(self, node):\n        if node.format_spec:\n            fmt = \"{:\" + self._eval(node.format_spec) + \"}\"\n            return fmt.format(self._eval(node.value))\n        return self._eval(node.value)\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.SafeEval.__init__","title":"<code>__init__(operators=None, functions=None, names=None)</code>","text":"<p>Create the evaluator instance.  Set up valid operators (+,-, etc) functions (add, random, get_val, whatever) and names.</p> Source code in <code>hyfi/utils/safeeval.py</code> <pre><code>def __init__(\n    self,\n    operators: Optional[Dict[Any, Callable]] = None,\n    functions: Optional[Dict[str, Callable]] = None,\n    names: Optional[Dict[str, Any]] = None,\n):\n    \"\"\"\n    Create the evaluator instance.  Set up valid operators (+,-, etc)\n    functions (add, random, get_val, whatever) and names.\"\"\"\n\n    if operators is None:\n        operators = DEFAULT_OPERATORS.copy()\n    if functions is None:\n        functions = DEFAULT_FUNCTIONS.copy()\n    if names is None:\n        names = DEFAULT_NAMES.copy()\n\n    self.operators = operators\n    self.functions = functions\n    self.names = names\n\n    self.nodes = {\n        ast.Expr: self._eval_expr,\n        ast.Assign: self._eval_assign,\n        ast.AugAssign: self._eval_aug_assign,\n        ast.Import: self._eval_import,\n        ast.Num: self._eval_num,\n        ast.Str: self._eval_str,\n        ast.Name: self._eval_name,\n        ast.UnaryOp: self._eval_unaryop,\n        ast.BinOp: self._eval_binop,\n        ast.BoolOp: self._eval_boolop,\n        ast.Compare: self._eval_compare,\n        ast.IfExp: self._eval_ifexp,\n        ast.Call: self._eval_call,\n        ast.keyword: self._eval_keyword,\n        ast.Subscript: self._eval_subscript,\n        ast.Attribute: self._eval_attribute,\n        ast.Index: self._eval_index,\n        ast.Slice: self._eval_slice,\n    }\n\n    # py3k stuff:\n    if hasattr(ast, \"NameConstant\"):\n        self.nodes[ast.NameConstant] = self._eval_constant\n\n    # py3.6, f-strings\n    if hasattr(ast, \"JoinedStr\"):\n        self.nodes[ast.JoinedStr] = self._eval_joinedstr  # f-string\n        self.nodes[ast.FormattedValue] = (\n            self._eval_formattedvalue\n        )  # formatted value in f-string\n\n    # py3.8 uses ast.Constant instead of ast.Num, ast.Str, ast.NameConstant\n    if hasattr(ast, \"Constant\"):\n        self.nodes[ast.Constant] = self._eval_constant\n\n    # Defaults:\n\n    self.ATTR_INDEX_FALLBACK = ATTR_INDEX_FALLBACK\n\n    # Check for forbidden functions:\n\n    for f in self.functions.values():\n        if f in DISALLOW_FUNCTIONS:\n            raise FeatureNotAvailable(f\"This function {f} is a really bad idea.\")\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.SafeEval.eval","title":"<code>eval(expr, previously_parsed=None)</code>","text":"<p>evaluate an expresssion, using the operators, functions and names previously set up.</p> Source code in <code>hyfi/utils/safeeval.py</code> <pre><code>def eval(self, expr, previously_parsed=None):\n    \"\"\"evaluate an expresssion, using the operators, functions and\n    names previously set up.\"\"\"\n\n    # set a copy of the expression aside, so we can give nice errors...\n    self.expr = expr\n\n    return self._eval(previously_parsed or self.parse(expr))\n</code></pre>"},{"location":"reference/utils/#hyfi.utils.SafeEval.parse","title":"<code>parse(expr)</code>  <code>staticmethod</code>","text":"<p>parse an expression into a node tree</p> Source code in <code>hyfi/utils/safeeval.py</code> <pre><code>@staticmethod\ndef parse(expr):\n    \"\"\"parse an expression into a node tree\"\"\"\n\n    parsed = ast.parse(expr.strip())\n\n    if not parsed.body:\n        raise InvalidExpression(\"Sorry, cannot evaluate empty string\")\n    if len(parsed.body) &gt; 1:\n        warnings.warn(\n            f\"'{expr}' contains multiple expressions. Only the first will be used.\",\n            MultipleExpressions,\n        )\n    return parsed.body[0]\n</code></pre>"},{"location":"reference/workflow/","title":"<code>hyfi.workflow</code>","text":""},{"location":"reference/workflow/#hyfi.workflow.Workflow","title":"<code>Workflow</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>hyfi/workflow/workflow.py</code> <pre><code>class Workflow(BaseModel):\n    _config_group_: str = \"/workflow\"\n    _config_name_: str = \"__init__\"\n    _auto_populate_: bool = True\n\n    workflow_name: str = _config_name_\n    project: Optional[Project] = None\n    task: Optional[Task] = None\n    tasks: Optional[List[Union[str, Dict]]] = []\n    pipelines: Optional[List[Union[str, Dict]]] = []\n    verbose: bool = False\n\n    @model_validator(mode=\"before\")\n    def validate_model_config_before(cls, data):\n        # logger.debug(\"Validating model config before validating each field.\")\n        return Composer.to_dict(data)\n\n    def get_running_tasks(self) -&gt; RunningTasks:\n        return get_running_configs(self.tasks or [])\n\n    def get_running_task(self, rc: Running) -&gt; Any:\n        config = getattr(self, rc.uses, None)\n        if rc.uses and isinstance(config, dict):\n            if Composer.is_instantiatable(config):\n                task = Composer.instantiate(config)\n                if task is not None and getattr(task, \"__call__\", None):\n                    return task\n            else:\n                task = Task(**config)\n                task.name = rc.uses\n                return task\n        return None\n\n    def get_task(self):\n        return self.task or Task()\n\n    def run(self):\n        \"\"\"\n        Run the tasks specified in the workflow\n        \"\"\"\n        if self.verbose:\n            logger.info(\"Running %s task(s)\", len(self.tasks or []))\n        # Run all tasks in the workflow.\n        with elapsed_timer(format_time=True) as elapsed:\n            for rc in self.get_running_tasks():\n                task = self.get_running_task(rc)\n                task_name = (\n                    task.task_name\n                    if isinstance(task, Task)\n                    else getattr(task, \"_config_name_\", \"unknown\")\n                )\n                logger.info(\"Running task [%s] with [%s]\", task_name, rc)\n                if isinstance(task, Task):\n                    # Run the task if verbose is true.\n                    task.run()\n                elif task is not None and getattr(task, \"__call__\", None):\n                    if rc.run_kwargs:\n                        task(**rc.run_kwargs)\n                    else:\n                        task()\n                else:\n                    logger.warning(\"Invalid task: %s\", task)\n            # Print the elapsed time.\n            if self.verbose:\n                logger.info(\n                    \" &gt;&gt; elapsed time for the workflow with %s tasks: %s\",\n                    len(self.tasks or []),\n                    elapsed(),\n                )\n        # Run the pipelines in the workflow, if any.\n        if self.pipelines:\n            task = self.get_task()\n            logger.info(\n                \"Running pipelines in the workflow with task [%s]\", task.task_name\n            )\n            task.run(\n                pipelines=self.get_pipelines(),\n            )\n\n    def get_pipelines(self) -&gt; Pipelines:\n        \"\"\"\n        Get the list of pipelines for a workflow\n\n        Args:\n            task: The task to get the pipelines for\n\n        Returns:\n            A list of PipelineConfig objects\n        \"\"\"\n        self.pipelines = self.pipelines or []\n        pipelines: Pipelines = []\n        for name in self.pipelines:\n            if isinstance(name, str) and isinstance(getattr(self, name), dict):\n                pipeline = Pipeline(**getattr(self, name))\n                if not pipeline.name:\n                    pipeline.name = name\n                pipelines.append(pipeline)\n        return pipelines\n</code></pre>"},{"location":"reference/workflow/#hyfi.workflow.Workflow.get_pipelines","title":"<code>get_pipelines()</code>","text":"<p>Get the list of pipelines for a workflow</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <p>The task to get the pipelines for</p> required <p>Returns:</p> Type Description <code>Pipelines</code> <p>A list of PipelineConfig objects</p> Source code in <code>hyfi/workflow/workflow.py</code> <pre><code>def get_pipelines(self) -&gt; Pipelines:\n    \"\"\"\n    Get the list of pipelines for a workflow\n\n    Args:\n        task: The task to get the pipelines for\n\n    Returns:\n        A list of PipelineConfig objects\n    \"\"\"\n    self.pipelines = self.pipelines or []\n    pipelines: Pipelines = []\n    for name in self.pipelines:\n        if isinstance(name, str) and isinstance(getattr(self, name), dict):\n            pipeline = Pipeline(**getattr(self, name))\n            if not pipeline.name:\n                pipeline.name = name\n            pipelines.append(pipeline)\n    return pipelines\n</code></pre>"},{"location":"reference/workflow/#hyfi.workflow.Workflow.run","title":"<code>run()</code>","text":"<p>Run the tasks specified in the workflow</p> Source code in <code>hyfi/workflow/workflow.py</code> <pre><code>def run(self):\n    \"\"\"\n    Run the tasks specified in the workflow\n    \"\"\"\n    if self.verbose:\n        logger.info(\"Running %s task(s)\", len(self.tasks or []))\n    # Run all tasks in the workflow.\n    with elapsed_timer(format_time=True) as elapsed:\n        for rc in self.get_running_tasks():\n            task = self.get_running_task(rc)\n            task_name = (\n                task.task_name\n                if isinstance(task, Task)\n                else getattr(task, \"_config_name_\", \"unknown\")\n            )\n            logger.info(\"Running task [%s] with [%s]\", task_name, rc)\n            if isinstance(task, Task):\n                # Run the task if verbose is true.\n                task.run()\n            elif task is not None and getattr(task, \"__call__\", None):\n                if rc.run_kwargs:\n                    task(**rc.run_kwargs)\n                else:\n                    task()\n            else:\n                logger.warning(\"Invalid task: %s\", task)\n        # Print the elapsed time.\n        if self.verbose:\n            logger.info(\n                \" &gt;&gt; elapsed time for the workflow with %s tasks: %s\",\n                len(self.tasks or []),\n                elapsed(),\n            )\n    # Run the pipelines in the workflow, if any.\n    if self.pipelines:\n        task = self.get_task()\n        logger.info(\n            \"Running pipelines in the workflow with task [%s]\", task.task_name\n        )\n        task.run(\n            pipelines=self.get_pipelines(),\n        )\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/envs/","title":"Environment variables","text":""},{"location":"usage/envs/#utils","title":"Utils","text":"<p>Here's an example of how you can use the expand_posix_vars function in a Python script:</p> <pre><code>from hypi.utils.envs import ENVs\n\n# Define a POSIX expression with variables\nposix_expr = \"The current working directory is $PWD and the user is $USER.\"\n\n# Call the expand_posix_vars function with the POSIX expression\nexpanded_expr = ENVs.expand_posix_vars(posix_expr)\n\n# Print the expanded expression\nprint(expanded_expr)\n</code></pre> <p>In this example, we import the <code>expand_posix_vars</code> function from the env module. We then define a POSIX expression with two variables, <code>$PWD</code> and <code>$USER</code>. We call the <code>expand_posix_vars</code> function with the POSIX expression as an argument, which expands the variables using the current working directory and the current user. Finally, we print the expanded expression, which should output something like:</p> <pre><code>The current working directory is /home/user and the user is user.\n</code></pre> <p>You can also pass in a dictionary of additional variables to be used in the expansion, like this:</p> <pre><code>from hypi.utils.envs import ENVs\n\n# Define a POSIX expression with variables\nposix_expr = \"The value of MY_VAR is $MY_VAR.\"\n\n# Define a dictionary of additional variables\ncontext = {\"MY_VAR\": \"hello world\"}\n\n# Call the expand_posix_vars function with the POSIX expression and context\nexpanded_expr = ENVs.expand_posix_vars(posix_expr, context)\n\n# Print the expanded expression\nprint(expanded_expr)\n</code></pre> <p>In this example, we define a POSIX expression with a single variable, <code>$MY_VAR</code>. We also define a dictionary of additional variables with a key of <code>MY_VAR</code> and a value of hello world. We call the <code>expand_posix_vars</code> function with the POSIX expression and context as arguments, which expands the <code>$MY_VAR</code> variable to hello world. Finally, we print the expanded expression, which should output:</p> <pre><code>The value of MY_VAR is hello world.\n</code></pre>"}]}